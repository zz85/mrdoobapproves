/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(2);
	__webpack_require__(3);
	__webpack_require__(4);
	__webpack_require__(5);
	__webpack_require__(6);
	__webpack_require__(7);
	__webpack_require__(11);
	__webpack_require__(13);
	__webpack_require__(15);
	__webpack_require__(17);
	module.exports = __webpack_require__(18);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	// This is CodeMirror (http://codemirror.net), a code editor
	// implemented in JavaScript on top of the browser's DOM.
	//
	// You can find some technical background for some of the code below
	// at http://marijnhaverbeke.nl/blog/#cm-internals .

	(function(mod) {
	  if (true) // CommonJS
	    module.exports = mod();
	  else if (typeof define == "function" && define.amd) // AMD
	    return define([], mod);
	  else // Plain browser env
	    this.CodeMirror = mod();
	})(function() {
	  "use strict";

	  // BROWSER SNIFFING

	  // Kludges for bugs and behavior differences that can't be feature
	  // detected are enabled based on userAgent etc sniffing.

	  var gecko = /gecko\/\d/i.test(navigator.userAgent);
	  // ie_uptoN means Internet Explorer version N or lower
	  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
	  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
	  var ie = ie_upto10 || ie_11up;
	  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
	  var webkit = /WebKit\//.test(navigator.userAgent);
	  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
	  var chrome = /Chrome\//.test(navigator.userAgent);
	  var presto = /Opera\//.test(navigator.userAgent);
	  var safari = /Apple Computer/.test(navigator.vendor);
	  var khtml = /KHTML\//.test(navigator.userAgent);
	  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
	  var phantom = /PhantomJS/.test(navigator.userAgent);

	  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
	  // This is woefully incomplete. Suggestions for alternative methods welcome.
	  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
	  var mac = ios || /Mac/.test(navigator.platform);
	  var windows = /win/i.test(navigator.platform);

	  var presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
	  if (presto_version) presto_version = Number(presto_version[1]);
	  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
	  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
	  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
	  var captureRightClick = gecko || (ie && ie_version >= 9);

	  // Optimize some code when these features are not used.
	  var sawReadOnlySpans = false, sawCollapsedSpans = false;

	  // EDITOR CONSTRUCTOR

	  // A CodeMirror instance represents an editor. This is the object
	  // that user code is usually dealing with.

	  function CodeMirror(place, options) {
	    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

	    this.options = options = options ? copyObj(options) : {};
	    // Determine effective options based on given values and defaults.
	    copyObj(defaults, options, false);
	    setGuttersForLineNumbers(options);

	    var doc = options.value;
	    if (typeof doc == "string") doc = new Doc(doc, options.mode);
	    this.doc = doc;

	    var display = this.display = new Display(place, doc);
	    display.wrapper.CodeMirror = this;
	    updateGutters(this);
	    themeChanged(this);
	    if (options.lineWrapping)
	      this.display.wrapper.className += " CodeMirror-wrap";
	    if (options.autofocus && !mobile) focusInput(this);
	    initScrollbars(this);

	    this.state = {
	      keyMaps: [],  // stores maps added by addKeyMap
	      overlays: [], // highlighting overlays, as added by addOverlay
	      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
	      overwrite: false, focused: false,
	      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
	      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in readInput
	      draggingText: false,
	      highlight: new Delayed(), // stores highlight worker timeout
	      keySeq: null  // Unfinished key sequence
	    };

	    // Override magic textarea content restore that IE sometimes does
	    // on our hidden textarea on reload
	    if (ie && ie_version < 11) setTimeout(bind(resetInput, this, true), 20);

	    registerEventHandlers(this);
	    ensureGlobalHandlers();

	    startOperation(this);
	    this.curOp.forceUpdate = true;
	    attachDoc(this, doc);

	    if ((options.autofocus && !mobile) || activeElt() == display.input)
	      setTimeout(bind(onFocus, this), 20);
	    else
	      onBlur(this);

	    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
	      optionHandlers[opt](this, options[opt], Init);
	    maybeUpdateLineNumberWidth(this);
	    if (options.finishInit) options.finishInit(this);
	    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
	    endOperation(this);
	    // Suppress optimizelegibility in Webkit, since it breaks text
	    // measuring on line wrapping boundaries.
	    if (webkit && options.lineWrapping &&
	        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
	      display.lineDiv.style.textRendering = "auto";
	  }

	  // DISPLAY CONSTRUCTOR

	  // The display handles the DOM integration, both for input reading
	  // and content drawing. It holds references to DOM nodes and
	  // display-related state.

	  function Display(place, doc) {
	    var d = this;

	    // The semihidden textarea that is focused when the editor is
	    // focused, and receives input.
	    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
	    // The textarea is kept positioned near the cursor to prevent the
	    // fact that it'll be scrolled into view on input from scrolling
	    // our fake cursor out of view. On webkit, when wrap=off, paste is
	    // very slow. So make the area wide instead.
	    if (webkit) input.style.width = "1000px";
	    else input.setAttribute("wrap", "off");
	    // If border: 0; -- iOS fails to open keyboard (issue #1287)
	    if (ios) input.style.border = "1px solid black";
	    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");

	    // Wraps and hides input textarea
	    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
	    // Covers bottom-right square when both scrollbars are present.
	    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
	    d.scrollbarFiller.setAttribute("not-content", "true");
	    // Covers bottom of gutter when coverGutterNextToScrollbar is on
	    // and h scrollbar is present.
	    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
	    d.gutterFiller.setAttribute("not-content", "true");
	    // Will contain the actual code, positioned to cover the viewport.
	    d.lineDiv = elt("div", null, "CodeMirror-code");
	    // Elements are added to these to represent selection and cursors.
	    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
	    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
	    // A visibility: hidden element used to find the size of things.
	    d.measure = elt("div", null, "CodeMirror-measure");
	    // When lines outside of the viewport are measured, they are drawn in this.
	    d.lineMeasure = elt("div", null, "CodeMirror-measure");
	    // Wraps everything that needs to exist inside the vertically-padded coordinate system
	    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
	                      null, "position: relative; outline: none");
	    // Moved around its parent to cover visible view.
	    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
	    // Set to the height of the document, allowing scrolling.
	    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
	    d.sizerWidth = null;
	    // Behavior of elts with overflow: auto and padding is
	    // inconsistent across browsers. This is used to ensure the
	    // scrollable area is big enough.
	    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
	    // Will contain the gutters, if any.
	    d.gutters = elt("div", null, "CodeMirror-gutters");
	    d.lineGutter = null;
	    // Actual scrollable element.
	    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
	    d.scroller.setAttribute("tabIndex", "-1");
	    // The element in which the editor lives.
	    d.wrapper = elt("div", [d.inputDiv, d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

	    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
	    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
	    // Needed to hide big blue blinking cursor on Mobile Safari
	    if (ios) input.style.width = "0px";
	    if (!webkit) d.scroller.draggable = true;
	    // Needed to handle Tab key in KHTML
	    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }

	    if (place) {
	      if (place.appendChild) place.appendChild(d.wrapper);
	      else place(d.wrapper);
	    }

	    // Current rendered range (may be bigger than the view window).
	    d.viewFrom = d.viewTo = doc.first;
	    d.reportedViewFrom = d.reportedViewTo = doc.first;
	    // Information about the rendered lines.
	    d.view = [];
	    d.renderedView = null;
	    // Holds info about a single rendered line when it was rendered
	    // for measurement, while not in view.
	    d.externalMeasured = null;
	    // Empty space (in pixels) above the view
	    d.viewOffset = 0;
	    d.lastWrapHeight = d.lastWrapWidth = 0;
	    d.updateLineNumbers = null;

	    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
	    d.scrollbarsClipped = false;

	    // Used to only resize the line number gutter when necessary (when
	    // the amount of lines crosses a boundary that makes its width change)
	    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
	    // See readInput and resetInput
	    d.prevInput = "";
	    // Set to true when a non-horizontal-scrolling line widget is
	    // added. As an optimization, line widget aligning is skipped when
	    // this is false.
	    d.alignWidgets = false;
	    // Flag that indicates whether we expect input to appear real soon
	    // now (after some event like 'keypress' or 'input') and are
	    // polling intensively.
	    d.pollingFast = false;
	    // Self-resetting timeout for the poller
	    d.poll = new Delayed();

	    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

	    // Tracks when resetInput has punted to just putting a short
	    // string into the textarea instead of the full selection.
	    d.inaccurateSelection = false;

	    // Tracks the maximum line length so that the horizontal scrollbar
	    // can be kept static when scrolling.
	    d.maxLine = null;
	    d.maxLineLength = 0;
	    d.maxLineChanged = false;

	    // Used for measuring wheel scrolling granularity
	    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

	    // True when shift is held down.
	    d.shift = false;

	    // Used to track whether anything happened since the context menu
	    // was opened.
	    d.selForContextMenu = null;
	  }

	  // STATE UPDATES

	  // Used to get the editor into a consistent state again when options change.

	  function loadMode(cm) {
	    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
	    resetModeState(cm);
	  }

	  function resetModeState(cm) {
	    cm.doc.iter(function(line) {
	      if (line.stateAfter) line.stateAfter = null;
	      if (line.styles) line.styles = null;
	    });
	    cm.doc.frontier = cm.doc.first;
	    startWorker(cm, 100);
	    cm.state.modeGen++;
	    if (cm.curOp) regChange(cm);
	  }

	  function wrappingChanged(cm) {
	    if (cm.options.lineWrapping) {
	      addClass(cm.display.wrapper, "CodeMirror-wrap");
	      cm.display.sizer.style.minWidth = "";
	      cm.display.sizerWidth = null;
	    } else {
	      rmClass(cm.display.wrapper, "CodeMirror-wrap");
	      findMaxLine(cm);
	    }
	    estimateLineHeights(cm);
	    regChange(cm);
	    clearCaches(cm);
	    setTimeout(function(){updateScrollbars(cm);}, 100);
	  }

	  // Returns a function that estimates the height of a line, to use as
	  // first approximation until the line becomes visible (and is thus
	  // properly measurable).
	  function estimateHeight(cm) {
	    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
	    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
	    return function(line) {
	      if (lineIsHidden(cm.doc, line)) return 0;

	      var widgetsHeight = 0;
	      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
	        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
	      }

	      if (wrapping)
	        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
	      else
	        return widgetsHeight + th;
	    };
	  }

	  function estimateLineHeights(cm) {
	    var doc = cm.doc, est = estimateHeight(cm);
	    doc.iter(function(line) {
	      var estHeight = est(line);
	      if (estHeight != line.height) updateLineHeight(line, estHeight);
	    });
	  }

	  function themeChanged(cm) {
	    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
	      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
	    clearCaches(cm);
	  }

	  function guttersChanged(cm) {
	    updateGutters(cm);
	    regChange(cm);
	    setTimeout(function(){alignHorizontally(cm);}, 20);
	  }

	  // Rebuild the gutter elements, ensure the margin to the left of the
	  // code matches their width.
	  function updateGutters(cm) {
	    var gutters = cm.display.gutters, specs = cm.options.gutters;
	    removeChildren(gutters);
	    for (var i = 0; i < specs.length; ++i) {
	      var gutterClass = specs[i];
	      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
	      if (gutterClass == "CodeMirror-linenumbers") {
	        cm.display.lineGutter = gElt;
	        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
	      }
	    }
	    gutters.style.display = i ? "" : "none";
	    updateGutterSpace(cm);
	  }

	  function updateGutterSpace(cm) {
	    var width = cm.display.gutters.offsetWidth;
	    cm.display.sizer.style.marginLeft = width + "px";
	  }

	  // Compute the character length of a line, taking into account
	  // collapsed ranges (see markText) that might hide parts, and join
	  // other lines onto it.
	  function lineLength(line) {
	    if (line.height == 0) return 0;
	    var len = line.text.length, merged, cur = line;
	    while (merged = collapsedSpanAtStart(cur)) {
	      var found = merged.find(0, true);
	      cur = found.from.line;
	      len += found.from.ch - found.to.ch;
	    }
	    cur = line;
	    while (merged = collapsedSpanAtEnd(cur)) {
	      var found = merged.find(0, true);
	      len -= cur.text.length - found.from.ch;
	      cur = found.to.line;
	      len += cur.text.length - found.to.ch;
	    }
	    return len;
	  }

	  // Find the longest line in the document.
	  function findMaxLine(cm) {
	    var d = cm.display, doc = cm.doc;
	    d.maxLine = getLine(doc, doc.first);
	    d.maxLineLength = lineLength(d.maxLine);
	    d.maxLineChanged = true;
	    doc.iter(function(line) {
	      var len = lineLength(line);
	      if (len > d.maxLineLength) {
	        d.maxLineLength = len;
	        d.maxLine = line;
	      }
	    });
	  }

	  // Make sure the gutters options contains the element
	  // "CodeMirror-linenumbers" when the lineNumbers option is true.
	  function setGuttersForLineNumbers(options) {
	    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
	    if (found == -1 && options.lineNumbers) {
	      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
	    } else if (found > -1 && !options.lineNumbers) {
	      options.gutters = options.gutters.slice(0);
	      options.gutters.splice(found, 1);
	    }
	  }

	  // SCROLLBARS

	  // Prepare DOM reads needed to update the scrollbars. Done in one
	  // shot to minimize update/measure roundtrips.
	  function measureForScrollbars(cm) {
	    var d = cm.display, gutterW = d.gutters.offsetWidth;
	    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
	    return {
	      clientHeight: d.scroller.clientHeight,
	      viewHeight: d.wrapper.clientHeight,
	      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
	      viewWidth: d.wrapper.clientWidth,
	      barLeft: cm.options.fixedGutter ? gutterW : 0,
	      docHeight: docH,
	      scrollHeight: docH + scrollGap(cm) + d.barHeight,
	      nativeBarWidth: d.nativeBarWidth,
	      gutterWidth: gutterW
	    };
	  }

	  function NativeScrollbars(place, scroll, cm) {
	    this.cm = cm;
	    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
	    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
	    place(vert); place(horiz);

	    on(vert, "scroll", function() {
	      if (vert.clientHeight) scroll(vert.scrollTop, "vertical");
	    });
	    on(horiz, "scroll", function() {
	      if (horiz.clientWidth) scroll(horiz.scrollLeft, "horizontal");
	    });

	    this.checkedOverlay = false;
	    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
	    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
	  }

	  NativeScrollbars.prototype = copyObj({
	    update: function(measure) {
	      var needsH = measure.scrollWidth > measure.clientWidth + 1;
	      var needsV = measure.scrollHeight > measure.clientHeight + 1;
	      var sWidth = measure.nativeBarWidth;

	      if (needsV) {
	        this.vert.style.display = "block";
	        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
	        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
	        // A bug in IE8 can cause this value to be negative, so guard it.
	        this.vert.firstChild.style.height =
	          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
	      } else {
	        this.vert.style.display = "";
	        this.vert.firstChild.style.height = "0";
	      }

	      if (needsH) {
	        this.horiz.style.display = "block";
	        this.horiz.style.right = needsV ? sWidth + "px" : "0";
	        this.horiz.style.left = measure.barLeft + "px";
	        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
	        this.horiz.firstChild.style.width =
	          (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
	      } else {
	        this.horiz.style.display = "";
	        this.horiz.firstChild.style.width = "0";
	      }

	      if (!this.checkedOverlay && measure.clientHeight > 0) {
	        if (sWidth == 0) this.overlayHack();
	        this.checkedOverlay = true;
	      }

	      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};
	    },
	    setScrollLeft: function(pos) {
	      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;
	    },
	    setScrollTop: function(pos) {
	      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;
	    },
	    overlayHack: function() {
	      var w = mac && !mac_geMountainLion ? "12px" : "18px";
	      this.horiz.style.minHeight = this.vert.style.minWidth = w;
	      var self = this;
	      var barMouseDown = function(e) {
	        if (e_target(e) != self.vert && e_target(e) != self.horiz)
	          operation(self.cm, onMouseDown)(e);
	      };
	      on(this.vert, "mousedown", barMouseDown);
	      on(this.horiz, "mousedown", barMouseDown);
	    },
	    clear: function() {
	      var parent = this.horiz.parentNode;
	      parent.removeChild(this.horiz);
	      parent.removeChild(this.vert);
	    }
	  }, NativeScrollbars.prototype);

	  function NullScrollbars() {}

	  NullScrollbars.prototype = copyObj({
	    update: function() { return {bottom: 0, right: 0}; },
	    setScrollLeft: function() {},
	    setScrollTop: function() {},
	    clear: function() {}
	  }, NullScrollbars.prototype);

	  CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

	  function initScrollbars(cm) {
	    if (cm.display.scrollbars) {
	      cm.display.scrollbars.clear();
	      if (cm.display.scrollbars.addClass)
	        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
	    }

	    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
	      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
	      on(node, "mousedown", function() {
	        if (cm.state.focused) setTimeout(bind(focusInput, cm), 0);
	      });
	      node.setAttribute("not-content", "true");
	    }, function(pos, axis) {
	      if (axis == "horizontal") setScrollLeft(cm, pos);
	      else setScrollTop(cm, pos);
	    }, cm);
	    if (cm.display.scrollbars.addClass)
	      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
	  }

	  function updateScrollbars(cm, measure) {
	    if (!measure) measure = measureForScrollbars(cm);
	    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
	    updateScrollbarsInner(cm, measure);
	    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
	      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
	        updateHeightsInViewport(cm);
	      updateScrollbarsInner(cm, measureForScrollbars(cm));
	      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
	    }
	  }

	  // Re-synchronize the fake scrollbars with the actual size of the
	  // content.
	  function updateScrollbarsInner(cm, measure) {
	    var d = cm.display;
	    var sizes = d.scrollbars.update(measure);

	    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
	    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";

	    if (sizes.right && sizes.bottom) {
	      d.scrollbarFiller.style.display = "block";
	      d.scrollbarFiller.style.height = sizes.bottom + "px";
	      d.scrollbarFiller.style.width = sizes.right + "px";
	    } else d.scrollbarFiller.style.display = "";
	    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
	      d.gutterFiller.style.display = "block";
	      d.gutterFiller.style.height = sizes.bottom + "px";
	      d.gutterFiller.style.width = measure.gutterWidth + "px";
	    } else d.gutterFiller.style.display = "";
	  }

	  // Compute the lines that are visible in a given viewport (defaults
	  // the the current scroll position). viewport may contain top,
	  // height, and ensure (see op.scrollToPos) properties.
	  function visibleLines(display, doc, viewport) {
	    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
	    top = Math.floor(top - paddingTop(display));
	    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

	    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
	    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
	    // forces those lines into the viewport (if possible).
	    if (viewport && viewport.ensure) {
	      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
	      if (ensureFrom < from) {
	        from = ensureFrom;
	        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
	      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
	        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
	        to = ensureTo;
	      }
	    }
	    return {from: from, to: Math.max(to, from + 1)};
	  }

	  // LINE NUMBERS

	  // Re-align line numbers and gutter marks to compensate for
	  // horizontal scrolling.
	  function alignHorizontally(cm) {
	    var display = cm.display, view = display.view;
	    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
	    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
	    var gutterW = display.gutters.offsetWidth, left = comp + "px";
	    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
	      if (cm.options.fixedGutter && view[i].gutter)
	        view[i].gutter.style.left = left;
	      var align = view[i].alignable;
	      if (align) for (var j = 0; j < align.length; j++)
	        align[j].style.left = left;
	    }
	    if (cm.options.fixedGutter)
	      display.gutters.style.left = (comp + gutterW) + "px";
	  }

	  // Used to ensure that the line number gutter is still the right
	  // size for the current document size. Returns true when an update
	  // is needed.
	  function maybeUpdateLineNumberWidth(cm) {
	    if (!cm.options.lineNumbers) return false;
	    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
	    if (last.length != display.lineNumChars) {
	      var test = display.measure.appendChild(elt("div", [elt("div", last)],
	                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
	      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
	      display.lineGutter.style.width = "";
	      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
	      display.lineNumWidth = display.lineNumInnerWidth + padding;
	      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
	      display.lineGutter.style.width = display.lineNumWidth + "px";
	      updateGutterSpace(cm);
	      return true;
	    }
	    return false;
	  }

	  function lineNumberFor(options, i) {
	    return String(options.lineNumberFormatter(i + options.firstLineNumber));
	  }

	  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
	  // but using getBoundingClientRect to get a sub-pixel-accurate
	  // result.
	  function compensateForHScroll(display) {
	    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
	  }

	  // DISPLAY DRAWING

	  function DisplayUpdate(cm, viewport, force) {
	    var display = cm.display;

	    this.viewport = viewport;
	    // Store some values that we'll need later (but don't want to force a relayout for)
	    this.visible = visibleLines(display, cm.doc, viewport);
	    this.editorIsHidden = !display.wrapper.offsetWidth;
	    this.wrapperHeight = display.wrapper.clientHeight;
	    this.wrapperWidth = display.wrapper.clientWidth;
	    this.oldDisplayWidth = displayWidth(cm);
	    this.force = force;
	    this.dims = getDimensions(cm);
	    this.events = [];
	  }

	  DisplayUpdate.prototype.signal = function(emitter, type) {
	    if (hasHandler(emitter, type))
	      this.events.push(arguments);
	  };
	  DisplayUpdate.prototype.finish = function() {
	    for (var i = 0; i < this.events.length; i++)
	      signal.apply(null, this.events[i]);
	  };

	  function maybeClipScrollbars(cm) {
	    var display = cm.display;
	    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
	      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
	      display.heightForcer.style.height = scrollGap(cm) + "px";
	      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
	      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
	      display.scrollbarsClipped = true;
	    }
	  }

	  // Does the actual updating of the line display. Bails out
	  // (returning false) when there is nothing to be done and forced is
	  // false.
	  function updateDisplayIfNeeded(cm, update) {
	    var display = cm.display, doc = cm.doc;

	    if (update.editorIsHidden) {
	      resetView(cm);
	      return false;
	    }

	    // Bail out if the visible area is already rendered and nothing changed.
	    if (!update.force &&
	        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
	        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
	        display.renderedView == display.view && countDirtyView(cm) == 0)
	      return false;

	    if (maybeUpdateLineNumberWidth(cm)) {
	      resetView(cm);
	      update.dims = getDimensions(cm);
	    }

	    // Compute a suitable new viewport (from & to)
	    var end = doc.first + doc.size;
	    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
	    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
	    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
	    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
	    if (sawCollapsedSpans) {
	      from = visualLineNo(cm.doc, from);
	      to = visualLineEndNo(cm.doc, to);
	    }

	    var different = from != display.viewFrom || to != display.viewTo ||
	      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
	    adjustView(cm, from, to);

	    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
	    // Position the mover div to align with the current scroll position
	    cm.display.mover.style.top = display.viewOffset + "px";

	    var toUpdate = countDirtyView(cm);
	    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
	        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
	      return false;

	    // For big changes, we hide the enclosing element during the
	    // update, since that speeds up the operations on most browsers.
	    var focused = activeElt();
	    if (toUpdate > 4) display.lineDiv.style.display = "none";
	    patchDisplay(cm, display.updateLineNumbers, update.dims);
	    if (toUpdate > 4) display.lineDiv.style.display = "";
	    display.renderedView = display.view;
	    // There might have been a widget with a focused element that got
	    // hidden or updated, if so re-focus it.
	    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

	    // Prevent selection and cursors from interfering with the scroll
	    // width and height.
	    removeChildren(display.cursorDiv);
	    removeChildren(display.selectionDiv);
	    display.gutters.style.height = 0;

	    if (different) {
	      display.lastWrapHeight = update.wrapperHeight;
	      display.lastWrapWidth = update.wrapperWidth;
	      startWorker(cm, 400);
	    }

	    display.updateLineNumbers = null;

	    return true;
	  }

	  function postUpdateDisplay(cm, update) {
	    var force = update.force, viewport = update.viewport;
	    for (var first = true;; first = false) {
	      if (first && cm.options.lineWrapping && update.oldDisplayWidth != displayWidth(cm)) {
	        force = true;
	      } else {
	        force = false;
	        // Clip forced viewport to actual scrollable area.
	        if (viewport && viewport.top != null)
	          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
	        // Updated line heights might result in the drawn area not
	        // actually covering the viewport. Keep looping until it does.
	        update.visible = visibleLines(cm.display, cm.doc, viewport);
	        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
	          break;
	      }
	      if (!updateDisplayIfNeeded(cm, update)) break;
	      updateHeightsInViewport(cm);
	      var barMeasure = measureForScrollbars(cm);
	      updateSelection(cm);
	      setDocumentHeight(cm, barMeasure);
	      updateScrollbars(cm, barMeasure);
	    }

	    update.signal(cm, "update", cm);
	    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
	      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
	      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
	    }
	  }

	  function updateDisplaySimple(cm, viewport) {
	    var update = new DisplayUpdate(cm, viewport);
	    if (updateDisplayIfNeeded(cm, update)) {
	      updateHeightsInViewport(cm);
	      postUpdateDisplay(cm, update);
	      var barMeasure = measureForScrollbars(cm);
	      updateSelection(cm);
	      setDocumentHeight(cm, barMeasure);
	      updateScrollbars(cm, barMeasure);
	      update.finish();
	    }
	  }

	  function setDocumentHeight(cm, measure) {
	    cm.display.sizer.style.minHeight = measure.docHeight + "px";
	    var total = measure.docHeight + cm.display.barHeight;
	    cm.display.heightForcer.style.top = total + "px";
	    cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + "px";
	  }

	  // Read the actual heights of the rendered lines, and update their
	  // stored heights to match.
	  function updateHeightsInViewport(cm) {
	    var display = cm.display;
	    var prevBottom = display.lineDiv.offsetTop;
	    for (var i = 0; i < display.view.length; i++) {
	      var cur = display.view[i], height;
	      if (cur.hidden) continue;
	      if (ie && ie_version < 8) {
	        var bot = cur.node.offsetTop + cur.node.offsetHeight;
	        height = bot - prevBottom;
	        prevBottom = bot;
	      } else {
	        var box = cur.node.getBoundingClientRect();
	        height = box.bottom - box.top;
	      }
	      var diff = cur.line.height - height;
	      if (height < 2) height = textHeight(display);
	      if (diff > .001 || diff < -.001) {
	        updateLineHeight(cur.line, height);
	        updateWidgetHeight(cur.line);
	        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
	          updateWidgetHeight(cur.rest[j]);
	      }
	    }
	  }

	  // Read and store the height of line widgets associated with the
	  // given line.
	  function updateWidgetHeight(line) {
	    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
	      line.widgets[i].height = line.widgets[i].node.offsetHeight;
	  }

	  // Do a bulk-read of the DOM positions and sizes needed to draw the
	  // view, so that we don't interleave reading and writing to the DOM.
	  function getDimensions(cm) {
	    var d = cm.display, left = {}, width = {};
	    var gutterLeft = d.gutters.clientLeft;
	    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
	      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
	      width[cm.options.gutters[i]] = n.clientWidth;
	    }
	    return {fixedPos: compensateForHScroll(d),
	            gutterTotalWidth: d.gutters.offsetWidth,
	            gutterLeft: left,
	            gutterWidth: width,
	            wrapperWidth: d.wrapper.clientWidth};
	  }

	  // Sync the actual display DOM structure with display.view, removing
	  // nodes for lines that are no longer in view, and creating the ones
	  // that are not there yet, and updating the ones that are out of
	  // date.
	  function patchDisplay(cm, updateNumbersFrom, dims) {
	    var display = cm.display, lineNumbers = cm.options.lineNumbers;
	    var container = display.lineDiv, cur = container.firstChild;

	    function rm(node) {
	      var next = node.nextSibling;
	      // Works around a throw-scroll bug in OS X Webkit
	      if (webkit && mac && cm.display.currentWheelTarget == node)
	        node.style.display = "none";
	      else
	        node.parentNode.removeChild(node);
	      return next;
	    }

	    var view = display.view, lineN = display.viewFrom;
	    // Loop over the elements in the view, syncing cur (the DOM nodes
	    // in display.lineDiv) with the view as we go.
	    for (var i = 0; i < view.length; i++) {
	      var lineView = view[i];
	      if (lineView.hidden) {
	      } else if (!lineView.node) { // Not drawn yet
	        var node = buildLineElement(cm, lineView, lineN, dims);
	        container.insertBefore(node, cur);
	      } else { // Already drawn
	        while (cur != lineView.node) cur = rm(cur);
	        var updateNumber = lineNumbers && updateNumbersFrom != null &&
	          updateNumbersFrom <= lineN && lineView.lineNumber;
	        if (lineView.changes) {
	          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
	          updateLineForChanges(cm, lineView, lineN, dims);
	        }
	        if (updateNumber) {
	          removeChildren(lineView.lineNumber);
	          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
	        }
	        cur = lineView.node.nextSibling;
	      }
	      lineN += lineView.size;
	    }
	    while (cur) cur = rm(cur);
	  }

	  // When an aspect of a line changes, a string is added to
	  // lineView.changes. This updates the relevant part of the line's
	  // DOM structure.
	  function updateLineForChanges(cm, lineView, lineN, dims) {
	    for (var j = 0; j < lineView.changes.length; j++) {
	      var type = lineView.changes[j];
	      if (type == "text") updateLineText(cm, lineView);
	      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
	      else if (type == "class") updateLineClasses(lineView);
	      else if (type == "widget") updateLineWidgets(lineView, dims);
	    }
	    lineView.changes = null;
	  }

	  // Lines with gutter elements, widgets or a background class need to
	  // be wrapped, and have the extra elements added to the wrapper div
	  function ensureLineWrapped(lineView) {
	    if (lineView.node == lineView.text) {
	      lineView.node = elt("div", null, null, "position: relative");
	      if (lineView.text.parentNode)
	        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
	      lineView.node.appendChild(lineView.text);
	      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;
	    }
	    return lineView.node;
	  }

	  function updateLineBackground(lineView) {
	    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
	    if (cls) cls += " CodeMirror-linebackground";
	    if (lineView.background) {
	      if (cls) lineView.background.className = cls;
	      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
	    } else if (cls) {
	      var wrap = ensureLineWrapped(lineView);
	      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
	    }
	  }

	  // Wrapper around buildLineContent which will reuse the structure
	  // in display.externalMeasured when possible.
	  function getLineContent(cm, lineView) {
	    var ext = cm.display.externalMeasured;
	    if (ext && ext.line == lineView.line) {
	      cm.display.externalMeasured = null;
	      lineView.measure = ext.measure;
	      return ext.built;
	    }
	    return buildLineContent(cm, lineView);
	  }

	  // Redraw the line's text. Interacts with the background and text
	  // classes because the mode may output tokens that influence these
	  // classes.
	  function updateLineText(cm, lineView) {
	    var cls = lineView.text.className;
	    var built = getLineContent(cm, lineView);
	    if (lineView.text == lineView.node) lineView.node = built.pre;
	    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
	    lineView.text = built.pre;
	    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
	      lineView.bgClass = built.bgClass;
	      lineView.textClass = built.textClass;
	      updateLineClasses(lineView);
	    } else if (cls) {
	      lineView.text.className = cls;
	    }
	  }

	  function updateLineClasses(lineView) {
	    updateLineBackground(lineView);
	    if (lineView.line.wrapClass)
	      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
	    else if (lineView.node != lineView.text)
	      lineView.node.className = "";
	    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
	    lineView.text.className = textClass || "";
	  }

	  function updateLineGutter(cm, lineView, lineN, dims) {
	    if (lineView.gutter) {
	      lineView.node.removeChild(lineView.gutter);
	      lineView.gutter = null;
	    }
	    var markers = lineView.line.gutterMarkers;
	    if (cm.options.lineNumbers || markers) {
	      var wrap = ensureLineWrapped(lineView);
	      var gutterWrap = lineView.gutter =
	        wrap.insertBefore(elt("div", null, "CodeMirror-gutter-wrapper", "left: " +
	                              (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +
	                              "px; width: " + dims.gutterTotalWidth + "px"),
	                          lineView.text);
	      if (lineView.line.gutterClass)
	        gutterWrap.className += " " + lineView.line.gutterClass;
	      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
	        lineView.lineNumber = gutterWrap.appendChild(
	          elt("div", lineNumberFor(cm.options, lineN),
	              "CodeMirror-linenumber CodeMirror-gutter-elt",
	              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
	              + cm.display.lineNumInnerWidth + "px"));
	      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
	        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
	        if (found)
	          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
	                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
	      }
	    }
	  }

	  function updateLineWidgets(lineView, dims) {
	    if (lineView.alignable) lineView.alignable = null;
	    for (var node = lineView.node.firstChild, next; node; node = next) {
	      var next = node.nextSibling;
	      if (node.className == "CodeMirror-linewidget")
	        lineView.node.removeChild(node);
	    }
	    insertLineWidgets(lineView, dims);
	  }

	  // Build a line's DOM representation from scratch
	  function buildLineElement(cm, lineView, lineN, dims) {
	    var built = getLineContent(cm, lineView);
	    lineView.text = lineView.node = built.pre;
	    if (built.bgClass) lineView.bgClass = built.bgClass;
	    if (built.textClass) lineView.textClass = built.textClass;

	    updateLineClasses(lineView);
	    updateLineGutter(cm, lineView, lineN, dims);
	    insertLineWidgets(lineView, dims);
	    return lineView.node;
	  }

	  // A lineView may contain multiple logical lines (when merged by
	  // collapsed spans). The widgets for all of them need to be drawn.
	  function insertLineWidgets(lineView, dims) {
	    insertLineWidgetsFor(lineView.line, lineView, dims, true);
	    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
	      insertLineWidgetsFor(lineView.rest[i], lineView, dims, false);
	  }

	  function insertLineWidgetsFor(line, lineView, dims, allowAbove) {
	    if (!line.widgets) return;
	    var wrap = ensureLineWrapped(lineView);
	    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
	      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
	      if (!widget.handleMouseEvents) node.setAttribute("cm-ignore-events", "true");
	      positionLineWidget(widget, node, lineView, dims);
	      if (allowAbove && widget.above)
	        wrap.insertBefore(node, lineView.gutter || lineView.text);
	      else
	        wrap.appendChild(node);
	      signalLater(widget, "redraw");
	    }
	  }

	  function positionLineWidget(widget, node, lineView, dims) {
	    if (widget.noHScroll) {
	      (lineView.alignable || (lineView.alignable = [])).push(node);
	      var width = dims.wrapperWidth;
	      node.style.left = dims.fixedPos + "px";
	      if (!widget.coverGutter) {
	        width -= dims.gutterTotalWidth;
	        node.style.paddingLeft = dims.gutterTotalWidth + "px";
	      }
	      node.style.width = width + "px";
	    }
	    if (widget.coverGutter) {
	      node.style.zIndex = 5;
	      node.style.position = "relative";
	      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
	    }
	  }

	  // POSITION OBJECT

	  // A Pos instance represents a position within the text.
	  var Pos = CodeMirror.Pos = function(line, ch) {
	    if (!(this instanceof Pos)) return new Pos(line, ch);
	    this.line = line; this.ch = ch;
	  };

	  // Compare two positions, return 0 if they are the same, a negative
	  // number when a is less, and a positive number otherwise.
	  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

	  function copyPos(x) {return Pos(x.line, x.ch);}
	  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
	  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

	  // SELECTION / CURSOR

	  // Selection objects are immutable. A new one is created every time
	  // the selection changes. A selection is one or more non-overlapping
	  // (and non-touching) ranges, sorted, and an integer that indicates
	  // which one is the primary selection (the one that's scrolled into
	  // view, that getCursor returns, etc).
	  function Selection(ranges, primIndex) {
	    this.ranges = ranges;
	    this.primIndex = primIndex;
	  }

	  Selection.prototype = {
	    primary: function() { return this.ranges[this.primIndex]; },
	    equals: function(other) {
	      if (other == this) return true;
	      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
	      for (var i = 0; i < this.ranges.length; i++) {
	        var here = this.ranges[i], there = other.ranges[i];
	        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
	      }
	      return true;
	    },
	    deepCopy: function() {
	      for (var out = [], i = 0; i < this.ranges.length; i++)
	        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
	      return new Selection(out, this.primIndex);
	    },
	    somethingSelected: function() {
	      for (var i = 0; i < this.ranges.length; i++)
	        if (!this.ranges[i].empty()) return true;
	      return false;
	    },
	    contains: function(pos, end) {
	      if (!end) end = pos;
	      for (var i = 0; i < this.ranges.length; i++) {
	        var range = this.ranges[i];
	        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
	          return i;
	      }
	      return -1;
	    }
	  };

	  function Range(anchor, head) {
	    this.anchor = anchor; this.head = head;
	  }

	  Range.prototype = {
	    from: function() { return minPos(this.anchor, this.head); },
	    to: function() { return maxPos(this.anchor, this.head); },
	    empty: function() {
	      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
	    }
	  };

	  // Take an unsorted, potentially overlapping set of ranges, and
	  // build a selection out of it. 'Consumes' ranges array (modifying
	  // it).
	  function normalizeSelection(ranges, primIndex) {
	    var prim = ranges[primIndex];
	    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
	    primIndex = indexOf(ranges, prim);
	    for (var i = 1; i < ranges.length; i++) {
	      var cur = ranges[i], prev = ranges[i - 1];
	      if (cmp(prev.to(), cur.from()) >= 0) {
	        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
	        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
	        if (i <= primIndex) --primIndex;
	        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
	      }
	    }
	    return new Selection(ranges, primIndex);
	  }

	  function simpleSelection(anchor, head) {
	    return new Selection([new Range(anchor, head || anchor)], 0);
	  }

	  // Most of the external API clips given positions to make sure they
	  // actually exist within the document.
	  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
	  function clipPos(doc, pos) {
	    if (pos.line < doc.first) return Pos(doc.first, 0);
	    var last = doc.first + doc.size - 1;
	    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
	    return clipToLen(pos, getLine(doc, pos.line).text.length);
	  }
	  function clipToLen(pos, linelen) {
	    var ch = pos.ch;
	    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
	    else if (ch < 0) return Pos(pos.line, 0);
	    else return pos;
	  }
	  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
	  function clipPosArray(doc, array) {
	    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
	    return out;
	  }

	  // SELECTION UPDATES

	  // The 'scroll' parameter given to many of these indicated whether
	  // the new cursor position should be scrolled into view after
	  // modifying the selection.

	  // If shift is held or the extend flag is set, extends a range to
	  // include a given position (and optionally a second position).
	  // Otherwise, simply returns the range between the given positions.
	  // Used for cursor motion and such.
	  function extendRange(doc, range, head, other) {
	    if (doc.cm && doc.cm.display.shift || doc.extend) {
	      var anchor = range.anchor;
	      if (other) {
	        var posBefore = cmp(head, anchor) < 0;
	        if (posBefore != (cmp(other, anchor) < 0)) {
	          anchor = head;
	          head = other;
	        } else if (posBefore != (cmp(head, other) < 0)) {
	          head = other;
	        }
	      }
	      return new Range(anchor, head);
	    } else {
	      return new Range(other || head, head);
	    }
	  }

	  // Extend the primary selection range, discard the rest.
	  function extendSelection(doc, head, other, options) {
	    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
	  }

	  // Extend all selections (pos is an array of selections with length
	  // equal the number of selections)
	  function extendSelections(doc, heads, options) {
	    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
	      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
	    var newSel = normalizeSelection(out, doc.sel.primIndex);
	    setSelection(doc, newSel, options);
	  }

	  // Updates a single range in the selection.
	  function replaceOneSelection(doc, i, range, options) {
	    var ranges = doc.sel.ranges.slice(0);
	    ranges[i] = range;
	    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
	  }

	  // Reset the selection to a single range.
	  function setSimpleSelection(doc, anchor, head, options) {
	    setSelection(doc, simpleSelection(anchor, head), options);
	  }

	  // Give beforeSelectionChange handlers a change to influence a
	  // selection update.
	  function filterSelectionChange(doc, sel) {
	    var obj = {
	      ranges: sel.ranges,
	      update: function(ranges) {
	        this.ranges = [];
	        for (var i = 0; i < ranges.length; i++)
	          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
	                                     clipPos(doc, ranges[i].head));
	      }
	    };
	    signal(doc, "beforeSelectionChange", doc, obj);
	    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
	    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
	    else return sel;
	  }

	  function setSelectionReplaceHistory(doc, sel, options) {
	    var done = doc.history.done, last = lst(done);
	    if (last && last.ranges) {
	      done[done.length - 1] = sel;
	      setSelectionNoUndo(doc, sel, options);
	    } else {
	      setSelection(doc, sel, options);
	    }
	  }

	  // Set a new selection.
	  function setSelection(doc, sel, options) {
	    setSelectionNoUndo(doc, sel, options);
	    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
	  }

	  function setSelectionNoUndo(doc, sel, options) {
	    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
	      sel = filterSelectionChange(doc, sel);

	    var bias = options && options.bias ||
	      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
	    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

	    if (!(options && options.scroll === false) && doc.cm)
	      ensureCursorVisible(doc.cm);
	  }

	  function setSelectionInner(doc, sel) {
	    if (sel.equals(doc.sel)) return;

	    doc.sel = sel;

	    if (doc.cm) {
	      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
	      signalCursorActivity(doc.cm);
	    }
	    signalLater(doc, "cursorActivity", doc);
	  }

	  // Verify that the selection does not partially select any atomic
	  // marked ranges.
	  function reCheckSelection(doc) {
	    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
	  }

	  // Return a selection that does not partially select any atomic
	  // ranges.
	  function skipAtomicInSelection(doc, sel, bias, mayClear) {
	    var out;
	    for (var i = 0; i < sel.ranges.length; i++) {
	      var range = sel.ranges[i];
	      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);
	      var newHead = skipAtomic(doc, range.head, bias, mayClear);
	      if (out || newAnchor != range.anchor || newHead != range.head) {
	        if (!out) out = sel.ranges.slice(0, i);
	        out[i] = new Range(newAnchor, newHead);
	      }
	    }
	    return out ? normalizeSelection(out, sel.primIndex) : sel;
	  }

	  // Ensure a given position is not inside an atomic range.
	  function skipAtomic(doc, pos, bias, mayClear) {
	    var flipped = false, curPos = pos;
	    var dir = bias || 1;
	    doc.cantEdit = false;
	    search: for (;;) {
	      var line = getLine(doc, curPos.line);
	      if (line.markedSpans) {
	        for (var i = 0; i < line.markedSpans.length; ++i) {
	          var sp = line.markedSpans[i], m = sp.marker;
	          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&
	              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
	            if (mayClear) {
	              signal(m, "beforeCursorEnter");
	              if (m.explicitlyCleared) {
	                if (!line.markedSpans) break;
	                else {--i; continue;}
	              }
	            }
	            if (!m.atomic) continue;
	            var newPos = m.find(dir < 0 ? -1 : 1);
	            if (cmp(newPos, curPos) == 0) {
	              newPos.ch += dir;
	              if (newPos.ch < 0) {
	                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));
	                else newPos = null;
	              } else if (newPos.ch > line.text.length) {
	                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);
	                else newPos = null;
	              }
	              if (!newPos) {
	                if (flipped) {
	                  // Driven in a corner -- no valid cursor position found at all
	                  // -- try again *with* clearing, if we didn't already
	                  if (!mayClear) return skipAtomic(doc, pos, bias, true);
	                  // Otherwise, turn off editing until further notice, and return the start of the doc
	                  doc.cantEdit = true;
	                  return Pos(doc.first, 0);
	                }
	                flipped = true; newPos = pos; dir = -dir;
	              }
	            }
	            curPos = newPos;
	            continue search;
	          }
	        }
	      }
	      return curPos;
	    }
	  }

	  // SELECTION DRAWING

	  // Redraw the selection and/or cursor
	  function drawSelection(cm) {
	    var display = cm.display, doc = cm.doc, result = {};
	    var curFragment = result.cursors = document.createDocumentFragment();
	    var selFragment = result.selection = document.createDocumentFragment();

	    for (var i = 0; i < doc.sel.ranges.length; i++) {
	      var range = doc.sel.ranges[i];
	      var collapsed = range.empty();
	      if (collapsed || cm.options.showCursorWhenSelecting)
	        drawSelectionCursor(cm, range, curFragment);
	      if (!collapsed)
	        drawSelectionRange(cm, range, selFragment);
	    }

	    // Move the hidden textarea near the cursor to prevent scrolling artifacts
	    if (cm.options.moveInputWithCursor) {
	      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
	      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
	      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
	                                          headPos.top + lineOff.top - wrapOff.top));
	      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
	                                           headPos.left + lineOff.left - wrapOff.left));
	    }

	    return result;
	  }

	  function showSelection(cm, drawn) {
	    removeChildrenAndAdd(cm.display.cursorDiv, drawn.cursors);
	    removeChildrenAndAdd(cm.display.selectionDiv, drawn.selection);
	    if (drawn.teTop != null) {
	      cm.display.inputDiv.style.top = drawn.teTop + "px";
	      cm.display.inputDiv.style.left = drawn.teLeft + "px";
	    }
	  }

	  function updateSelection(cm) {
	    showSelection(cm, drawSelection(cm));
	  }

	  // Draws a cursor for the given range
	  function drawSelectionCursor(cm, range, output) {
	    var pos = cursorCoords(cm, range.head, "div", null, null, !cm.options.singleCursorHeightPerLine);

	    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
	    cursor.style.left = pos.left + "px";
	    cursor.style.top = pos.top + "px";
	    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

	    if (pos.other) {
	      // Secondary cursor, shown when on a 'jump' in bi-directional text
	      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
	      otherCursor.style.display = "";
	      otherCursor.style.left = pos.other.left + "px";
	      otherCursor.style.top = pos.other.top + "px";
	      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
	    }
	  }

	  // Draws the given range as a highlighted selection
	  function drawSelectionRange(cm, range, output) {
	    var display = cm.display, doc = cm.doc;
	    var fragment = document.createDocumentFragment();
	    var padding = paddingH(cm.display), leftSide = padding.left;
	    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

	    function add(left, top, width, bottom) {
	      if (top < 0) top = 0;
	      top = Math.round(top);
	      bottom = Math.round(bottom);
	      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
	                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
	                               "px; height: " + (bottom - top) + "px"));
	    }

	    function drawForLine(line, fromArg, toArg) {
	      var lineObj = getLine(doc, line);
	      var lineLen = lineObj.text.length;
	      var start, end;
	      function coords(ch, bias) {
	        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
	      }

	      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
	        var leftPos = coords(from, "left"), rightPos, left, right;
	        if (from == to) {
	          rightPos = leftPos;
	          left = right = leftPos.left;
	        } else {
	          rightPos = coords(to - 1, "right");
	          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
	          left = leftPos.left;
	          right = rightPos.right;
	        }
	        if (fromArg == null && from == 0) left = leftSide;
	        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
	          add(left, leftPos.top, null, leftPos.bottom);
	          left = leftSide;
	          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
	        }
	        if (toArg == null && to == lineLen) right = rightSide;
	        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
	          start = leftPos;
	        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
	          end = rightPos;
	        if (left < leftSide + 1) left = leftSide;
	        add(left, rightPos.top, right - left, rightPos.bottom);
	      });
	      return {start: start, end: end};
	    }

	    var sFrom = range.from(), sTo = range.to();
	    if (sFrom.line == sTo.line) {
	      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
	    } else {
	      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
	      var singleVLine = visualLine(fromLine) == visualLine(toLine);
	      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
	      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
	      if (singleVLine) {
	        if (leftEnd.top < rightStart.top - 2) {
	          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
	          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
	        } else {
	          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
	        }
	      }
	      if (leftEnd.bottom < rightStart.top)
	        add(leftSide, leftEnd.bottom, null, rightStart.top);
	    }

	    output.appendChild(fragment);
	  }

	  // Cursor-blinking
	  function restartBlink(cm) {
	    if (!cm.state.focused) return;
	    var display = cm.display;
	    clearInterval(display.blinker);
	    var on = true;
	    display.cursorDiv.style.visibility = "";
	    if (cm.options.cursorBlinkRate > 0)
	      display.blinker = setInterval(function() {
	        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
	      }, cm.options.cursorBlinkRate);
	    else if (cm.options.cursorBlinkRate < 0)
	      display.cursorDiv.style.visibility = "hidden";
	  }

	  // HIGHLIGHT WORKER

	  function startWorker(cm, time) {
	    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
	      cm.state.highlight.set(time, bind(highlightWorker, cm));
	  }

	  function highlightWorker(cm) {
	    var doc = cm.doc;
	    if (doc.frontier < doc.first) doc.frontier = doc.first;
	    if (doc.frontier >= cm.display.viewTo) return;
	    var end = +new Date + cm.options.workTime;
	    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
	    var changedLines = [];

	    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
	      if (doc.frontier >= cm.display.viewFrom) { // Visible
	        var oldStyles = line.styles;
	        var highlighted = highlightLine(cm, line, state, true);
	        line.styles = highlighted.styles;
	        var oldCls = line.styleClasses, newCls = highlighted.classes;
	        if (newCls) line.styleClasses = newCls;
	        else if (oldCls) line.styleClasses = null;
	        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
	          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
	        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
	        if (ischange) changedLines.push(doc.frontier);
	        line.stateAfter = copyState(doc.mode, state);
	      } else {
	        processLine(cm, line.text, state);
	        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
	      }
	      ++doc.frontier;
	      if (+new Date > end) {
	        startWorker(cm, cm.options.workDelay);
	        return true;
	      }
	    });
	    if (changedLines.length) runInOp(cm, function() {
	      for (var i = 0; i < changedLines.length; i++)
	        regLineChange(cm, changedLines[i], "text");
	    });
	  }

	  // Finds the line to start with when starting a parse. Tries to
	  // find a line with a stateAfter, so that it can start with a
	  // valid state. If that fails, it returns the line with the
	  // smallest indentation, which tends to need the least context to
	  // parse correctly.
	  function findStartLine(cm, n, precise) {
	    var minindent, minline, doc = cm.doc;
	    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
	    for (var search = n; search > lim; --search) {
	      if (search <= doc.first) return doc.first;
	      var line = getLine(doc, search - 1);
	      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
	      var indented = countColumn(line.text, null, cm.options.tabSize);
	      if (minline == null || minindent > indented) {
	        minline = search - 1;
	        minindent = indented;
	      }
	    }
	    return minline;
	  }

	  function getStateBefore(cm, n, precise) {
	    var doc = cm.doc, display = cm.display;
	    if (!doc.mode.startState) return true;
	    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
	    if (!state) state = startState(doc.mode);
	    else state = copyState(doc.mode, state);
	    doc.iter(pos, n, function(line) {
	      processLine(cm, line.text, state);
	      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
	      line.stateAfter = save ? copyState(doc.mode, state) : null;
	      ++pos;
	    });
	    if (precise) doc.frontier = pos;
	    return state;
	  }

	  // POSITION MEASUREMENT

	  function paddingTop(display) {return display.lineSpace.offsetTop;}
	  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
	  function paddingH(display) {
	    if (display.cachedPaddingH) return display.cachedPaddingH;
	    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
	    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
	    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
	    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
	    return data;
	  }

	  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }
	  function displayWidth(cm) {
	    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
	  }
	  function displayHeight(cm) {
	    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
	  }

	  // Ensure the lineView.wrapping.heights array is populated. This is
	  // an array of bottom offsets for the lines that make up a drawn
	  // line. When lineWrapping is on, there might be more than one
	  // height.
	  function ensureLineHeights(cm, lineView, rect) {
	    var wrapping = cm.options.lineWrapping;
	    var curWidth = wrapping && displayWidth(cm);
	    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
	      var heights = lineView.measure.heights = [];
	      if (wrapping) {
	        lineView.measure.width = curWidth;
	        var rects = lineView.text.firstChild.getClientRects();
	        for (var i = 0; i < rects.length - 1; i++) {
	          var cur = rects[i], next = rects[i + 1];
	          if (Math.abs(cur.bottom - next.bottom) > 2)
	            heights.push((cur.bottom + next.top) / 2 - rect.top);
	        }
	      }
	      heights.push(rect.bottom - rect.top);
	    }
	  }

	  // Find a line map (mapping character offsets to text nodes) and a
	  // measurement cache for the given line number. (A line view might
	  // contain multiple lines when collapsed ranges are present.)
	  function mapFromLineView(lineView, line, lineN) {
	    if (lineView.line == line)
	      return {map: lineView.measure.map, cache: lineView.measure.cache};
	    for (var i = 0; i < lineView.rest.length; i++)
	      if (lineView.rest[i] == line)
	        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
	    for (var i = 0; i < lineView.rest.length; i++)
	      if (lineNo(lineView.rest[i]) > lineN)
	        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
	  }

	  // Render a line into the hidden node display.externalMeasured. Used
	  // when measurement is needed for a line that's not in the viewport.
	  function updateExternalMeasurement(cm, line) {
	    line = visualLine(line);
	    var lineN = lineNo(line);
	    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
	    view.lineN = lineN;
	    var built = view.built = buildLineContent(cm, view);
	    view.text = built.pre;
	    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
	    return view;
	  }

	  // Get a {top, bottom, left, right} box (in line-local coordinates)
	  // for a given character.
	  function measureChar(cm, line, ch, bias) {
	    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
	  }

	  // Find a line view that corresponds to the given line number.
	  function findViewForLine(cm, lineN) {
	    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
	      return cm.display.view[findViewIndex(cm, lineN)];
	    var ext = cm.display.externalMeasured;
	    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
	      return ext;
	  }

	  // Measurement can be split in two steps, the set-up work that
	  // applies to the whole line, and the measurement of the actual
	  // character. Functions like coordsChar, that need to do a lot of
	  // measurements in a row, can thus ensure that the set-up work is
	  // only done once.
	  function prepareMeasureForLine(cm, line) {
	    var lineN = lineNo(line);
	    var view = findViewForLine(cm, lineN);
	    if (view && !view.text)
	      view = null;
	    else if (view && view.changes)
	      updateLineForChanges(cm, view, lineN, getDimensions(cm));
	    if (!view)
	      view = updateExternalMeasurement(cm, line);

	    var info = mapFromLineView(view, line, lineN);
	    return {
	      line: line, view: view, rect: null,
	      map: info.map, cache: info.cache, before: info.before,
	      hasHeights: false
	    };
	  }

	  // Given a prepared measurement object, measures the position of an
	  // actual character (or fetches it from the cache).
	  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
	    if (prepared.before) ch = -1;
	    var key = ch + (bias || ""), found;
	    if (prepared.cache.hasOwnProperty(key)) {
	      found = prepared.cache[key];
	    } else {
	      if (!prepared.rect)
	        prepared.rect = prepared.view.text.getBoundingClientRect();
	      if (!prepared.hasHeights) {
	        ensureLineHeights(cm, prepared.view, prepared.rect);
	        prepared.hasHeights = true;
	      }
	      found = measureCharInner(cm, prepared, ch, bias);
	      if (!found.bogus) prepared.cache[key] = found;
	    }
	    return {left: found.left, right: found.right,
	            top: varHeight ? found.rtop : found.top,
	            bottom: varHeight ? found.rbottom : found.bottom};
	  }

	  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

	  function measureCharInner(cm, prepared, ch, bias) {
	    var map = prepared.map;

	    var node, start, end, collapse;
	    // First, search the line map for the text node corresponding to,
	    // or closest to, the target character.
	    for (var i = 0; i < map.length; i += 3) {
	      var mStart = map[i], mEnd = map[i + 1];
	      if (ch < mStart) {
	        start = 0; end = 1;
	        collapse = "left";
	      } else if (ch < mEnd) {
	        start = ch - mStart;
	        end = start + 1;
	      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
	        end = mEnd - mStart;
	        start = end - 1;
	        if (ch >= mEnd) collapse = "right";
	      }
	      if (start != null) {
	        node = map[i + 2];
	        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
	          collapse = bias;
	        if (bias == "left" && start == 0)
	          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
	            node = map[(i -= 3) + 2];
	            collapse = "left";
	          }
	        if (bias == "right" && start == mEnd - mStart)
	          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
	            node = map[(i += 3) + 2];
	            collapse = "right";
	          }
	        break;
	      }
	    }

	    var rect;
	    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
	      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned
	        while (start && isExtendingChar(prepared.line.text.charAt(mStart + start))) --start;
	        while (mStart + end < mEnd && isExtendingChar(prepared.line.text.charAt(mStart + end))) ++end;
	        if (ie && ie_version < 9 && start == 0 && end == mEnd - mStart) {
	          rect = node.parentNode.getBoundingClientRect();
	        } else if (ie && cm.options.lineWrapping) {
	          var rects = range(node, start, end).getClientRects();
	          if (rects.length)
	            rect = rects[bias == "right" ? rects.length - 1 : 0];
	          else
	            rect = nullRect;
	        } else {
	          rect = range(node, start, end).getBoundingClientRect() || nullRect;
	        }
	        if (rect.left || rect.right || start == 0) break;
	        end = start;
	        start = start - 1;
	        collapse = "right";
	      }
	      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);
	    } else { // If it is a widget, simply get the box for the whole widget.
	      if (start > 0) collapse = bias = "right";
	      var rects;
	      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
	        rect = rects[bias == "right" ? rects.length - 1 : 0];
	      else
	        rect = node.getBoundingClientRect();
	    }
	    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
	      var rSpan = node.parentNode.getClientRects()[0];
	      if (rSpan)
	        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
	      else
	        rect = nullRect;
	    }

	    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
	    var mid = (rtop + rbot) / 2;
	    var heights = prepared.view.measure.heights;
	    for (var i = 0; i < heights.length - 1; i++)
	      if (mid < heights[i]) break;
	    var top = i ? heights[i - 1] : 0, bot = heights[i];
	    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
	                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
	                  top: top, bottom: bot};
	    if (!rect.left && !rect.right) result.bogus = true;
	    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

	    return result;
	  }

	  // Work around problem with bounding client rects on ranges being
	  // returned incorrectly when zoomed on IE10 and below.
	  function maybeUpdateRectForZooming(measure, rect) {
	    if (!window.screen || screen.logicalXDPI == null ||
	        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
	      return rect;
	    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
	    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
	    return {left: rect.left * scaleX, right: rect.right * scaleX,
	            top: rect.top * scaleY, bottom: rect.bottom * scaleY};
	  }

	  function clearLineMeasurementCacheFor(lineView) {
	    if (lineView.measure) {
	      lineView.measure.cache = {};
	      lineView.measure.heights = null;
	      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
	        lineView.measure.caches[i] = {};
	    }
	  }

	  function clearLineMeasurementCache(cm) {
	    cm.display.externalMeasure = null;
	    removeChildren(cm.display.lineMeasure);
	    for (var i = 0; i < cm.display.view.length; i++)
	      clearLineMeasurementCacheFor(cm.display.view[i]);
	  }

	  function clearCaches(cm) {
	    clearLineMeasurementCache(cm);
	    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
	    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
	    cm.display.lineNumChars = null;
	  }

	  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
	  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

	  // Converts a {top, bottom, left, right} box from line-local
	  // coordinates into another coordinate system. Context may be one of
	  // "line", "div" (display.lineDiv), "local"/null (editor), "window",
	  // or "page".
	  function intoCoordSystem(cm, lineObj, rect, context) {
	    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
	      var size = widgetHeight(lineObj.widgets[i]);
	      rect.top += size; rect.bottom += size;
	    }
	    if (context == "line") return rect;
	    if (!context) context = "local";
	    var yOff = heightAtLine(lineObj);
	    if (context == "local") yOff += paddingTop(cm.display);
	    else yOff -= cm.display.viewOffset;
	    if (context == "page" || context == "window") {
	      var lOff = cm.display.lineSpace.getBoundingClientRect();
	      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
	      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
	      rect.left += xOff; rect.right += xOff;
	    }
	    rect.top += yOff; rect.bottom += yOff;
	    return rect;
	  }

	  // Coverts a box from "div" coords to another coordinate system.
	  // Context may be "window", "page", "div", or "local"/null.
	  function fromCoordSystem(cm, coords, context) {
	    if (context == "div") return coords;
	    var left = coords.left, top = coords.top;
	    // First move into "page" coordinate system
	    if (context == "page") {
	      left -= pageScrollX();
	      top -= pageScrollY();
	    } else if (context == "local" || !context) {
	      var localBox = cm.display.sizer.getBoundingClientRect();
	      left += localBox.left;
	      top += localBox.top;
	    }

	    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
	    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
	  }

	  function charCoords(cm, pos, context, lineObj, bias) {
	    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
	    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
	  }

	  // Returns a box for a given cursor position, which may have an
	  // 'other' property containing the position of the secondary cursor
	  // on a bidi boundary.
	  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
	    lineObj = lineObj || getLine(cm.doc, pos.line);
	    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
	    function get(ch, right) {
	      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
	      if (right) m.left = m.right; else m.right = m.left;
	      return intoCoordSystem(cm, lineObj, m, context);
	    }
	    function getBidi(ch, partPos) {
	      var part = order[partPos], right = part.level % 2;
	      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
	        part = order[--partPos];
	        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
	        right = true;
	      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
	        part = order[++partPos];
	        ch = bidiLeft(part) - part.level % 2;
	        right = false;
	      }
	      if (right && ch == part.to && ch > part.from) return get(ch - 1);
	      return get(ch, right);
	    }
	    var order = getOrder(lineObj), ch = pos.ch;
	    if (!order) return get(ch);
	    var partPos = getBidiPartAt(order, ch);
	    var val = getBidi(ch, partPos);
	    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
	    return val;
	  }

	  // Used to cheaply estimate the coordinates for a position. Used for
	  // intermediate scroll updates.
	  function estimateCoords(cm, pos) {
	    var left = 0, pos = clipPos(cm.doc, pos);
	    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
	    var lineObj = getLine(cm.doc, pos.line);
	    var top = heightAtLine(lineObj) + paddingTop(cm.display);
	    return {left: left, right: left, top: top, bottom: top + lineObj.height};
	  }

	  // Positions returned by coordsChar contain some extra information.
	  // xRel is the relative x position of the input coordinates compared
	  // to the found position (so xRel > 0 means the coordinates are to
	  // the right of the character position, for example). When outside
	  // is true, that means the coordinates lie outside the line's
	  // vertical range.
	  function PosWithInfo(line, ch, outside, xRel) {
	    var pos = Pos(line, ch);
	    pos.xRel = xRel;
	    if (outside) pos.outside = true;
	    return pos;
	  }

	  // Compute the character position closest to the given coordinates.
	  // Input must be lineSpace-local ("div" coordinate system).
	  function coordsChar(cm, x, y) {
	    var doc = cm.doc;
	    y += cm.display.viewOffset;
	    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
	    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
	    if (lineN > last)
	      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
	    if (x < 0) x = 0;

	    var lineObj = getLine(doc, lineN);
	    for (;;) {
	      var found = coordsCharInner(cm, lineObj, lineN, x, y);
	      var merged = collapsedSpanAtEnd(lineObj);
	      var mergedPos = merged && merged.find(0, true);
	      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
	        lineN = lineNo(lineObj = mergedPos.to.line);
	      else
	        return found;
	    }
	  }

	  function coordsCharInner(cm, lineObj, lineNo, x, y) {
	    var innerOff = y - heightAtLine(lineObj);
	    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
	    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

	    function getX(ch) {
	      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
	      wrongLine = true;
	      if (innerOff > sp.bottom) return sp.left - adjust;
	      else if (innerOff < sp.top) return sp.left + adjust;
	      else wrongLine = false;
	      return sp.left;
	    }

	    var bidi = getOrder(lineObj), dist = lineObj.text.length;
	    var from = lineLeft(lineObj), to = lineRight(lineObj);
	    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

	    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
	    // Do a binary search between these bounds.
	    for (;;) {
	      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
	        var ch = x < fromX || x - fromX <= toX - x ? from : to;
	        var xDiff = x - (ch == from ? fromX : toX);
	        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
	        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
	                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
	        return pos;
	      }
	      var step = Math.ceil(dist / 2), middle = from + step;
	      if (bidi) {
	        middle = from;
	        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
	      }
	      var middleX = getX(middle);
	      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
	      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
	    }
	  }

	  var measureText;
	  // Compute the default text height.
	  function textHeight(display) {
	    if (display.cachedTextHeight != null) return display.cachedTextHeight;
	    if (measureText == null) {
	      measureText = elt("pre");
	      // Measure a bunch of lines, for browsers that compute
	      // fractional heights.
	      for (var i = 0; i < 49; ++i) {
	        measureText.appendChild(document.createTextNode("x"));
	        measureText.appendChild(elt("br"));
	      }
	      measureText.appendChild(document.createTextNode("x"));
	    }
	    removeChildrenAndAdd(display.measure, measureText);
	    var height = measureText.offsetHeight / 50;
	    if (height > 3) display.cachedTextHeight = height;
	    removeChildren(display.measure);
	    return height || 1;
	  }

	  // Compute the default character width.
	  function charWidth(display) {
	    if (display.cachedCharWidth != null) return display.cachedCharWidth;
	    var anchor = elt("span", "xxxxxxxxxx");
	    var pre = elt("pre", [anchor]);
	    removeChildrenAndAdd(display.measure, pre);
	    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
	    if (width > 2) display.cachedCharWidth = width;
	    return width || 10;
	  }

	  // OPERATIONS

	  // Operations are used to wrap a series of changes to the editor
	  // state in such a way that each change won't have to update the
	  // cursor and display (which would be awkward, slow, and
	  // error-prone). Instead, display updates are batched and then all
	  // combined and executed at once.

	  var operationGroup = null;

	  var nextOpId = 0;
	  // Start a new operation.
	  function startOperation(cm) {
	    cm.curOp = {
	      cm: cm,
	      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
	      startHeight: cm.doc.height, // Used to detect need to update scrollbar
	      forceUpdate: false,      // Used to force a redraw
	      updateInput: null,       // Whether to reset the input textarea
	      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
	      changeObjs: null,        // Accumulated changes, for firing change events
	      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
	      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
	      selectionChanged: false, // Whether the selection needs to be redrawn
	      updateMaxLine: false,    // Set when the widest line needs to be determined anew
	      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
	      scrollToPos: null,       // Used to scroll to a specific position
	      id: ++nextOpId           // Unique ID
	    };
	    if (operationGroup) {
	      operationGroup.ops.push(cm.curOp);
	    } else {
	      cm.curOp.ownsGroup = operationGroup = {
	        ops: [cm.curOp],
	        delayedCallbacks: []
	      };
	    }
	  }

	  function fireCallbacksForOps(group) {
	    // Calls delayed callbacks and cursorActivity handlers until no
	    // new ones appear
	    var callbacks = group.delayedCallbacks, i = 0;
	    do {
	      for (; i < callbacks.length; i++)
	        callbacks[i]();
	      for (var j = 0; j < group.ops.length; j++) {
	        var op = group.ops[j];
	        if (op.cursorActivityHandlers)
	          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
	            op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm);
	      }
	    } while (i < callbacks.length);
	  }

	  // Finish an operation, updating the display and signalling delayed events
	  function endOperation(cm) {
	    var op = cm.curOp, group = op.ownsGroup;
	    if (!group) return;

	    try { fireCallbacksForOps(group); }
	    finally {
	      operationGroup = null;
	      for (var i = 0; i < group.ops.length; i++)
	        group.ops[i].cm.curOp = null;
	      endOperations(group);
	    }
	  }

	  // The DOM updates done when an operation finishes are batched so
	  // that the minimum number of relayouts are required.
	  function endOperations(group) {
	    var ops = group.ops;
	    for (var i = 0; i < ops.length; i++) // Read DOM
	      endOperation_R1(ops[i]);
	    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
	      endOperation_W1(ops[i]);
	    for (var i = 0; i < ops.length; i++) // Read DOM
	      endOperation_R2(ops[i]);
	    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
	      endOperation_W2(ops[i]);
	    for (var i = 0; i < ops.length; i++) // Read DOM
	      endOperation_finish(ops[i]);
	  }

	  function endOperation_R1(op) {
	    var cm = op.cm, display = cm.display;
	    maybeClipScrollbars(cm);
	    if (op.updateMaxLine) findMaxLine(cm);

	    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
	      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
	                         op.scrollToPos.to.line >= display.viewTo) ||
	      display.maxLineChanged && cm.options.lineWrapping;
	    op.update = op.mustUpdate &&
	      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
	  }

	  function endOperation_W1(op) {
	    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
	  }

	  function endOperation_R2(op) {
	    var cm = op.cm, display = cm.display;
	    if (op.updatedDisplay) updateHeightsInViewport(cm);

	    op.barMeasure = measureForScrollbars(cm);

	    // If the max line changed since it was last measured, measure it,
	    // and ensure the document's width matches it.
	    // updateDisplay_W2 will use these properties to do the actual resizing
	    if (display.maxLineChanged && !cm.options.lineWrapping) {
	      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
	      cm.display.sizerWidth = op.adjustWidthTo;
	      op.barMeasure.scrollWidth =
	        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
	      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
	    }

	    if (op.updatedDisplay || op.selectionChanged)
	      op.newSelectionNodes = drawSelection(cm);
	  }

	  function endOperation_W2(op) {
	    var cm = op.cm;

	    if (op.adjustWidthTo != null) {
	      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
	      if (op.maxScrollLeft < cm.doc.scrollLeft)
	        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
	      cm.display.maxLineChanged = false;
	    }

	    if (op.newSelectionNodes)
	      showSelection(cm, op.newSelectionNodes);
	    if (op.updatedDisplay)
	      setDocumentHeight(cm, op.barMeasure);
	    if (op.updatedDisplay || op.startHeight != cm.doc.height)
	      updateScrollbars(cm, op.barMeasure);

	    if (op.selectionChanged) restartBlink(cm);

	    if (cm.state.focused && op.updateInput)
	      resetInput(cm, op.typing);
	  }

	  function endOperation_finish(op) {
	    var cm = op.cm, display = cm.display, doc = cm.doc;

	    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);

	    // Abort mouse wheel delta measurement, when scrolling explicitly
	    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
	      display.wheelStartX = display.wheelStartY = null;

	    // Propagate the scroll position to the actual DOM scroller
	    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
	      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
	      display.scrollbars.setScrollTop(doc.scrollTop);
	      display.scroller.scrollTop = doc.scrollTop;
	    }
	    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
	      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));
	      display.scrollbars.setScrollLeft(doc.scrollLeft);
	      display.scroller.scrollLeft = doc.scrollLeft;
	      alignHorizontally(cm);
	    }
	    // If we need to scroll a specific position into view, do so.
	    if (op.scrollToPos) {
	      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
	                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
	      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
	    }

	    // Fire events for markers that are hidden/unidden by editing or
	    // undoing
	    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
	    if (hidden) for (var i = 0; i < hidden.length; ++i)
	      if (!hidden[i].lines.length) signal(hidden[i], "hide");
	    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
	      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

	    if (display.wrapper.offsetHeight)
	      doc.scrollTop = cm.display.scroller.scrollTop;

	    // Fire change events, and delayed event handlers
	    if (op.changeObjs)
	      signal(cm, "changes", cm, op.changeObjs);
	    if (op.update)
	      op.update.finish();
	  }

	  // Run the given function in an operation
	  function runInOp(cm, f) {
	    if (cm.curOp) return f();
	    startOperation(cm);
	    try { return f(); }
	    finally { endOperation(cm); }
	  }
	  // Wraps a function in an operation. Returns the wrapped function.
	  function operation(cm, f) {
	    return function() {
	      if (cm.curOp) return f.apply(cm, arguments);
	      startOperation(cm);
	      try { return f.apply(cm, arguments); }
	      finally { endOperation(cm); }
	    };
	  }
	  // Used to add methods to editor and doc instances, wrapping them in
	  // operations.
	  function methodOp(f) {
	    return function() {
	      if (this.curOp) return f.apply(this, arguments);
	      startOperation(this);
	      try { return f.apply(this, arguments); }
	      finally { endOperation(this); }
	    };
	  }
	  function docMethodOp(f) {
	    return function() {
	      var cm = this.cm;
	      if (!cm || cm.curOp) return f.apply(this, arguments);
	      startOperation(cm);
	      try { return f.apply(this, arguments); }
	      finally { endOperation(cm); }
	    };
	  }

	  // VIEW TRACKING

	  // These objects are used to represent the visible (currently drawn)
	  // part of the document. A LineView may correspond to multiple
	  // logical lines, if those are connected by collapsed ranges.
	  function LineView(doc, line, lineN) {
	    // The starting line
	    this.line = line;
	    // Continuing lines, if any
	    this.rest = visualLineContinued(line);
	    // Number of logical lines in this visual line
	    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
	    this.node = this.text = null;
	    this.hidden = lineIsHidden(doc, line);
	  }

	  // Create a range of LineView objects for the given lines.
	  function buildViewArray(cm, from, to) {
	    var array = [], nextPos;
	    for (var pos = from; pos < to; pos = nextPos) {
	      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
	      nextPos = pos + view.size;
	      array.push(view);
	    }
	    return array;
	  }

	  // Updates the display.view data structure for a given change to the
	  // document. From and to are in pre-change coordinates. Lendiff is
	  // the amount of lines added or subtracted by the change. This is
	  // used for changes that span multiple lines, or change the way
	  // lines are divided into visual lines. regLineChange (below)
	  // registers single-line changes.
	  function regChange(cm, from, to, lendiff) {
	    if (from == null) from = cm.doc.first;
	    if (to == null) to = cm.doc.first + cm.doc.size;
	    if (!lendiff) lendiff = 0;

	    var display = cm.display;
	    if (lendiff && to < display.viewTo &&
	        (display.updateLineNumbers == null || display.updateLineNumbers > from))
	      display.updateLineNumbers = from;

	    cm.curOp.viewChanged = true;

	    if (from >= display.viewTo) { // Change after
	      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
	        resetView(cm);
	    } else if (to <= display.viewFrom) { // Change before
	      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
	        resetView(cm);
	      } else {
	        display.viewFrom += lendiff;
	        display.viewTo += lendiff;
	      }
	    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
	      resetView(cm);
	    } else if (from <= display.viewFrom) { // Top overlap
	      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
	      if (cut) {
	        display.view = display.view.slice(cut.index);
	        display.viewFrom = cut.lineN;
	        display.viewTo += lendiff;
	      } else {
	        resetView(cm);
	      }
	    } else if (to >= display.viewTo) { // Bottom overlap
	      var cut = viewCuttingPoint(cm, from, from, -1);
	      if (cut) {
	        display.view = display.view.slice(0, cut.index);
	        display.viewTo = cut.lineN;
	      } else {
	        resetView(cm);
	      }
	    } else { // Gap in the middle
	      var cutTop = viewCuttingPoint(cm, from, from, -1);
	      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
	      if (cutTop && cutBot) {
	        display.view = display.view.slice(0, cutTop.index)
	          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
	          .concat(display.view.slice(cutBot.index));
	        display.viewTo += lendiff;
	      } else {
	        resetView(cm);
	      }
	    }

	    var ext = display.externalMeasured;
	    if (ext) {
	      if (to < ext.lineN)
	        ext.lineN += lendiff;
	      else if (from < ext.lineN + ext.size)
	        display.externalMeasured = null;
	    }
	  }

	  // Register a change to a single line. Type must be one of "text",
	  // "gutter", "class", "widget"
	  function regLineChange(cm, line, type) {
	    cm.curOp.viewChanged = true;
	    var display = cm.display, ext = cm.display.externalMeasured;
	    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
	      display.externalMeasured = null;

	    if (line < display.viewFrom || line >= display.viewTo) return;
	    var lineView = display.view[findViewIndex(cm, line)];
	    if (lineView.node == null) return;
	    var arr = lineView.changes || (lineView.changes = []);
	    if (indexOf(arr, type) == -1) arr.push(type);
	  }

	  // Clear the view.
	  function resetView(cm) {
	    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
	    cm.display.view = [];
	    cm.display.viewOffset = 0;
	  }

	  // Find the view element corresponding to a given line. Return null
	  // when the line isn't visible.
	  function findViewIndex(cm, n) {
	    if (n >= cm.display.viewTo) return null;
	    n -= cm.display.viewFrom;
	    if (n < 0) return null;
	    var view = cm.display.view;
	    for (var i = 0; i < view.length; i++) {
	      n -= view[i].size;
	      if (n < 0) return i;
	    }
	  }

	  function viewCuttingPoint(cm, oldN, newN, dir) {
	    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
	    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
	      return {index: index, lineN: newN};
	    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
	      n += view[i].size;
	    if (n != oldN) {
	      if (dir > 0) {
	        if (index == view.length - 1) return null;
	        diff = (n + view[index].size) - oldN;
	        index++;
	      } else {
	        diff = n - oldN;
	      }
	      oldN += diff; newN += diff;
	    }
	    while (visualLineNo(cm.doc, newN) != newN) {
	      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
	      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
	      index += dir;
	    }
	    return {index: index, lineN: newN};
	  }

	  // Force the view to cover a given range, adding empty view element
	  // or clipping off existing ones as needed.
	  function adjustView(cm, from, to) {
	    var display = cm.display, view = display.view;
	    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
	      display.view = buildViewArray(cm, from, to);
	      display.viewFrom = from;
	    } else {
	      if (display.viewFrom > from)
	        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
	      else if (display.viewFrom < from)
	        display.view = display.view.slice(findViewIndex(cm, from));
	      display.viewFrom = from;
	      if (display.viewTo < to)
	        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
	      else if (display.viewTo > to)
	        display.view = display.view.slice(0, findViewIndex(cm, to));
	    }
	    display.viewTo = to;
	  }

	  // Count the number of lines in the view whose DOM representation is
	  // out of date (or nonexistent).
	  function countDirtyView(cm) {
	    var view = cm.display.view, dirty = 0;
	    for (var i = 0; i < view.length; i++) {
	      var lineView = view[i];
	      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
	    }
	    return dirty;
	  }

	  // INPUT HANDLING

	  // Poll for input changes, using the normal rate of polling. This
	  // runs as long as the editor is focused.
	  function slowPoll(cm) {
	    if (cm.display.pollingFast) return;
	    cm.display.poll.set(cm.options.pollInterval, function() {
	      readInput(cm);
	      if (cm.state.focused) slowPoll(cm);
	    });
	  }

	  // When an event has just come in that is likely to add or change
	  // something in the input textarea, we poll faster, to ensure that
	  // the change appears on the screen quickly.
	  function fastPoll(cm) {
	    var missed = false;
	    cm.display.pollingFast = true;
	    function p() {
	      var changed = readInput(cm);
	      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}
	      else {cm.display.pollingFast = false; slowPoll(cm);}
	    }
	    cm.display.poll.set(20, p);
	  }

	  // This will be set to an array of strings when copying, so that,
	  // when pasting, we know what kind of selections the copied text
	  // was made out of.
	  var lastCopied = null;

	  // Read input from the textarea, and update the document to match.
	  // When something is selected, it is present in the textarea, and
	  // selected (unless it is huge, in which case a placeholder is
	  // used). When nothing is selected, the cursor sits after previously
	  // seen text (can be empty), which is stored in prevInput (we must
	  // not reset the textarea when typing, because that breaks IME).
	  function readInput(cm) {
	    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc;
	    // Since this is called a *lot*, try to bail out as cheaply as
	    // possible when it is clear that nothing happened. hasSelection
	    // will be the case when there is a lot of text in the textarea,
	    // in which case reading its value would be expensive.
	    if (!cm.state.focused || (hasSelection(input) && !prevInput) || isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)
	      return false;
	    // See paste handler for more on the fakedLastChar kludge
	    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
	      input.value = input.value.substring(0, input.value.length - 1);
	      cm.state.fakedLastChar = false;
	    }
	    var text = input.value;
	    // If nothing changed, bail.
	    if (text == prevInput && !cm.somethingSelected()) return false;
	    // Work around nonsensical selection resetting in IE9/10, and
	    // inexplicable appearance of private area unicode characters on
	    // some key combos in Mac (#2689).
	    if (ie && ie_version >= 9 && cm.display.inputHasSelection === text ||
	        mac && /[\uf700-\uf7ff]/.test(text)) {
	      resetInput(cm);
	      return false;
	    }

	    var withOp = !cm.curOp;
	    if (withOp) startOperation(cm);
	    cm.display.shift = false;

	    if (text.charCodeAt(0) == 0x200b && doc.sel == cm.display.selForContextMenu && !prevInput)
	      prevInput = "\u200b";
	    // Find the part of the input that is actually new
	    var same = 0, l = Math.min(prevInput.length, text.length);
	    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;
	    var inserted = text.slice(same), textLines = splitLines(inserted);

	    // When pasing N lines into N selections, insert one line per selection
	    var multiPaste = null;
	    if (cm.state.pasteIncoming && doc.sel.ranges.length > 1) {
	      if (lastCopied && lastCopied.join("\n") == inserted)
	        multiPaste = doc.sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines);
	      else if (textLines.length == doc.sel.ranges.length)
	        multiPaste = map(textLines, function(l) { return [l]; });
	    }

	    // Normal behavior is to insert the new text into every selection
	    for (var i = doc.sel.ranges.length - 1; i >= 0; i--) {
	      var range = doc.sel.ranges[i];
	      var from = range.from(), to = range.to();
	      // Handle deletion
	      if (same < prevInput.length)
	        from = Pos(from.line, from.ch - (prevInput.length - same));
	      // Handle overwrite
	      else if (cm.state.overwrite && range.empty() && !cm.state.pasteIncoming)
	        to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
	      var updateInput = cm.curOp.updateInput;
	      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
	                         origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};
	      makeChange(cm.doc, changeEvent);
	      signalLater(cm, "inputRead", cm, changeEvent);
	      // When an 'electric' character is inserted, immediately trigger a reindent
	      if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&
	          cm.options.smartIndent && range.head.ch < 100 &&
	          (!i || doc.sel.ranges[i - 1].head.line != range.head.line)) {
	        var mode = cm.getModeAt(range.head);
	        var end = changeEnd(changeEvent);
	        if (mode.electricChars) {
	          for (var j = 0; j < mode.electricChars.length; j++)
	            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
	              indentLine(cm, end.line, "smart");
	              break;
	            }
	        } else if (mode.electricInput) {
	          if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))
	            indentLine(cm, end.line, "smart");
	        }
	      }
	    }
	    ensureCursorVisible(cm);
	    cm.curOp.updateInput = updateInput;
	    cm.curOp.typing = true;

	    // Don't leave long text in the textarea, since it makes further polling slow
	    if (text.length > 1000 || text.indexOf("\n") > -1) input.value = cm.display.prevInput = "";
	    else cm.display.prevInput = text;
	    if (withOp) endOperation(cm);
	    cm.state.pasteIncoming = cm.state.cutIncoming = false;
	    return true;
	  }

	  // Reset the input to correspond to the selection (or to be empty,
	  // when not typing and nothing is selected)
	  function resetInput(cm, typing) {
	    if (cm.display.contextMenuPending) return;
	    var minimal, selected, doc = cm.doc;
	    if (cm.somethingSelected()) {
	      cm.display.prevInput = "";
	      var range = doc.sel.primary();
	      minimal = hasCopyEvent &&
	        (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
	      var content = minimal ? "-" : selected || cm.getSelection();
	      cm.display.input.value = content;
	      if (cm.state.focused) selectInput(cm.display.input);
	      if (ie && ie_version >= 9) cm.display.inputHasSelection = content;
	    } else if (!typing) {
	      cm.display.prevInput = cm.display.input.value = "";
	      if (ie && ie_version >= 9) cm.display.inputHasSelection = null;
	    }
	    cm.display.inaccurateSelection = minimal;
	  }

	  function focusInput(cm) {
	    if (cm.options.readOnly != "nocursor" && (!mobile || activeElt() != cm.display.input)) {
	      try { cm.display.input.focus(); }
	      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
	    }
	  }

	  function ensureFocus(cm) {
	    if (!cm.state.focused) { focusInput(cm); onFocus(cm); }
	  }

	  function isReadOnly(cm) {
	    return cm.options.readOnly || cm.doc.cantEdit;
	  }

	  // EVENT HANDLERS

	  // Attach the necessary event handlers when initializing the editor
	  function registerEventHandlers(cm) {
	    var d = cm.display;
	    on(d.scroller, "mousedown", operation(cm, onMouseDown));
	    // Older IE's will not fire a second mousedown for a double click
	    if (ie && ie_version < 11)
	      on(d.scroller, "dblclick", operation(cm, function(e) {
	        if (signalDOMEvent(cm, e)) return;
	        var pos = posFromMouse(cm, e);
	        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
	        e_preventDefault(e);
	        var word = cm.findWordAt(pos);
	        extendSelection(cm.doc, word.anchor, word.head);
	      }));
	    else
	      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
	    // Prevent normal selection in the editor (we handle our own)
	    on(d.lineSpace, "selectstart", function(e) {
	      if (!eventInWidget(d, e)) e_preventDefault(e);
	    });
	    // Some browsers fire contextmenu *after* opening the menu, at
	    // which point we can't mess with it anymore. Context menu is
	    // handled in onMouseDown for these browsers.
	    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

	    // Sync scrolling between fake scrollbars and real scrollable
	    // area, ensure viewport is updated when scrolling.
	    on(d.scroller, "scroll", function() {
	      if (d.scroller.clientHeight) {
	        setScrollTop(cm, d.scroller.scrollTop);
	        setScrollLeft(cm, d.scroller.scrollLeft, true);
	        signal(cm, "scroll", cm);
	      }
	    });

	    // Listen to wheel events in order to try and update the viewport on time.
	    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
	    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

	    // Prevent wrapper from ever scrolling
	    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

	    on(d.input, "keyup", function(e) { onKeyUp.call(cm, e); });
	    on(d.input, "input", function() {
	      if (ie && ie_version >= 9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;
	      readInput(cm);
	    });
	    on(d.input, "keydown", operation(cm, onKeyDown));
	    on(d.input, "keypress", operation(cm, onKeyPress));
	    on(d.input, "focus", bind(onFocus, cm));
	    on(d.input, "blur", bind(onBlur, cm));

	    function drag_(e) {
	      if (!signalDOMEvent(cm, e)) e_stop(e);
	    }
	    if (cm.options.dragDrop) {
	      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});
	      on(d.scroller, "dragenter", drag_);
	      on(d.scroller, "dragover", drag_);
	      on(d.scroller, "drop", operation(cm, onDrop));
	    }
	    on(d.scroller, "paste", function(e) {
	      if (eventInWidget(d, e)) return;
	      cm.state.pasteIncoming = true;
	      focusInput(cm);
	      fastPoll(cm);
	    });
	    on(d.input, "paste", function() {
	      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206
	      // Add a char to the end of textarea before paste occur so that
	      // selection doesn't span to the end of textarea.
	      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {
	        var start = d.input.selectionStart, end = d.input.selectionEnd;
	        d.input.value += "$";
	        // The selection end needs to be set before the start, otherwise there
	        // can be an intermediate non-empty selection between the two, which
	        // can override the middle-click paste buffer on linux and cause the
	        // wrong thing to get pasted.
	        d.input.selectionEnd = end;
	        d.input.selectionStart = start;
	        cm.state.fakedLastChar = true;
	      }
	      cm.state.pasteIncoming = true;
	      fastPoll(cm);
	    });

	    function prepareCopyCut(e) {
	      if (cm.somethingSelected()) {
	        lastCopied = cm.getSelections();
	        if (d.inaccurateSelection) {
	          d.prevInput = "";
	          d.inaccurateSelection = false;
	          d.input.value = lastCopied.join("\n");
	          selectInput(d.input);
	        }
	      } else {
	        var text = [], ranges = [];
	        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
	          var line = cm.doc.sel.ranges[i].head.line;
	          var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
	          ranges.push(lineRange);
	          text.push(cm.getRange(lineRange.anchor, lineRange.head));
	        }
	        if (e.type == "cut") {
	          cm.setSelections(ranges, null, sel_dontScroll);
	        } else {
	          d.prevInput = "";
	          d.input.value = text.join("\n");
	          selectInput(d.input);
	        }
	        lastCopied = text;
	      }
	      if (e.type == "cut") cm.state.cutIncoming = true;
	    }
	    on(d.input, "cut", prepareCopyCut);
	    on(d.input, "copy", prepareCopyCut);

	    // Needed to handle Tab key in KHTML
	    if (khtml) on(d.sizer, "mouseup", function() {
	      if (activeElt() == d.input) d.input.blur();
	      focusInput(cm);
	    });
	  }

	  // Called when the window resizes
	  function onResize(cm) {
	    var d = cm.display;
	    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
	      return;
	    // Might be a text scaling operation, clear size caches.
	    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
	    d.scrollbarsClipped = false;
	    cm.setSize();
	  }

	  // MOUSE EVENTS

	  // Return true when the given mouse event happened in a widget
	  function eventInWidget(display, e) {
	    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
	      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
	          (n.parentNode == display.sizer && n != display.mover))
	        return true;
	    }
	  }

	  // Given a mouse event, find the corresponding position. If liberal
	  // is false, it checks whether a gutter or scrollbar was clicked,
	  // and returns null if it was. forRect is used by rectangular
	  // selections, and tries to estimate a character position even for
	  // coordinates beyond the right of the text.
	  function posFromMouse(cm, e, liberal, forRect) {
	    var display = cm.display;
	    if (!liberal && e_target(e).getAttribute("not-content") == "true") return null;

	    var x, y, space = display.lineSpace.getBoundingClientRect();
	    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
	    try { x = e.clientX - space.left; y = e.clientY - space.top; }
	    catch (e) { return null; }
	    var coords = coordsChar(cm, x, y), line;
	    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
	      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
	      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
	    }
	    return coords;
	  }

	  // A mouse down can be a single click, double click, triple click,
	  // start of selection drag, start of text drag, new cursor
	  // (ctrl-click), rectangle drag (alt-drag), or xwin
	  // middle-click-paste. Or it might be a click on something we should
	  // not interfere with, such as a scrollbar or widget.
	  function onMouseDown(e) {
	    if (signalDOMEvent(this, e)) return;
	    var cm = this, display = cm.display;
	    display.shift = e.shiftKey;

	    if (eventInWidget(display, e)) {
	      if (!webkit) {
	        // Briefly turn off draggability, to allow widgets to do
	        // normal dragging things.
	        display.scroller.draggable = false;
	        setTimeout(function(){display.scroller.draggable = true;}, 100);
	      }
	      return;
	    }
	    if (clickInGutter(cm, e)) return;
	    var start = posFromMouse(cm, e);
	    window.focus();

	    switch (e_button(e)) {
	    case 1:
	      if (start)
	        leftButtonDown(cm, e, start);
	      else if (e_target(e) == display.scroller)
	        e_preventDefault(e);
	      break;
	    case 2:
	      if (webkit) cm.state.lastMiddleDown = +new Date;
	      if (start) extendSelection(cm.doc, start);
	      setTimeout(bind(focusInput, cm), 20);
	      e_preventDefault(e);
	      break;
	    case 3:
	      if (captureRightClick) onContextMenu(cm, e);
	      break;
	    }
	  }

	  var lastClick, lastDoubleClick;
	  function leftButtonDown(cm, e, start) {
	    setTimeout(bind(ensureFocus, cm), 0);

	    var now = +new Date, type;
	    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
	      type = "triple";
	    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
	      type = "double";
	      lastDoubleClick = {time: now, pos: start};
	    } else {
	      type = "single";
	      lastClick = {time: now, pos: start};
	    }

	    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
	    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&
	        type == "single" && (contained = sel.contains(start)) > -1 &&
	        !sel.ranges[contained].empty())
	      leftButtonStartDrag(cm, e, start, modifier);
	    else
	      leftButtonSelect(cm, e, start, type, modifier);
	  }

	  // Start a text drag. When it ends, see if any dragging actually
	  // happen, and treat as a click if it didn't.
	  function leftButtonStartDrag(cm, e, start, modifier) {
	    var display = cm.display;
	    var dragEnd = operation(cm, function(e2) {
	      if (webkit) display.scroller.draggable = false;
	      cm.state.draggingText = false;
	      off(document, "mouseup", dragEnd);
	      off(display.scroller, "drop", dragEnd);
	      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
	        e_preventDefault(e2);
	        if (!modifier)
	          extendSelection(cm.doc, start);
	        focusInput(cm);
	        // Work around unexplainable focus problem in IE9 (#2127)
	        if (ie && ie_version == 9)
	          setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);
	      }
	    });
	    // Let the drag handler handle this.
	    if (webkit) display.scroller.draggable = true;
	    cm.state.draggingText = dragEnd;
	    // IE's approach to draggable
	    if (display.scroller.dragDrop) display.scroller.dragDrop();
	    on(document, "mouseup", dragEnd);
	    on(display.scroller, "drop", dragEnd);
	  }

	  // Normal selection, as opposed to text dragging.
	  function leftButtonSelect(cm, e, start, type, addNew) {
	    var display = cm.display, doc = cm.doc;
	    e_preventDefault(e);

	    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
	    if (addNew && !e.shiftKey) {
	      ourIndex = doc.sel.contains(start);
	      if (ourIndex > -1)
	        ourRange = ranges[ourIndex];
	      else
	        ourRange = new Range(start, start);
	    } else {
	      ourRange = doc.sel.primary();
	    }

	    if (e.altKey) {
	      type = "rect";
	      if (!addNew) ourRange = new Range(start, start);
	      start = posFromMouse(cm, e, true, true);
	      ourIndex = -1;
	    } else if (type == "double") {
	      var word = cm.findWordAt(start);
	      if (cm.display.shift || doc.extend)
	        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
	      else
	        ourRange = word;
	    } else if (type == "triple") {
	      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
	      if (cm.display.shift || doc.extend)
	        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
	      else
	        ourRange = line;
	    } else {
	      ourRange = extendRange(doc, ourRange, start);
	    }

	    if (!addNew) {
	      ourIndex = 0;
	      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
	      startSel = doc.sel;
	    } else if (ourIndex == -1) {
	      ourIndex = ranges.length;
	      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
	                   {scroll: false, origin: "*mouse"});
	    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single") {
	      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0));
	      startSel = doc.sel;
	    } else {
	      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
	    }

	    var lastPos = start;
	    function extendTo(pos) {
	      if (cmp(lastPos, pos) == 0) return;
	      lastPos = pos;

	      if (type == "rect") {
	        var ranges = [], tabSize = cm.options.tabSize;
	        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
	        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
	        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
	        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
	             line <= end; line++) {
	          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
	          if (left == right)
	            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
	          else if (text.length > leftPos)
	            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
	        }
	        if (!ranges.length) ranges.push(new Range(start, start));
	        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
	                     {origin: "*mouse", scroll: false});
	        cm.scrollIntoView(pos);
	      } else {
	        var oldRange = ourRange;
	        var anchor = oldRange.anchor, head = pos;
	        if (type != "single") {
	          if (type == "double")
	            var range = cm.findWordAt(pos);
	          else
	            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
	          if (cmp(range.anchor, anchor) > 0) {
	            head = range.head;
	            anchor = minPos(oldRange.from(), range.anchor);
	          } else {
	            head = range.anchor;
	            anchor = maxPos(oldRange.to(), range.head);
	          }
	        }
	        var ranges = startSel.ranges.slice(0);
	        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
	        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
	      }
	    }

	    var editorSize = display.wrapper.getBoundingClientRect();
	    // Used to ensure timeout re-tries don't fire when another extend
	    // happened in the meantime (clearTimeout isn't reliable -- at
	    // least on Chrome, the timeouts still happen even when cleared,
	    // if the clear happens after their scheduled firing time).
	    var counter = 0;

	    function extend(e) {
	      var curCount = ++counter;
	      var cur = posFromMouse(cm, e, true, type == "rect");
	      if (!cur) return;
	      if (cmp(cur, lastPos) != 0) {
	        ensureFocus(cm);
	        extendTo(cur);
	        var visible = visibleLines(display, doc);
	        if (cur.line >= visible.to || cur.line < visible.from)
	          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
	      } else {
	        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
	        if (outside) setTimeout(operation(cm, function() {
	          if (counter != curCount) return;
	          display.scroller.scrollTop += outside;
	          extend(e);
	        }), 50);
	      }
	    }

	    function done(e) {
	      counter = Infinity;
	      e_preventDefault(e);
	      focusInput(cm);
	      off(document, "mousemove", move);
	      off(document, "mouseup", up);
	      doc.history.lastSelOrigin = null;
	    }

	    var move = operation(cm, function(e) {
	      if (!e_button(e)) done(e);
	      else extend(e);
	    });
	    var up = operation(cm, done);
	    on(document, "mousemove", move);
	    on(document, "mouseup", up);
	  }

	  // Determines whether an event happened in the gutter, and fires the
	  // handlers for the corresponding event.
	  function gutterEvent(cm, e, type, prevent, signalfn) {
	    try { var mX = e.clientX, mY = e.clientY; }
	    catch(e) { return false; }
	    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
	    if (prevent) e_preventDefault(e);

	    var display = cm.display;
	    var lineBox = display.lineDiv.getBoundingClientRect();

	    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
	    mY -= lineBox.top - display.viewOffset;

	    for (var i = 0; i < cm.options.gutters.length; ++i) {
	      var g = display.gutters.childNodes[i];
	      if (g && g.getBoundingClientRect().right >= mX) {
	        var line = lineAtHeight(cm.doc, mY);
	        var gutter = cm.options.gutters[i];
	        signalfn(cm, type, cm, line, gutter, e);
	        return e_defaultPrevented(e);
	      }
	    }
	  }

	  function clickInGutter(cm, e) {
	    return gutterEvent(cm, e, "gutterClick", true, signalLater);
	  }

	  // Kludge to work around strange IE behavior where it'll sometimes
	  // re-fire a series of drag-related events right after the drop (#1551)
	  var lastDrop = 0;

	  function onDrop(e) {
	    var cm = this;
	    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
	      return;
	    e_preventDefault(e);
	    if (ie) lastDrop = +new Date;
	    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
	    if (!pos || isReadOnly(cm)) return;
	    // Might be a file drop, in which case we simply extract the text
	    // and insert it.
	    if (files && files.length && window.FileReader && window.File) {
	      var n = files.length, text = Array(n), read = 0;
	      var loadFile = function(file, i) {
	        var reader = new FileReader;
	        reader.onload = operation(cm, function() {
	          text[i] = reader.result;
	          if (++read == n) {
	            pos = clipPos(cm.doc, pos);
	            var change = {from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste"};
	            makeChange(cm.doc, change);
	            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
	          }
	        });
	        reader.readAsText(file);
	      };
	      for (var i = 0; i < n; ++i) loadFile(files[i], i);
	    } else { // Normal drop
	      // Don't do a replace if the drop happened inside of the selected text.
	      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
	        cm.state.draggingText(e);
	        // Ensure the editor is re-focused
	        setTimeout(bind(focusInput, cm), 20);
	        return;
	      }
	      try {
	        var text = e.dataTransfer.getData("Text");
	        if (text) {
	          if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))
	            var selected = cm.listSelections();
	          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
	          if (selected) for (var i = 0; i < selected.length; ++i)
	            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
	          cm.replaceSelection(text, "around", "paste");
	          focusInput(cm);
	        }
	      }
	      catch(e){}
	    }
	  }

	  function onDragStart(cm, e) {
	    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
	    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

	    e.dataTransfer.setData("Text", cm.getSelection());

	    // Use dummy image instead of default browsers image.
	    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
	    if (e.dataTransfer.setDragImage && !safari) {
	      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
	      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
	      if (presto) {
	        img.width = img.height = 1;
	        cm.display.wrapper.appendChild(img);
	        // Force a relayout, or Opera won't use our image for some obscure reason
	        img._top = img.offsetTop;
	      }
	      e.dataTransfer.setDragImage(img, 0, 0);
	      if (presto) img.parentNode.removeChild(img);
	    }
	  }

	  // SCROLL EVENTS

	  // Sync the scrollable area and scrollbars, ensure the viewport
	  // covers the visible area.
	  function setScrollTop(cm, val) {
	    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
	    cm.doc.scrollTop = val;
	    if (!gecko) updateDisplaySimple(cm, {top: val});
	    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
	    cm.display.scrollbars.setScrollTop(val);
	    if (gecko) updateDisplaySimple(cm);
	    startWorker(cm, 100);
	  }
	  // Sync scroller and scrollbar, ensure the gutter elements are
	  // aligned.
	  function setScrollLeft(cm, val, isScroller) {
	    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
	    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
	    cm.doc.scrollLeft = val;
	    alignHorizontally(cm);
	    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
	    cm.display.scrollbars.setScrollLeft(val);
	  }

	  // Since the delta values reported on mouse wheel events are
	  // unstandardized between browsers and even browser versions, and
	  // generally horribly unpredictable, this code starts by measuring
	  // the scroll effect that the first few mouse wheel events have,
	  // and, from that, detects the way it can convert deltas to pixel
	  // offsets afterwards.
	  //
	  // The reason we want to know the amount a wheel event will scroll
	  // is that it gives us a chance to update the display before the
	  // actual scrolling happens, reducing flickering.

	  var wheelSamples = 0, wheelPixelsPerUnit = null;
	  // Fill in a browser-detected starting value on browsers where we
	  // know one. These don't have to be accurate -- the result of them
	  // being wrong would just be a slight flicker on the first wheel
	  // scroll (if it is large enough).
	  if (ie) wheelPixelsPerUnit = -.53;
	  else if (gecko) wheelPixelsPerUnit = 15;
	  else if (chrome) wheelPixelsPerUnit = -.7;
	  else if (safari) wheelPixelsPerUnit = -1/3;

	  var wheelEventDelta = function(e) {
	    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
	    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
	    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
	    else if (dy == null) dy = e.wheelDelta;
	    return {x: dx, y: dy};
	  };
	  CodeMirror.wheelEventPixels = function(e) {
	    var delta = wheelEventDelta(e);
	    delta.x *= wheelPixelsPerUnit;
	    delta.y *= wheelPixelsPerUnit;
	    return delta;
	  };

	  function onScrollWheel(cm, e) {
	    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

	    var display = cm.display, scroll = display.scroller;
	    // Quit if there's nothing to scroll here
	    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||
	          dy && scroll.scrollHeight > scroll.clientHeight)) return;

	    // Webkit browsers on OS X abort momentum scrolls when the target
	    // of the scroll event is removed from the scrollable element.
	    // This hack (see related code in patchDisplay) makes sure the
	    // element is kept around.
	    if (dy && mac && webkit) {
	      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
	        for (var i = 0; i < view.length; i++) {
	          if (view[i].node == cur) {
	            cm.display.currentWheelTarget = cur;
	            break outer;
	          }
	        }
	      }
	    }

	    // On some browsers, horizontal scrolling will cause redraws to
	    // happen before the gutter has been realigned, causing it to
	    // wriggle around in a most unseemly way. When we have an
	    // estimated pixels/delta value, we just handle horizontal
	    // scrolling entirely here. It'll be slightly off from native, but
	    // better than glitching out.
	    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
	      if (dy)
	        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
	      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
	      e_preventDefault(e);
	      display.wheelStartX = null; // Abort measurement, if in progress
	      return;
	    }

	    // 'Project' the visible viewport to cover the area that is being
	    // scrolled into view (if we know enough to estimate it).
	    if (dy && wheelPixelsPerUnit != null) {
	      var pixels = dy * wheelPixelsPerUnit;
	      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
	      if (pixels < 0) top = Math.max(0, top + pixels - 50);
	      else bot = Math.min(cm.doc.height, bot + pixels + 50);
	      updateDisplaySimple(cm, {top: top, bottom: bot});
	    }

	    if (wheelSamples < 20) {
	      if (display.wheelStartX == null) {
	        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
	        display.wheelDX = dx; display.wheelDY = dy;
	        setTimeout(function() {
	          if (display.wheelStartX == null) return;
	          var movedX = scroll.scrollLeft - display.wheelStartX;
	          var movedY = scroll.scrollTop - display.wheelStartY;
	          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
	            (movedX && display.wheelDX && movedX / display.wheelDX);
	          display.wheelStartX = display.wheelStartY = null;
	          if (!sample) return;
	          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
	          ++wheelSamples;
	        }, 200);
	      } else {
	        display.wheelDX += dx; display.wheelDY += dy;
	      }
	    }
	  }

	  // KEY EVENTS

	  // Run a handler that was bound to a key.
	  function doHandleBinding(cm, bound, dropShift) {
	    if (typeof bound == "string") {
	      bound = commands[bound];
	      if (!bound) return false;
	    }
	    // Ensure previous input has been read, so that the handler sees a
	    // consistent view of the document
	    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;
	    var prevShift = cm.display.shift, done = false;
	    try {
	      if (isReadOnly(cm)) cm.state.suppressEdits = true;
	      if (dropShift) cm.display.shift = false;
	      done = bound(cm) != Pass;
	    } finally {
	      cm.display.shift = prevShift;
	      cm.state.suppressEdits = false;
	    }
	    return done;
	  }

	  function lookupKeyForEditor(cm, name, handle) {
	    for (var i = 0; i < cm.state.keyMaps.length; i++) {
	      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
	      if (result) return result;
	    }
	    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
	      || lookupKey(name, cm.options.keyMap, handle, cm);
	  }

	  var stopSeq = new Delayed;
	  function dispatchKey(cm, name, e, handle) {
	    var seq = cm.state.keySeq;
	    if (seq) {
	      if (isModifierKey(name)) return "handled";
	      stopSeq.set(50, function() {
	        if (cm.state.keySeq == seq) {
	          cm.state.keySeq = null;
	          resetInput(cm);
	        }
	      });
	      name = seq + " " + name;
	    }
	    var result = lookupKeyForEditor(cm, name, handle);

	    if (result == "multi")
	      cm.state.keySeq = name;
	    if (result == "handled")
	      signalLater(cm, "keyHandled", cm, name, e);

	    if (result == "handled" || result == "multi") {
	      e_preventDefault(e);
	      restartBlink(cm);
	    }

	    if (seq && !result && /\'$/.test(name)) {
	      e_preventDefault(e);
	      return true;
	    }
	    return !!result;
	  }

	  // Handle a key from the keydown event.
	  function handleKeyBinding(cm, e) {
	    var name = keyName(e, true);
	    if (!name) return false;

	    if (e.shiftKey && !cm.state.keySeq) {
	      // First try to resolve full name (including 'Shift-'). Failing
	      // that, see if there is a cursor-motion command (starting with
	      // 'go') bound to the keyname without 'Shift-'.
	      return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})
	          || dispatchKey(cm, name, e, function(b) {
	               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
	                 return doHandleBinding(cm, b);
	             });
	    } else {
	      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });
	    }
	  }

	  // Handle a key from the keypress event
	  function handleCharBinding(cm, e, ch) {
	    return dispatchKey(cm, "'" + ch + "'", e,
	                       function(b) { return doHandleBinding(cm, b, true); });
	  }

	  var lastStoppedKey = null;
	  function onKeyDown(e) {
	    var cm = this;
	    ensureFocus(cm);
	    if (signalDOMEvent(cm, e)) return;
	    // IE does strange things with escape.
	    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
	    var code = e.keyCode;
	    cm.display.shift = code == 16 || e.shiftKey;
	    var handled = handleKeyBinding(cm, e);
	    if (presto) {
	      lastStoppedKey = handled ? code : null;
	      // Opera has no cut event... we try to at least catch the key combo
	      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
	        cm.replaceSelection("", null, "cut");
	    }

	    // Turn mouse into crosshair when Alt is held on Mac.
	    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
	      showCrossHair(cm);
	  }

	  function showCrossHair(cm) {
	    var lineDiv = cm.display.lineDiv;
	    addClass(lineDiv, "CodeMirror-crosshair");

	    function up(e) {
	      if (e.keyCode == 18 || !e.altKey) {
	        rmClass(lineDiv, "CodeMirror-crosshair");
	        off(document, "keyup", up);
	        off(document, "mouseover", up);
	      }
	    }
	    on(document, "keyup", up);
	    on(document, "mouseover", up);
	  }

	  function onKeyUp(e) {
	    if (e.keyCode == 16) this.doc.sel.shift = false;
	    signalDOMEvent(this, e);
	  }

	  function onKeyPress(e) {
	    var cm = this;
	    if (signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
	    var keyCode = e.keyCode, charCode = e.charCode;
	    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
	    if (((presto && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;
	    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
	    if (handleCharBinding(cm, e, ch)) return;
	    if (ie && ie_version >= 9) cm.display.inputHasSelection = null;
	    fastPoll(cm);
	  }

	  // FOCUS/BLUR EVENTS

	  function onFocus(cm) {
	    if (cm.options.readOnly == "nocursor") return;
	    if (!cm.state.focused) {
	      signal(cm, "focus", cm);
	      cm.state.focused = true;
	      addClass(cm.display.wrapper, "CodeMirror-focused");
	      // The prevInput test prevents this from firing when a context
	      // menu is closed (since the resetInput would kill the
	      // select-all detection hack)
	      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
	        resetInput(cm);
	        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730
	      }
	    }
	    slowPoll(cm);
	    restartBlink(cm);
	  }
	  function onBlur(cm) {
	    if (cm.state.focused) {
	      signal(cm, "blur", cm);
	      cm.state.focused = false;
	      rmClass(cm.display.wrapper, "CodeMirror-focused");
	    }
	    clearInterval(cm.display.blinker);
	    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
	  }

	  // CONTEXT MENU HANDLING

	  // To make the context menu work, we need to briefly unhide the
	  // textarea (making it as unobtrusive as possible) to let the
	  // right-click take effect on it.
	  function onContextMenu(cm, e) {
	    if (signalDOMEvent(cm, e, "contextmenu")) return;
	    var display = cm.display;
	    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;

	    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
	    if (!pos || presto) return; // Opera is difficult.

	    // Reset the current text selection only if the click is done outside of the selection
	    // and 'resetSelectionOnContextMenu' option is true.
	    var reset = cm.options.resetSelectionOnContextMenu;
	    if (reset && cm.doc.sel.contains(pos) == -1)
	      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

	    var oldCSS = display.input.style.cssText;
	    display.inputDiv.style.position = "absolute";
	    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
	      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " +
	      (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
	      "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
	    if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)
	    focusInput(cm);
	    if (webkit) window.scrollTo(null, oldScrollY);
	    resetInput(cm);
	    // Adds "Select all" to context menu in FF
	    if (!cm.somethingSelected()) display.input.value = display.prevInput = " ";
	    display.contextMenuPending = true;
	    display.selForContextMenu = cm.doc.sel;
	    clearTimeout(display.detectingSelectAll);

	    // Select-all will be greyed out if there's nothing to select, so
	    // this adds a zero-width space so that we can later check whether
	    // it got selected.
	    function prepareSelectAllHack() {
	      if (display.input.selectionStart != null) {
	        var selected = cm.somethingSelected();
	        var extval = display.input.value = "\u200b" + (selected ? display.input.value : "");
	        display.prevInput = selected ? "" : "\u200b";
	        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;
	        // Re-set this, in case some other handler touched the
	        // selection in the meantime.
	        display.selForContextMenu = cm.doc.sel;
	      }
	    }
	    function rehide() {
	      display.contextMenuPending = false;
	      display.inputDiv.style.position = "relative";
	      display.input.style.cssText = oldCSS;
	      if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
	      slowPoll(cm);

	      // Try to detect the user choosing select-all
	      if (display.input.selectionStart != null) {
	        if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();
	        var i = 0, poll = function() {
	          if (display.selForContextMenu == cm.doc.sel && display.input.selectionStart == 0)
	            operation(cm, commands.selectAll)(cm);
	          else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
	          else resetInput(cm);
	        };
	        display.detectingSelectAll = setTimeout(poll, 200);
	      }
	    }

	    if (ie && ie_version >= 9) prepareSelectAllHack();
	    if (captureRightClick) {
	      e_stop(e);
	      var mouseup = function() {
	        off(window, "mouseup", mouseup);
	        setTimeout(rehide, 20);
	      };
	      on(window, "mouseup", mouseup);
	    } else {
	      setTimeout(rehide, 50);
	    }
	  }

	  function contextMenuInGutter(cm, e) {
	    if (!hasHandler(cm, "gutterContextMenu")) return false;
	    return gutterEvent(cm, e, "gutterContextMenu", false, signal);
	  }

	  // UPDATING

	  // Compute the position of the end of a change (its 'to' property
	  // refers to the pre-change end).
	  var changeEnd = CodeMirror.changeEnd = function(change) {
	    if (!change.text) return change.to;
	    return Pos(change.from.line + change.text.length - 1,
	               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
	  };

	  // Adjust a position to refer to the post-change position of the
	  // same text, or the end of the change if the change covers it.
	  function adjustForChange(pos, change) {
	    if (cmp(pos, change.from) < 0) return pos;
	    if (cmp(pos, change.to) <= 0) return changeEnd(change);

	    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
	    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
	    return Pos(line, ch);
	  }

	  function computeSelAfterChange(doc, change) {
	    var out = [];
	    for (var i = 0; i < doc.sel.ranges.length; i++) {
	      var range = doc.sel.ranges[i];
	      out.push(new Range(adjustForChange(range.anchor, change),
	                         adjustForChange(range.head, change)));
	    }
	    return normalizeSelection(out, doc.sel.primIndex);
	  }

	  function offsetPos(pos, old, nw) {
	    if (pos.line == old.line)
	      return Pos(nw.line, pos.ch - old.ch + nw.ch);
	    else
	      return Pos(nw.line + (pos.line - old.line), pos.ch);
	  }

	  // Used by replaceSelections to allow moving the selection to the
	  // start or around the replaced test. Hint may be "start" or "around".
	  function computeReplacedSel(doc, changes, hint) {
	    var out = [];
	    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
	    for (var i = 0; i < changes.length; i++) {
	      var change = changes[i];
	      var from = offsetPos(change.from, oldPrev, newPrev);
	      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
	      oldPrev = change.to;
	      newPrev = to;
	      if (hint == "around") {
	        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
	        out[i] = new Range(inv ? to : from, inv ? from : to);
	      } else {
	        out[i] = new Range(from, from);
	      }
	    }
	    return new Selection(out, doc.sel.primIndex);
	  }

	  // Allow "beforeChange" event handlers to influence a change
	  function filterChange(doc, change, update) {
	    var obj = {
	      canceled: false,
	      from: change.from,
	      to: change.to,
	      text: change.text,
	      origin: change.origin,
	      cancel: function() { this.canceled = true; }
	    };
	    if (update) obj.update = function(from, to, text, origin) {
	      if (from) this.from = clipPos(doc, from);
	      if (to) this.to = clipPos(doc, to);
	      if (text) this.text = text;
	      if (origin !== undefined) this.origin = origin;
	    };
	    signal(doc, "beforeChange", doc, obj);
	    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

	    if (obj.canceled) return null;
	    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
	  }

	  // Apply a change to a document, and add it to the document's
	  // history, and propagating it to all linked documents.
	  function makeChange(doc, change, ignoreReadOnly) {
	    if (doc.cm) {
	      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
	      if (doc.cm.state.suppressEdits) return;
	    }

	    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
	      change = filterChange(doc, change, true);
	      if (!change) return;
	    }

	    // Possibly split or suppress the update based on the presence
	    // of read-only spans in its range.
	    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
	    if (split) {
	      for (var i = split.length - 1; i >= 0; --i)
	        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
	    } else {
	      makeChangeInner(doc, change);
	    }
	  }

	  function makeChangeInner(doc, change) {
	    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
	    var selAfter = computeSelAfterChange(doc, change);
	    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

	    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
	    var rebased = [];

	    linkedDocs(doc, function(doc, sharedHist) {
	      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	        rebaseHist(doc.history, change);
	        rebased.push(doc.history);
	      }
	      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
	    });
	  }

	  // Revert a change stored in a document's history.
	  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
	    if (doc.cm && doc.cm.state.suppressEdits) return;

	    var hist = doc.history, event, selAfter = doc.sel;
	    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

	    // Verify that there is a useable event (so that ctrl-z won't
	    // needlessly clear selection events)
	    for (var i = 0; i < source.length; i++) {
	      event = source[i];
	      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
	        break;
	    }
	    if (i == source.length) return;
	    hist.lastOrigin = hist.lastSelOrigin = null;

	    for (;;) {
	      event = source.pop();
	      if (event.ranges) {
	        pushSelectionToHistory(event, dest);
	        if (allowSelectionOnly && !event.equals(doc.sel)) {
	          setSelection(doc, event, {clearRedo: false});
	          return;
	        }
	        selAfter = event;
	      }
	      else break;
	    }

	    // Build up a reverse change object to add to the opposite history
	    // stack (redo when undoing, and vice versa).
	    var antiChanges = [];
	    pushSelectionToHistory(selAfter, dest);
	    dest.push({changes: antiChanges, generation: hist.generation});
	    hist.generation = event.generation || ++hist.maxGeneration;

	    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

	    for (var i = event.changes.length - 1; i >= 0; --i) {
	      var change = event.changes[i];
	      change.origin = type;
	      if (filter && !filterChange(doc, change, false)) {
	        source.length = 0;
	        return;
	      }

	      antiChanges.push(historyChangeFromChange(doc, change));

	      var after = i ? computeSelAfterChange(doc, change) : lst(source);
	      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
	      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
	      var rebased = [];

	      // Propagate to the linked documents
	      linkedDocs(doc, function(doc, sharedHist) {
	        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	          rebaseHist(doc.history, change);
	          rebased.push(doc.history);
	        }
	        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
	      });
	    }
	  }

	  // Sub-views need their line numbers shifted when text is added
	  // above or below them in the parent document.
	  function shiftDoc(doc, distance) {
	    if (distance == 0) return;
	    doc.first += distance;
	    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
	      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
	                       Pos(range.head.line + distance, range.head.ch));
	    }), doc.sel.primIndex);
	    if (doc.cm) {
	      regChange(doc.cm, doc.first, doc.first - distance, distance);
	      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
	        regLineChange(doc.cm, l, "gutter");
	    }
	  }

	  // More lower-level change function, handling only a single document
	  // (not linked ones).
	  function makeChangeSingleDoc(doc, change, selAfter, spans) {
	    if (doc.cm && !doc.cm.curOp)
	      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

	    if (change.to.line < doc.first) {
	      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
	      return;
	    }
	    if (change.from.line > doc.lastLine()) return;

	    // Clip the change to the size of this doc
	    if (change.from.line < doc.first) {
	      var shift = change.text.length - 1 - (doc.first - change.from.line);
	      shiftDoc(doc, shift);
	      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
	                text: [lst(change.text)], origin: change.origin};
	    }
	    var last = doc.lastLine();
	    if (change.to.line > last) {
	      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
	                text: [change.text[0]], origin: change.origin};
	    }

	    change.removed = getBetween(doc, change.from, change.to);

	    if (!selAfter) selAfter = computeSelAfterChange(doc, change);
	    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
	    else updateDoc(doc, change, spans);
	    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
	  }

	  // Handle the interaction of a change to a document with the editor
	  // that this document is part of.
	  function makeChangeSingleDocInEditor(cm, change, spans) {
	    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

	    var recomputeMaxLength = false, checkWidthStart = from.line;
	    if (!cm.options.lineWrapping) {
	      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
	      doc.iter(checkWidthStart, to.line + 1, function(line) {
	        if (line == display.maxLine) {
	          recomputeMaxLength = true;
	          return true;
	        }
	      });
	    }

	    if (doc.sel.contains(change.from, change.to) > -1)
	      signalCursorActivity(cm);

	    updateDoc(doc, change, spans, estimateHeight(cm));

	    if (!cm.options.lineWrapping) {
	      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
	        var len = lineLength(line);
	        if (len > display.maxLineLength) {
	          display.maxLine = line;
	          display.maxLineLength = len;
	          display.maxLineChanged = true;
	          recomputeMaxLength = false;
	        }
	      });
	      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
	    }

	    // Adjust frontier, schedule worker
	    doc.frontier = Math.min(doc.frontier, from.line);
	    startWorker(cm, 400);

	    var lendiff = change.text.length - (to.line - from.line) - 1;
	    // Remember that these lines changed, for updating the display
	    if (change.full)
	      regChange(cm);
	    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
	      regLineChange(cm, from.line, "text");
	    else
	      regChange(cm, from.line, to.line + 1, lendiff);

	    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
	    if (changeHandler || changesHandler) {
	      var obj = {
	        from: from, to: to,
	        text: change.text,
	        removed: change.removed,
	        origin: change.origin
	      };
	      if (changeHandler) signalLater(cm, "change", cm, obj);
	      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
	    }
	    cm.display.selForContextMenu = null;
	  }

	  function replaceRange(doc, code, from, to, origin) {
	    if (!to) to = from;
	    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
	    if (typeof code == "string") code = splitLines(code);
	    makeChange(doc, {from: from, to: to, text: code, origin: origin});
	  }

	  // SCROLLING THINGS INTO VIEW

	  // If an editor sits on the top or bottom of the window, partially
	  // scrolled out of view, this ensures that the cursor is visible.
	  function maybeScrollWindow(cm, coords) {
	    if (signalDOMEvent(cm, "scrollCursorIntoView")) return;

	    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
	    if (coords.top + box.top < 0) doScroll = true;
	    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
	    if (doScroll != null && !phantom) {
	      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
	                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
	                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +
	                           coords.left + "px; width: 2px;");
	      cm.display.lineSpace.appendChild(scrollNode);
	      scrollNode.scrollIntoView(doScroll);
	      cm.display.lineSpace.removeChild(scrollNode);
	    }
	  }

	  // Scroll a given position into view (immediately), verifying that
	  // it actually became visible (as line heights are accurately
	  // measured, the position of something may 'drift' during drawing).
	  function scrollPosIntoView(cm, pos, end, margin) {
	    if (margin == null) margin = 0;
	    for (var limit = 0; limit < 5; limit++) {
	      var changed = false, coords = cursorCoords(cm, pos);
	      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
	      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
	                                         Math.min(coords.top, endCoords.top) - margin,
	                                         Math.max(coords.left, endCoords.left),
	                                         Math.max(coords.bottom, endCoords.bottom) + margin);
	      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
	      if (scrollPos.scrollTop != null) {
	        setScrollTop(cm, scrollPos.scrollTop);
	        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
	      }
	      if (scrollPos.scrollLeft != null) {
	        setScrollLeft(cm, scrollPos.scrollLeft);
	        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
	      }
	      if (!changed) break;
	    }
	    return coords;
	  }

	  // Scroll a given set of coordinates into view (immediately).
	  function scrollIntoView(cm, x1, y1, x2, y2) {
	    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
	    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
	    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
	  }

	  // Calculate a new scroll position needed to scroll the given
	  // rectangle into view. Returns an object with scrollTop and
	  // scrollLeft properties. When these are undefined, the
	  // vertical/horizontal position does not need to be adjusted.
	  function calculateScrollPos(cm, x1, y1, x2, y2) {
	    var display = cm.display, snapMargin = textHeight(cm.display);
	    if (y1 < 0) y1 = 0;
	    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
	    var screen = displayHeight(cm), result = {};
	    if (y2 - y1 > screen) y2 = y1 + screen;
	    var docBottom = cm.doc.height + paddingVert(display);
	    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
	    if (y1 < screentop) {
	      result.scrollTop = atTop ? 0 : y1;
	    } else if (y2 > screentop + screen) {
	      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
	      if (newTop != screentop) result.scrollTop = newTop;
	    }

	    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
	    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
	    var tooWide = x2 - x1 > screenw;
	    if (tooWide) x2 = x1 + screenw;
	    if (x1 < 10)
	      result.scrollLeft = 0;
	    else if (x1 < screenleft)
	      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
	    else if (x2 > screenw + screenleft - 3)
	      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
	    return result;
	  }

	  // Store a relative adjustment to the scroll position in the current
	  // operation (to be applied when the operation finishes).
	  function addToScrollPos(cm, left, top) {
	    if (left != null || top != null) resolveScrollToPos(cm);
	    if (left != null)
	      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
	    if (top != null)
	      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
	  }

	  // Make sure that at the end of the operation the current cursor is
	  // shown.
	  function ensureCursorVisible(cm) {
	    resolveScrollToPos(cm);
	    var cur = cm.getCursor(), from = cur, to = cur;
	    if (!cm.options.lineWrapping) {
	      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
	      to = Pos(cur.line, cur.ch + 1);
	    }
	    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
	  }

	  // When an operation has its scrollToPos property set, and another
	  // scroll action is applied before the end of the operation, this
	  // 'simulates' scrolling that position into view in a cheap way, so
	  // that the effect of intermediate scroll commands is not ignored.
	  function resolveScrollToPos(cm) {
	    var range = cm.curOp.scrollToPos;
	    if (range) {
	      cm.curOp.scrollToPos = null;
	      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
	      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
	                                    Math.min(from.top, to.top) - range.margin,
	                                    Math.max(from.right, to.right),
	                                    Math.max(from.bottom, to.bottom) + range.margin);
	      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
	    }
	  }

	  // API UTILITIES

	  // Indent the given line. The how parameter can be "smart",
	  // "add"/null, "subtract", or "prev". When aggressive is false
	  // (typically set to true for forced single-line indents), empty
	  // lines are not indented, and places where the mode returns Pass
	  // are left alone.
	  function indentLine(cm, n, how, aggressive) {
	    var doc = cm.doc, state;
	    if (how == null) how = "add";
	    if (how == "smart") {
	      // Fall back to "prev" when the mode doesn't have an indentation
	      // method.
	      if (!doc.mode.indent) how = "prev";
	      else state = getStateBefore(cm, n);
	    }

	    var tabSize = cm.options.tabSize;
	    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
	    if (line.stateAfter) line.stateAfter = null;
	    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
	    if (!aggressive && !/\S/.test(line.text)) {
	      indentation = 0;
	      how = "not";
	    } else if (how == "smart") {
	      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
	      if (indentation == Pass || indentation > 150) {
	        if (!aggressive) return;
	        how = "prev";
	      }
	    }
	    if (how == "prev") {
	      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
	      else indentation = 0;
	    } else if (how == "add") {
	      indentation = curSpace + cm.options.indentUnit;
	    } else if (how == "subtract") {
	      indentation = curSpace - cm.options.indentUnit;
	    } else if (typeof how == "number") {
	      indentation = curSpace + how;
	    }
	    indentation = Math.max(0, indentation);

	    var indentString = "", pos = 0;
	    if (cm.options.indentWithTabs)
	      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
	    if (pos < indentation) indentString += spaceStr(indentation - pos);

	    if (indentString != curSpaceString) {
	      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
	    } else {
	      // Ensure that, if the cursor was in the whitespace at the start
	      // of the line, it is moved to the end of that space.
	      for (var i = 0; i < doc.sel.ranges.length; i++) {
	        var range = doc.sel.ranges[i];
	        if (range.head.line == n && range.head.ch < curSpaceString.length) {
	          var pos = Pos(n, curSpaceString.length);
	          replaceOneSelection(doc, i, new Range(pos, pos));
	          break;
	        }
	      }
	    }
	    line.stateAfter = null;
	  }

	  // Utility for applying a change to a line by handle or number,
	  // returning the number and optionally registering the line as
	  // changed.
	  function changeLine(doc, handle, changeType, op) {
	    var no = handle, line = handle;
	    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
	    else no = lineNo(handle);
	    if (no == null) return null;
	    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
	    return line;
	  }

	  // Helper for deleting text near the selection(s), used to implement
	  // backspace, delete, and similar functionality.
	  function deleteNearSelection(cm, compute) {
	    var ranges = cm.doc.sel.ranges, kill = [];
	    // Build up a set of ranges to kill first, merging overlapping
	    // ranges.
	    for (var i = 0; i < ranges.length; i++) {
	      var toKill = compute(ranges[i]);
	      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
	        var replaced = kill.pop();
	        if (cmp(replaced.from, toKill.from) < 0) {
	          toKill.from = replaced.from;
	          break;
	        }
	      }
	      kill.push(toKill);
	    }
	    // Next, remove those actual ranges.
	    runInOp(cm, function() {
	      for (var i = kill.length - 1; i >= 0; i--)
	        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
	      ensureCursorVisible(cm);
	    });
	  }

	  // Used for horizontal relative motion. Dir is -1 or 1 (left or
	  // right), unit can be "char", "column" (like char, but doesn't
	  // cross line boundaries), "word" (across next word), or "group" (to
	  // the start of next group of word or non-word-non-whitespace
	  // chars). The visually param controls whether, in right-to-left
	  // text, direction 1 means to move towards the next index in the
	  // string, or towards the character to the right of the current
	  // position. The resulting position will have a hitSide=true
	  // property if it reached the end of the document.
	  function findPosH(doc, pos, dir, unit, visually) {
	    var line = pos.line, ch = pos.ch, origDir = dir;
	    var lineObj = getLine(doc, line);
	    var possible = true;
	    function findNextLine() {
	      var l = line + dir;
	      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
	      line = l;
	      return lineObj = getLine(doc, l);
	    }
	    function moveOnce(boundToLine) {
	      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
	      if (next == null) {
	        if (!boundToLine && findNextLine()) {
	          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
	          else ch = dir < 0 ? lineObj.text.length : 0;
	        } else return (possible = false);
	      } else ch = next;
	      return true;
	    }

	    if (unit == "char") moveOnce();
	    else if (unit == "column") moveOnce(true);
	    else if (unit == "word" || unit == "group") {
	      var sawType = null, group = unit == "group";
	      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
	      for (var first = true;; first = false) {
	        if (dir < 0 && !moveOnce(!first)) break;
	        var cur = lineObj.text.charAt(ch) || "\n";
	        var type = isWordChar(cur, helper) ? "w"
	          : group && cur == "\n" ? "n"
	          : !group || /\s/.test(cur) ? null
	          : "p";
	        if (group && !first && !type) type = "s";
	        if (sawType && sawType != type) {
	          if (dir < 0) {dir = 1; moveOnce();}
	          break;
	        }

	        if (type) sawType = type;
	        if (dir > 0 && !moveOnce(!first)) break;
	      }
	    }
	    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
	    if (!possible) result.hitSide = true;
	    return result;
	  }

	  // For relative vertical movement. Dir may be -1 or 1. Unit can be
	  // "page" or "line". The resulting position will have a hitSide=true
	  // property if it reached the end of the document.
	  function findPosV(cm, pos, dir, unit) {
	    var doc = cm.doc, x = pos.left, y;
	    if (unit == "page") {
	      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
	      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
	    } else if (unit == "line") {
	      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
	    }
	    for (;;) {
	      var target = coordsChar(cm, x, y);
	      if (!target.outside) break;
	      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
	      y += dir * 5;
	    }
	    return target;
	  }

	  // EDITOR METHODS

	  // The publicly visible API. Note that methodOp(f) means
	  // 'wrap f in an operation, performed on its `this` parameter'.

	  // This is not the complete set of editor methods. Most of the
	  // methods defined on the Doc type are also injected into
	  // CodeMirror.prototype, for backwards compatibility and
	  // convenience.

	  CodeMirror.prototype = {
	    constructor: CodeMirror,
	    focus: function(){window.focus(); focusInput(this); fastPoll(this);},

	    setOption: function(option, value) {
	      var options = this.options, old = options[option];
	      if (options[option] == value && option != "mode") return;
	      options[option] = value;
	      if (optionHandlers.hasOwnProperty(option))
	        operation(this, optionHandlers[option])(this, value, old);
	    },

	    getOption: function(option) {return this.options[option];},
	    getDoc: function() {return this.doc;},

	    addKeyMap: function(map, bottom) {
	      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
	    },
	    removeKeyMap: function(map) {
	      var maps = this.state.keyMaps;
	      for (var i = 0; i < maps.length; ++i)
	        if (maps[i] == map || maps[i].name == map) {
	          maps.splice(i, 1);
	          return true;
	        }
	    },

	    addOverlay: methodOp(function(spec, options) {
	      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
	      if (mode.startState) throw new Error("Overlays may not be stateful.");
	      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
	      this.state.modeGen++;
	      regChange(this);
	    }),
	    removeOverlay: methodOp(function(spec) {
	      var overlays = this.state.overlays;
	      for (var i = 0; i < overlays.length; ++i) {
	        var cur = overlays[i].modeSpec;
	        if (cur == spec || typeof spec == "string" && cur.name == spec) {
	          overlays.splice(i, 1);
	          this.state.modeGen++;
	          regChange(this);
	          return;
	        }
	      }
	    }),

	    indentLine: methodOp(function(n, dir, aggressive) {
	      if (typeof dir != "string" && typeof dir != "number") {
	        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
	        else dir = dir ? "add" : "subtract";
	      }
	      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
	    }),
	    indentSelection: methodOp(function(how) {
	      var ranges = this.doc.sel.ranges, end = -1;
	      for (var i = 0; i < ranges.length; i++) {
	        var range = ranges[i];
	        if (!range.empty()) {
	          var from = range.from(), to = range.to();
	          var start = Math.max(end, from.line);
	          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
	          for (var j = start; j < end; ++j)
	            indentLine(this, j, how);
	          var newRanges = this.doc.sel.ranges;
	          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
	            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
	        } else if (range.head.line > end) {
	          indentLine(this, range.head.line, how, true);
	          end = range.head.line;
	          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
	        }
	      }
	    }),

	    // Fetch the parser token for a given character. Useful for hacks
	    // that want to inspect the mode state (say, for completion).
	    getTokenAt: function(pos, precise) {
	      return takeToken(this, pos, precise);
	    },

	    getLineTokens: function(line, precise) {
	      return takeToken(this, Pos(line), precise, true);
	    },

	    getTokenTypeAt: function(pos) {
	      pos = clipPos(this.doc, pos);
	      var styles = getLineStyles(this, getLine(this.doc, pos.line));
	      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
	      var type;
	      if (ch == 0) type = styles[2];
	      else for (;;) {
	        var mid = (before + after) >> 1;
	        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
	        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
	        else { type = styles[mid * 2 + 2]; break; }
	      }
	      var cut = type ? type.indexOf("cm-overlay ") : -1;
	      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
	    },

	    getModeAt: function(pos) {
	      var mode = this.doc.mode;
	      if (!mode.innerMode) return mode;
	      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
	    },

	    getHelper: function(pos, type) {
	      return this.getHelpers(pos, type)[0];
	    },

	    getHelpers: function(pos, type) {
	      var found = [];
	      if (!helpers.hasOwnProperty(type)) return helpers;
	      var help = helpers[type], mode = this.getModeAt(pos);
	      if (typeof mode[type] == "string") {
	        if (help[mode[type]]) found.push(help[mode[type]]);
	      } else if (mode[type]) {
	        for (var i = 0; i < mode[type].length; i++) {
	          var val = help[mode[type][i]];
	          if (val) found.push(val);
	        }
	      } else if (mode.helperType && help[mode.helperType]) {
	        found.push(help[mode.helperType]);
	      } else if (help[mode.name]) {
	        found.push(help[mode.name]);
	      }
	      for (var i = 0; i < help._global.length; i++) {
	        var cur = help._global[i];
	        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
	          found.push(cur.val);
	      }
	      return found;
	    },

	    getStateAfter: function(line, precise) {
	      var doc = this.doc;
	      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
	      return getStateBefore(this, line + 1, precise);
	    },

	    cursorCoords: function(start, mode) {
	      var pos, range = this.doc.sel.primary();
	      if (start == null) pos = range.head;
	      else if (typeof start == "object") pos = clipPos(this.doc, start);
	      else pos = start ? range.from() : range.to();
	      return cursorCoords(this, pos, mode || "page");
	    },

	    charCoords: function(pos, mode) {
	      return charCoords(this, clipPos(this.doc, pos), mode || "page");
	    },

	    coordsChar: function(coords, mode) {
	      coords = fromCoordSystem(this, coords, mode || "page");
	      return coordsChar(this, coords.left, coords.top);
	    },

	    lineAtHeight: function(height, mode) {
	      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
	      return lineAtHeight(this.doc, height + this.display.viewOffset);
	    },
	    heightAtLine: function(line, mode) {
	      var end = false, last = this.doc.first + this.doc.size - 1;
	      if (line < this.doc.first) line = this.doc.first;
	      else if (line > last) { line = last; end = true; }
	      var lineObj = getLine(this.doc, line);
	      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
	        (end ? this.doc.height - heightAtLine(lineObj) : 0);
	    },

	    defaultTextHeight: function() { return textHeight(this.display); },
	    defaultCharWidth: function() { return charWidth(this.display); },

	    setGutterMarker: methodOp(function(line, gutterID, value) {
	      return changeLine(this.doc, line, "gutter", function(line) {
	        var markers = line.gutterMarkers || (line.gutterMarkers = {});
	        markers[gutterID] = value;
	        if (!value && isEmpty(markers)) line.gutterMarkers = null;
	        return true;
	      });
	    }),

	    clearGutter: methodOp(function(gutterID) {
	      var cm = this, doc = cm.doc, i = doc.first;
	      doc.iter(function(line) {
	        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
	          line.gutterMarkers[gutterID] = null;
	          regLineChange(cm, i, "gutter");
	          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
	        }
	        ++i;
	      });
	    }),

	    addLineWidget: methodOp(function(handle, node, options) {
	      return addLineWidget(this, handle, node, options);
	    }),

	    removeLineWidget: function(widget) { widget.clear(); },

	    lineInfo: function(line) {
	      if (typeof line == "number") {
	        if (!isLine(this.doc, line)) return null;
	        var n = line;
	        line = getLine(this.doc, line);
	        if (!line) return null;
	      } else {
	        var n = lineNo(line);
	        if (n == null) return null;
	      }
	      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
	              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
	              widgets: line.widgets};
	    },

	    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

	    addWidget: function(pos, node, scroll, vert, horiz) {
	      var display = this.display;
	      pos = cursorCoords(this, clipPos(this.doc, pos));
	      var top = pos.bottom, left = pos.left;
	      node.style.position = "absolute";
	      node.setAttribute("cm-ignore-events", "true");
	      display.sizer.appendChild(node);
	      if (vert == "over") {
	        top = pos.top;
	      } else if (vert == "above" || vert == "near") {
	        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
	        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
	        // Default to positioning above (if specified and possible); otherwise default to positioning below
	        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
	          top = pos.top - node.offsetHeight;
	        else if (pos.bottom + node.offsetHeight <= vspace)
	          top = pos.bottom;
	        if (left + node.offsetWidth > hspace)
	          left = hspace - node.offsetWidth;
	      }
	      node.style.top = top + "px";
	      node.style.left = node.style.right = "";
	      if (horiz == "right") {
	        left = display.sizer.clientWidth - node.offsetWidth;
	        node.style.right = "0px";
	      } else {
	        if (horiz == "left") left = 0;
	        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
	        node.style.left = left + "px";
	      }
	      if (scroll)
	        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
	    },

	    triggerOnKeyDown: methodOp(onKeyDown),
	    triggerOnKeyPress: methodOp(onKeyPress),
	    triggerOnKeyUp: onKeyUp,

	    execCommand: function(cmd) {
	      if (commands.hasOwnProperty(cmd))
	        return commands[cmd](this);
	    },

	    findPosH: function(from, amount, unit, visually) {
	      var dir = 1;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
	        cur = findPosH(this.doc, cur, dir, unit, visually);
	        if (cur.hitSide) break;
	      }
	      return cur;
	    },

	    moveH: methodOp(function(dir, unit) {
	      var cm = this;
	      cm.extendSelectionsBy(function(range) {
	        if (cm.display.shift || cm.doc.extend || range.empty())
	          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
	        else
	          return dir < 0 ? range.from() : range.to();
	      }, sel_move);
	    }),

	    deleteH: methodOp(function(dir, unit) {
	      var sel = this.doc.sel, doc = this.doc;
	      if (sel.somethingSelected())
	        doc.replaceSelection("", null, "+delete");
	      else
	        deleteNearSelection(this, function(range) {
	          var other = findPosH(doc, range.head, dir, unit, false);
	          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
	        });
	    }),

	    findPosV: function(from, amount, unit, goalColumn) {
	      var dir = 1, x = goalColumn;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
	        var coords = cursorCoords(this, cur, "div");
	        if (x == null) x = coords.left;
	        else coords.left = x;
	        cur = findPosV(this, coords, dir, unit);
	        if (cur.hitSide) break;
	      }
	      return cur;
	    },

	    moveV: methodOp(function(dir, unit) {
	      var cm = this, doc = this.doc, goals = [];
	      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
	      doc.extendSelectionsBy(function(range) {
	        if (collapse)
	          return dir < 0 ? range.from() : range.to();
	        var headPos = cursorCoords(cm, range.head, "div");
	        if (range.goalColumn != null) headPos.left = range.goalColumn;
	        goals.push(headPos.left);
	        var pos = findPosV(cm, headPos, dir, unit);
	        if (unit == "page" && range == doc.sel.primary())
	          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
	        return pos;
	      }, sel_move);
	      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
	        doc.sel.ranges[i].goalColumn = goals[i];
	    }),

	    // Find the word at the given position (as returned by coordsChar).
	    findWordAt: function(pos) {
	      var doc = this.doc, line = getLine(doc, pos.line).text;
	      var start = pos.ch, end = pos.ch;
	      if (line) {
	        var helper = this.getHelper(pos, "wordChars");
	        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
	        var startChar = line.charAt(start);
	        var check = isWordChar(startChar, helper)
	          ? function(ch) { return isWordChar(ch, helper); }
	          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
	          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
	        while (start > 0 && check(line.charAt(start - 1))) --start;
	        while (end < line.length && check(line.charAt(end))) ++end;
	      }
	      return new Range(Pos(pos.line, start), Pos(pos.line, end));
	    },

	    toggleOverwrite: function(value) {
	      if (value != null && value == this.state.overwrite) return;
	      if (this.state.overwrite = !this.state.overwrite)
	        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
	      else
	        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

	      signal(this, "overwriteToggle", this, this.state.overwrite);
	    },
	    hasFocus: function() { return activeElt() == this.display.input; },

	    scrollTo: methodOp(function(x, y) {
	      if (x != null || y != null) resolveScrollToPos(this);
	      if (x != null) this.curOp.scrollLeft = x;
	      if (y != null) this.curOp.scrollTop = y;
	    }),
	    getScrollInfo: function() {
	      var scroller = this.display.scroller;
	      return {left: scroller.scrollLeft, top: scroller.scrollTop,
	              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
	              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
	              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};
	    },

	    scrollIntoView: methodOp(function(range, margin) {
	      if (range == null) {
	        range = {from: this.doc.sel.primary().head, to: null};
	        if (margin == null) margin = this.options.cursorScrollMargin;
	      } else if (typeof range == "number") {
	        range = {from: Pos(range, 0), to: null};
	      } else if (range.from == null) {
	        range = {from: range, to: null};
	      }
	      if (!range.to) range.to = range.from;
	      range.margin = margin || 0;

	      if (range.from.line != null) {
	        resolveScrollToPos(this);
	        this.curOp.scrollToPos = range;
	      } else {
	        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
	                                      Math.min(range.from.top, range.to.top) - range.margin,
	                                      Math.max(range.from.right, range.to.right),
	                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
	        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
	      }
	    }),

	    setSize: methodOp(function(width, height) {
	      var cm = this;
	      function interpret(val) {
	        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
	      }
	      if (width != null) cm.display.wrapper.style.width = interpret(width);
	      if (height != null) cm.display.wrapper.style.height = interpret(height);
	      if (cm.options.lineWrapping) clearLineMeasurementCache(this);
	      var lineNo = cm.display.viewFrom;
	      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
	        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
	          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
	        ++lineNo;
	      });
	      cm.curOp.forceUpdate = true;
	      signal(cm, "refresh", this);
	    }),

	    operation: function(f){return runInOp(this, f);},

	    refresh: methodOp(function() {
	      var oldHeight = this.display.cachedTextHeight;
	      regChange(this);
	      this.curOp.forceUpdate = true;
	      clearCaches(this);
	      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
	      updateGutterSpace(this);
	      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
	        estimateLineHeights(this);
	      signal(this, "refresh", this);
	    }),

	    swapDoc: methodOp(function(doc) {
	      var old = this.doc;
	      old.cm = null;
	      attachDoc(this, doc);
	      clearCaches(this);
	      resetInput(this);
	      this.scrollTo(doc.scrollLeft, doc.scrollTop);
	      this.curOp.forceScroll = true;
	      signalLater(this, "swapDoc", this, old);
	      return old;
	    }),

	    getInputField: function(){return this.display.input;},
	    getWrapperElement: function(){return this.display.wrapper;},
	    getScrollerElement: function(){return this.display.scroller;},
	    getGutterElement: function(){return this.display.gutters;}
	  };
	  eventMixin(CodeMirror);

	  // OPTION DEFAULTS

	  // The default configuration options.
	  var defaults = CodeMirror.defaults = {};
	  // Functions to run when options are changed.
	  var optionHandlers = CodeMirror.optionHandlers = {};

	  function option(name, deflt, handle, notOnInit) {
	    CodeMirror.defaults[name] = deflt;
	    if (handle) optionHandlers[name] =
	      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
	  }

	  // Passed to option handlers when there is no old value.
	  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

	  // These two are, on init, called from the constructor because they
	  // have to be initialized before the editor can start at all.
	  option("value", "", function(cm, val) {
	    cm.setValue(val);
	  }, true);
	  option("mode", null, function(cm, val) {
	    cm.doc.modeOption = val;
	    loadMode(cm);
	  }, true);

	  option("indentUnit", 2, loadMode, true);
	  option("indentWithTabs", false);
	  option("smartIndent", true);
	  option("tabSize", 4, function(cm) {
	    resetModeState(cm);
	    clearCaches(cm);
	    regChange(cm);
	  }, true);
	  option("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val) {
	    cm.options.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
	    cm.refresh();
	  }, true);
	  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
	  option("electricChars", true);
	  option("rtlMoveVisually", !windows);
	  option("wholeLineUpdateBefore", true);

	  option("theme", "default", function(cm) {
	    themeChanged(cm);
	    guttersChanged(cm);
	  }, true);
	  option("keyMap", "default", function(cm, val, old) {
	    var next = getKeyMap(val);
	    var prev = old != CodeMirror.Init && getKeyMap(old);
	    if (prev && prev.detach) prev.detach(cm, next);
	    if (next.attach) next.attach(cm, prev || null);
	  });
	  option("extraKeys", null);

	  option("lineWrapping", false, wrappingChanged, true);
	  option("gutters", [], function(cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("fixedGutter", true, function(cm, val) {
	    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
	    cm.refresh();
	  }, true);
	  option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);
	  option("scrollbarStyle", "native", function(cm) {
	    initScrollbars(cm);
	    updateScrollbars(cm);
	    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
	    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
	  }, true);
	  option("lineNumbers", false, function(cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("firstLineNumber", 1, guttersChanged, true);
	  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
	  option("showCursorWhenSelecting", false, updateSelection, true);

	  option("resetSelectionOnContextMenu", true);

	  option("readOnly", false, function(cm, val) {
	    if (val == "nocursor") {
	      onBlur(cm);
	      cm.display.input.blur();
	      cm.display.disabled = true;
	    } else {
	      cm.display.disabled = false;
	      if (!val) resetInput(cm);
	    }
	  });
	  option("disableInput", false, function(cm, val) {if (!val) resetInput(cm);}, true);
	  option("dragDrop", true);

	  option("cursorBlinkRate", 530);
	  option("cursorScrollMargin", 0);
	  option("cursorHeight", 1, updateSelection, true);
	  option("singleCursorHeightPerLine", true, updateSelection, true);
	  option("workTime", 100);
	  option("workDelay", 100);
	  option("flattenSpans", true, resetModeState, true);
	  option("addModeClass", false, resetModeState, true);
	  option("pollInterval", 100);
	  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
	  option("historyEventDelay", 1250);
	  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
	  option("maxHighlightLength", 10000, resetModeState, true);
	  option("moveInputWithCursor", true, function(cm, val) {
	    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
	  });

	  option("tabindex", null, function(cm, val) {
	    cm.display.input.tabIndex = val || "";
	  });
	  option("autofocus", null);

	  // MODE DEFINITION AND QUERYING

	  // Known modes, by name and by MIME
	  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

	  // Extra arguments are stored as the mode's dependencies, which is
	  // used by (legacy) mechanisms like loadmode.js to automatically
	  // load a mode. (Preferred mechanism is the require/define calls.)
	  CodeMirror.defineMode = function(name, mode) {
	    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
	    if (arguments.length > 2)
	      mode.dependencies = Array.prototype.slice.call(arguments, 2);
	    modes[name] = mode;
	  };

	  CodeMirror.defineMIME = function(mime, spec) {
	    mimeModes[mime] = spec;
	  };

	  // Given a MIME type, a {name, ...options} config object, or a name
	  // string, return a mode config object.
	  CodeMirror.resolveMode = function(spec) {
	    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
	      spec = mimeModes[spec];
	    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
	      var found = mimeModes[spec.name];
	      if (typeof found == "string") found = {name: found};
	      spec = createObj(found, spec);
	      spec.name = found.name;
	    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
	      return CodeMirror.resolveMode("application/xml");
	    }
	    if (typeof spec == "string") return {name: spec};
	    else return spec || {name: "null"};
	  };

	  // Given a mode spec (anything that resolveMode accepts), find and
	  // initialize an actual mode object.
	  CodeMirror.getMode = function(options, spec) {
	    var spec = CodeMirror.resolveMode(spec);
	    var mfactory = modes[spec.name];
	    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
	    var modeObj = mfactory(options, spec);
	    if (modeExtensions.hasOwnProperty(spec.name)) {
	      var exts = modeExtensions[spec.name];
	      for (var prop in exts) {
	        if (!exts.hasOwnProperty(prop)) continue;
	        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
	        modeObj[prop] = exts[prop];
	      }
	    }
	    modeObj.name = spec.name;
	    if (spec.helperType) modeObj.helperType = spec.helperType;
	    if (spec.modeProps) for (var prop in spec.modeProps)
	      modeObj[prop] = spec.modeProps[prop];

	    return modeObj;
	  };

	  // Minimal default mode.
	  CodeMirror.defineMode("null", function() {
	    return {token: function(stream) {stream.skipToEnd();}};
	  });
	  CodeMirror.defineMIME("text/plain", "null");

	  // This can be used to attach properties to mode objects from
	  // outside the actual mode definition.
	  var modeExtensions = CodeMirror.modeExtensions = {};
	  CodeMirror.extendMode = function(mode, properties) {
	    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
	    copyObj(properties, exts);
	  };

	  // EXTENSIONS

	  CodeMirror.defineExtension = function(name, func) {
	    CodeMirror.prototype[name] = func;
	  };
	  CodeMirror.defineDocExtension = function(name, func) {
	    Doc.prototype[name] = func;
	  };
	  CodeMirror.defineOption = option;

	  var initHooks = [];
	  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

	  var helpers = CodeMirror.helpers = {};
	  CodeMirror.registerHelper = function(type, name, value) {
	    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
	    helpers[type][name] = value;
	  };
	  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
	    CodeMirror.registerHelper(type, name, value);
	    helpers[type]._global.push({pred: predicate, val: value});
	  };

	  // MODE STATE HANDLING

	  // Utility functions for working with state. Exported because nested
	  // modes need to do this for their inner modes.

	  var copyState = CodeMirror.copyState = function(mode, state) {
	    if (state === true) return state;
	    if (mode.copyState) return mode.copyState(state);
	    var nstate = {};
	    for (var n in state) {
	      var val = state[n];
	      if (val instanceof Array) val = val.concat([]);
	      nstate[n] = val;
	    }
	    return nstate;
	  };

	  var startState = CodeMirror.startState = function(mode, a1, a2) {
	    return mode.startState ? mode.startState(a1, a2) : true;
	  };

	  // Given a mode and a state (for that mode), find the inner mode and
	  // state at the position that the state refers to.
	  CodeMirror.innerMode = function(mode, state) {
	    while (mode.innerMode) {
	      var info = mode.innerMode(state);
	      if (!info || info.mode == mode) break;
	      state = info.state;
	      mode = info.mode;
	    }
	    return info || {mode: mode, state: state};
	  };

	  // STANDARD COMMANDS

	  // Commands are parameter-less actions that can be performed on an
	  // editor, mostly used for keybindings.
	  var commands = CodeMirror.commands = {
	    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
	    singleSelection: function(cm) {
	      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
	    },
	    killLine: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        if (range.empty()) {
	          var len = getLine(cm.doc, range.head.line).text.length;
	          if (range.head.ch == len && range.head.line < cm.lastLine())
	            return {from: range.head, to: Pos(range.head.line + 1, 0)};
	          else
	            return {from: range.head, to: Pos(range.head.line, len)};
	        } else {
	          return {from: range.from(), to: range.to()};
	        }
	      });
	    },
	    deleteLine: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        return {from: Pos(range.from().line, 0),
	                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
	      });
	    },
	    delLineLeft: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        return {from: Pos(range.from().line, 0), to: range.from()};
	      });
	    },
	    delWrappedLineLeft: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
	        return {from: leftPos, to: range.from()};
	      });
	    },
	    delWrappedLineRight: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
	        return {from: range.from(), to: rightPos };
	      });
	    },
	    undo: function(cm) {cm.undo();},
	    redo: function(cm) {cm.redo();},
	    undoSelection: function(cm) {cm.undoSelection();},
	    redoSelection: function(cm) {cm.redoSelection();},
	    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
	    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
	    goLineStart: function(cm) {
	      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
	                            {origin: "+move", bias: 1});
	    },
	    goLineStartSmart: function(cm) {
	      cm.extendSelectionsBy(function(range) {
	        return lineStartSmart(cm, range.head);
	      }, {origin: "+move", bias: 1});
	    },
	    goLineEnd: function(cm) {
	      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
	                            {origin: "+move", bias: -1});
	    },
	    goLineRight: function(cm) {
	      cm.extendSelectionsBy(function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
	      }, sel_move);
	    },
	    goLineLeft: function(cm) {
	      cm.extendSelectionsBy(function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        return cm.coordsChar({left: 0, top: top}, "div");
	      }, sel_move);
	    },
	    goLineLeftSmart: function(cm) {
	      cm.extendSelectionsBy(function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        var pos = cm.coordsChar({left: 0, top: top}, "div");
	        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
	        return pos;
	      }, sel_move);
	    },
	    goLineUp: function(cm) {cm.moveV(-1, "line");},
	    goLineDown: function(cm) {cm.moveV(1, "line");},
	    goPageUp: function(cm) {cm.moveV(-1, "page");},
	    goPageDown: function(cm) {cm.moveV(1, "page");},
	    goCharLeft: function(cm) {cm.moveH(-1, "char");},
	    goCharRight: function(cm) {cm.moveH(1, "char");},
	    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
	    goColumnRight: function(cm) {cm.moveH(1, "column");},
	    goWordLeft: function(cm) {cm.moveH(-1, "word");},
	    goGroupRight: function(cm) {cm.moveH(1, "group");},
	    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
	    goWordRight: function(cm) {cm.moveH(1, "word");},
	    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
	    delCharAfter: function(cm) {cm.deleteH(1, "char");},
	    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
	    delWordAfter: function(cm) {cm.deleteH(1, "word");},
	    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
	    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
	    indentAuto: function(cm) {cm.indentSelection("smart");},
	    indentMore: function(cm) {cm.indentSelection("add");},
	    indentLess: function(cm) {cm.indentSelection("subtract");},
	    insertTab: function(cm) {cm.replaceSelection("\t");},
	    insertSoftTab: function(cm) {
	      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
	      for (var i = 0; i < ranges.length; i++) {
	        var pos = ranges[i].from();
	        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
	        spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
	      }
	      cm.replaceSelections(spaces);
	    },
	    defaultTab: function(cm) {
	      if (cm.somethingSelected()) cm.indentSelection("add");
	      else cm.execCommand("insertTab");
	    },
	    transposeChars: function(cm) {
	      runInOp(cm, function() {
	        var ranges = cm.listSelections(), newSel = [];
	        for (var i = 0; i < ranges.length; i++) {
	          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
	          if (line) {
	            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
	            if (cur.ch > 0) {
	              cur = new Pos(cur.line, cur.ch + 1);
	              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
	                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
	            } else if (cur.line > cm.doc.first) {
	              var prev = getLine(cm.doc, cur.line - 1).text;
	              if (prev)
	                cm.replaceRange(line.charAt(0) + "\n" + prev.charAt(prev.length - 1),
	                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
	            }
	          }
	          newSel.push(new Range(cur, cur));
	        }
	        cm.setSelections(newSel);
	      });
	    },
	    newlineAndIndent: function(cm) {
	      runInOp(cm, function() {
	        var len = cm.listSelections().length;
	        for (var i = 0; i < len; i++) {
	          var range = cm.listSelections()[i];
	          cm.replaceRange("\n", range.anchor, range.head, "+input");
	          cm.indentLine(range.from().line + 1, null, true);
	          ensureCursorVisible(cm);
	        }
	      });
	    },
	    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
	  };


	  // STANDARD KEYMAPS

	  var keyMap = CodeMirror.keyMap = {};

	  keyMap.basic = {
	    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
	    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
	    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
	    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
	    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
	    "Esc": "singleSelection"
	  };
	  // Note that the save and find-related commands aren't defined by
	  // default. User code or addons can define them. Unknown commands
	  // are simply ignored.
	  keyMap.pcDefault = {
	    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
	    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
	    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
	    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
	    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
	    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
	    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
	    fallthrough: "basic"
	  };
	  // Very basic readline/emacs-style bindings, which are standard on Mac.
	  keyMap.emacsy = {
	    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
	    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
	    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
	    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
	  };
	  keyMap.macDefault = {
	    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
	    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
	    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
	    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
	    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
	    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
	    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
	    fallthrough: ["basic", "emacsy"]
	  };
	  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

	  // KEYMAP DISPATCH

	  function normalizeKeyName(name) {
	    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
	    var alt, ctrl, shift, cmd;
	    for (var i = 0; i < parts.length - 1; i++) {
	      var mod = parts[i];
	      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
	      else if (/^a(lt)?$/i.test(mod)) alt = true;
	      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
	      else if (/^s(hift)$/i.test(mod)) shift = true;
	      else throw new Error("Unrecognized modifier name: " + mod);
	    }
	    if (alt) name = "Alt-" + name;
	    if (ctrl) name = "Ctrl-" + name;
	    if (cmd) name = "Cmd-" + name;
	    if (shift) name = "Shift-" + name;
	    return name;
	  }

	  // This is a kludge to keep keymaps mostly working as raw objects
	  // (backwards compatibility) while at the same time support features
	  // like normalization and multi-stroke key bindings. It compiles a
	  // new normalized keymap, and then updates the old object to reflect
	  // this.
	  CodeMirror.normalizeKeyMap = function(keymap) {
	    var copy = {};
	    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
	      var value = keymap[keyname];
	      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
	      if (value == "...") { delete keymap[keyname]; continue; }

	      var keys = map(keyname.split(" "), normalizeKeyName);
	      for (var i = 0; i < keys.length; i++) {
	        var val, name;
	        if (i == keys.length - 1) {
	          name = keyname;
	          val = value;
	        } else {
	          name = keys.slice(0, i + 1).join(" ");
	          val = "...";
	        }
	        var prev = copy[name];
	        if (!prev) copy[name] = val;
	        else if (prev != val) throw new Error("Inconsistent bindings for " + name);
	      }
	      delete keymap[keyname];
	    }
	    for (var prop in copy) keymap[prop] = copy[prop];
	    return keymap;
	  };

	  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
	    map = getKeyMap(map);
	    var found = map.call ? map.call(key, context) : map[key];
	    if (found === false) return "nothing";
	    if (found === "...") return "multi";
	    if (found != null && handle(found)) return "handled";

	    if (map.fallthrough) {
	      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
	        return lookupKey(key, map.fallthrough, handle, context);
	      for (var i = 0; i < map.fallthrough.length; i++) {
	        var result = lookupKey(key, map.fallthrough[i], handle, context);
	        if (result) return result;
	      }
	    }
	  };

	  // Modifier key presses don't count as 'real' key presses for the
	  // purpose of keymap fallthrough.
	  var isModifierKey = CodeMirror.isModifierKey = function(value) {
	    var name = typeof value == "string" ? value : keyNames[value.keyCode];
	    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
	  };

	  // Look up the name of a key as indicated by an event object.
	  var keyName = CodeMirror.keyName = function(event, noShift) {
	    if (presto && event.keyCode == 34 && event["char"]) return false;
	    var base = keyNames[event.keyCode], name = base;
	    if (name == null || event.altGraphKey) return false;
	    if (event.altKey && base != "Alt") name = "Alt-" + name;
	    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") name = "Ctrl-" + name;
	    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") name = "Cmd-" + name;
	    if (!noShift && event.shiftKey && base != "Shift") name = "Shift-" + name;
	    return name;
	  };

	  function getKeyMap(val) {
	    return typeof val == "string" ? keyMap[val] : val;
	  }

	  // FROMTEXTAREA

	  CodeMirror.fromTextArea = function(textarea, options) {
	    options = options ? copyObj(options) : {};
	    options.value = textarea.value;
	    if (!options.tabindex && textarea.tabindex)
	      options.tabindex = textarea.tabindex;
	    if (!options.placeholder && textarea.placeholder)
	      options.placeholder = textarea.placeholder;
	    // Set autofocus to true if this textarea is focused, or if it has
	    // autofocus and no other element is focused.
	    if (options.autofocus == null) {
	      var hasFocus = activeElt();
	      options.autofocus = hasFocus == textarea ||
	        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
	    }

	    function save() {textarea.value = cm.getValue();}
	    if (textarea.form) {
	      on(textarea.form, "submit", save);
	      // Deplorable hack to make the submit method do the right thing.
	      if (!options.leaveSubmitMethodAlone) {
	        var form = textarea.form, realSubmit = form.submit;
	        try {
	          var wrappedSubmit = form.submit = function() {
	            save();
	            form.submit = realSubmit;
	            form.submit();
	            form.submit = wrappedSubmit;
	          };
	        } catch(e) {}
	      }
	    }

	    options.finishInit = function(cm) {
	      cm.save = save;
	      cm.getTextArea = function() { return textarea; };
	      cm.toTextArea = function() {
	        cm.toTextArea = isNaN; // Prevent this from being ran twice
	        save();
	        textarea.parentNode.removeChild(cm.getWrapperElement());
	        textarea.style.display = "";
	        if (textarea.form) {
	          off(textarea.form, "submit", save);
	          if (typeof textarea.form.submit == "function")
	            textarea.form.submit = realSubmit;
	        }
	      };
	    };

	    textarea.style.display = "none";
	    var cm = CodeMirror(function(node) {
	      textarea.parentNode.insertBefore(node, textarea.nextSibling);
	    }, options);
	    return cm;
	  };

	  // STRING STREAM

	  // Fed to the mode parsers, provides helper functions to make
	  // parsers more succinct.

	  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
	    this.pos = this.start = 0;
	    this.string = string;
	    this.tabSize = tabSize || 8;
	    this.lastColumnPos = this.lastColumnValue = 0;
	    this.lineStart = 0;
	  };

	  StringStream.prototype = {
	    eol: function() {return this.pos >= this.string.length;},
	    sol: function() {return this.pos == this.lineStart;},
	    peek: function() {return this.string.charAt(this.pos) || undefined;},
	    next: function() {
	      if (this.pos < this.string.length)
	        return this.string.charAt(this.pos++);
	    },
	    eat: function(match) {
	      var ch = this.string.charAt(this.pos);
	      if (typeof match == "string") var ok = ch == match;
	      else var ok = ch && (match.test ? match.test(ch) : match(ch));
	      if (ok) {++this.pos; return ch;}
	    },
	    eatWhile: function(match) {
	      var start = this.pos;
	      while (this.eat(match)){}
	      return this.pos > start;
	    },
	    eatSpace: function() {
	      var start = this.pos;
	      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
	      return this.pos > start;
	    },
	    skipToEnd: function() {this.pos = this.string.length;},
	    skipTo: function(ch) {
	      var found = this.string.indexOf(ch, this.pos);
	      if (found > -1) {this.pos = found; return true;}
	    },
	    backUp: function(n) {this.pos -= n;},
	    column: function() {
	      if (this.lastColumnPos < this.start) {
	        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
	        this.lastColumnPos = this.start;
	      }
	      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
	    },
	    indentation: function() {
	      return countColumn(this.string, null, this.tabSize) -
	        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
	    },
	    match: function(pattern, consume, caseInsensitive) {
	      if (typeof pattern == "string") {
	        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
	        var substr = this.string.substr(this.pos, pattern.length);
	        if (cased(substr) == cased(pattern)) {
	          if (consume !== false) this.pos += pattern.length;
	          return true;
	        }
	      } else {
	        var match = this.string.slice(this.pos).match(pattern);
	        if (match && match.index > 0) return null;
	        if (match && consume !== false) this.pos += match[0].length;
	        return match;
	      }
	    },
	    current: function(){return this.string.slice(this.start, this.pos);},
	    hideFirstChars: function(n, inner) {
	      this.lineStart += n;
	      try { return inner(); }
	      finally { this.lineStart -= n; }
	    }
	  };

	  // TEXTMARKERS

	  // Created with markText and setBookmark methods. A TextMarker is a
	  // handle that can be used to clear or find a marked position in the
	  // document. Line objects hold arrays (markedSpans) containing
	  // {from, to, marker} object pointing to such marker objects, and
	  // indicating that such a marker is present on that line. Multiple
	  // lines may point to the same marker when it spans across lines.
	  // The spans will have null for their from/to properties when the
	  // marker continues beyond the start/end of the line. Markers have
	  // links back to the lines they currently touch.

	  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
	    this.lines = [];
	    this.type = type;
	    this.doc = doc;
	  };
	  eventMixin(TextMarker);

	  // Clear the marker.
	  TextMarker.prototype.clear = function() {
	    if (this.explicitlyCleared) return;
	    var cm = this.doc.cm, withOp = cm && !cm.curOp;
	    if (withOp) startOperation(cm);
	    if (hasHandler(this, "clear")) {
	      var found = this.find();
	      if (found) signalLater(this, "clear", found.from, found.to);
	    }
	    var min = null, max = null;
	    for (var i = 0; i < this.lines.length; ++i) {
	      var line = this.lines[i];
	      var span = getMarkedSpanFor(line.markedSpans, this);
	      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
	      else if (cm) {
	        if (span.to != null) max = lineNo(line);
	        if (span.from != null) min = lineNo(line);
	      }
	      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
	      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
	        updateLineHeight(line, textHeight(cm.display));
	    }
	    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
	      var visual = visualLine(this.lines[i]), len = lineLength(visual);
	      if (len > cm.display.maxLineLength) {
	        cm.display.maxLine = visual;
	        cm.display.maxLineLength = len;
	        cm.display.maxLineChanged = true;
	      }
	    }

	    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
	    this.lines.length = 0;
	    this.explicitlyCleared = true;
	    if (this.atomic && this.doc.cantEdit) {
	      this.doc.cantEdit = false;
	      if (cm) reCheckSelection(cm.doc);
	    }
	    if (cm) signalLater(cm, "markerCleared", cm, this);
	    if (withOp) endOperation(cm);
	    if (this.parent) this.parent.clear();
	  };

	  // Find the position of the marker in the document. Returns a {from,
	  // to} object by default. Side can be passed to get a specific side
	  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
	  // Pos objects returned contain a line object, rather than a line
	  // number (used to prevent looking up the same line twice).
	  TextMarker.prototype.find = function(side, lineObj) {
	    if (side == null && this.type == "bookmark") side = 1;
	    var from, to;
	    for (var i = 0; i < this.lines.length; ++i) {
	      var line = this.lines[i];
	      var span = getMarkedSpanFor(line.markedSpans, this);
	      if (span.from != null) {
	        from = Pos(lineObj ? line : lineNo(line), span.from);
	        if (side == -1) return from;
	      }
	      if (span.to != null) {
	        to = Pos(lineObj ? line : lineNo(line), span.to);
	        if (side == 1) return to;
	      }
	    }
	    return from && {from: from, to: to};
	  };

	  // Signals that the marker's widget changed, and surrounding layout
	  // should be recomputed.
	  TextMarker.prototype.changed = function() {
	    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
	    if (!pos || !cm) return;
	    runInOp(cm, function() {
	      var line = pos.line, lineN = lineNo(pos.line);
	      var view = findViewForLine(cm, lineN);
	      if (view) {
	        clearLineMeasurementCacheFor(view);
	        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
	      }
	      cm.curOp.updateMaxLine = true;
	      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
	        var oldHeight = widget.height;
	        widget.height = null;
	        var dHeight = widgetHeight(widget) - oldHeight;
	        if (dHeight)
	          updateLineHeight(line, line.height + dHeight);
	      }
	    });
	  };

	  TextMarker.prototype.attachLine = function(line) {
	    if (!this.lines.length && this.doc.cm) {
	      var op = this.doc.cm.curOp;
	      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
	        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
	    }
	    this.lines.push(line);
	  };
	  TextMarker.prototype.detachLine = function(line) {
	    this.lines.splice(indexOf(this.lines, line), 1);
	    if (!this.lines.length && this.doc.cm) {
	      var op = this.doc.cm.curOp;
	      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
	    }
	  };

	  // Collapsed markers have unique ids, in order to be able to order
	  // them, which is needed for uniquely determining an outer marker
	  // when they overlap (they may nest, but not partially overlap).
	  var nextMarkerId = 0;

	  // Create a marker, wire it up to the right lines, and
	  function markText(doc, from, to, options, type) {
	    // Shared markers (across linked documents) are handled separately
	    // (markTextShared will call out to this again, once per
	    // document).
	    if (options && options.shared) return markTextShared(doc, from, to, options, type);
	    // Ensure we are in an operation.
	    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

	    var marker = new TextMarker(doc, type), diff = cmp(from, to);
	    if (options) copyObj(options, marker, false);
	    // Don't connect empty markers unless clearWhenEmpty is false
	    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
	      return marker;
	    if (marker.replacedWith) {
	      // Showing up as a widget implies collapsed (widget replaces text)
	      marker.collapsed = true;
	      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
	      if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");
	      if (options.insertLeft) marker.widgetNode.insertLeft = true;
	    }
	    if (marker.collapsed) {
	      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
	          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
	        throw new Error("Inserting collapsed marker partially overlapping an existing one");
	      sawCollapsedSpans = true;
	    }

	    if (marker.addToHistory)
	      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

	    var curLine = from.line, cm = doc.cm, updateMaxLine;
	    doc.iter(curLine, to.line + 1, function(line) {
	      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
	        updateMaxLine = true;
	      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
	      addMarkedSpan(line, new MarkedSpan(marker,
	                                         curLine == from.line ? from.ch : null,
	                                         curLine == to.line ? to.ch : null));
	      ++curLine;
	    });
	    // lineIsHidden depends on the presence of the spans, so needs a second pass
	    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
	      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
	    });

	    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

	    if (marker.readOnly) {
	      sawReadOnlySpans = true;
	      if (doc.history.done.length || doc.history.undone.length)
	        doc.clearHistory();
	    }
	    if (marker.collapsed) {
	      marker.id = ++nextMarkerId;
	      marker.atomic = true;
	    }
	    if (cm) {
	      // Sync editor state
	      if (updateMaxLine) cm.curOp.updateMaxLine = true;
	      if (marker.collapsed)
	        regChange(cm, from.line, to.line + 1);
	      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
	        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
	      if (marker.atomic) reCheckSelection(cm.doc);
	      signalLater(cm, "markerAdded", cm, marker);
	    }
	    return marker;
	  }

	  // SHARED TEXTMARKERS

	  // A shared marker spans multiple linked documents. It is
	  // implemented as a meta-marker-object controlling multiple normal
	  // markers.
	  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
	    this.markers = markers;
	    this.primary = primary;
	    for (var i = 0; i < markers.length; ++i)
	      markers[i].parent = this;
	  };
	  eventMixin(SharedTextMarker);

	  SharedTextMarker.prototype.clear = function() {
	    if (this.explicitlyCleared) return;
	    this.explicitlyCleared = true;
	    for (var i = 0; i < this.markers.length; ++i)
	      this.markers[i].clear();
	    signalLater(this, "clear");
	  };
	  SharedTextMarker.prototype.find = function(side, lineObj) {
	    return this.primary.find(side, lineObj);
	  };

	  function markTextShared(doc, from, to, options, type) {
	    options = copyObj(options);
	    options.shared = false;
	    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
	    var widget = options.widgetNode;
	    linkedDocs(doc, function(doc) {
	      if (widget) options.widgetNode = widget.cloneNode(true);
	      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
	      for (var i = 0; i < doc.linked.length; ++i)
	        if (doc.linked[i].isParent) return;
	      primary = lst(markers);
	    });
	    return new SharedTextMarker(markers, primary);
	  }

	  function findSharedMarkers(doc) {
	    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
	                         function(m) { return m.parent; });
	  }

	  function copySharedMarkers(doc, markers) {
	    for (var i = 0; i < markers.length; i++) {
	      var marker = markers[i], pos = marker.find();
	      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
	      if (cmp(mFrom, mTo)) {
	        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
	        marker.markers.push(subMark);
	        subMark.parent = marker;
	      }
	    }
	  }

	  function detachSharedMarkers(markers) {
	    for (var i = 0; i < markers.length; i++) {
	      var marker = markers[i], linked = [marker.primary.doc];;
	      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
	      for (var j = 0; j < marker.markers.length; j++) {
	        var subMarker = marker.markers[j];
	        if (indexOf(linked, subMarker.doc) == -1) {
	          subMarker.parent = null;
	          marker.markers.splice(j--, 1);
	        }
	      }
	    }
	  }

	  // TEXTMARKER SPANS

	  function MarkedSpan(marker, from, to) {
	    this.marker = marker;
	    this.from = from; this.to = to;
	  }

	  // Search an array of spans for a span matching the given marker.
	  function getMarkedSpanFor(spans, marker) {
	    if (spans) for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if (span.marker == marker) return span;
	    }
	  }
	  // Remove a span from an array, returning undefined if no spans are
	  // left (we don't store arrays for lines without spans).
	  function removeMarkedSpan(spans, span) {
	    for (var r, i = 0; i < spans.length; ++i)
	      if (spans[i] != span) (r || (r = [])).push(spans[i]);
	    return r;
	  }
	  // Add a span to a line.
	  function addMarkedSpan(line, span) {
	    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
	    span.marker.attachLine(line);
	  }

	  // Used for the algorithm that adjusts markers for a change in the
	  // document. These functions cut an array of spans at a given
	  // character position, returning an array of remaining chunks (or
	  // undefined if nothing remains).
	  function markedSpansBefore(old, startCh, isInsert) {
	    if (old) for (var i = 0, nw; i < old.length; ++i) {
	      var span = old[i], marker = span.marker;
	      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
	      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
	        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
	        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
	      }
	    }
	    return nw;
	  }
	  function markedSpansAfter(old, endCh, isInsert) {
	    if (old) for (var i = 0, nw; i < old.length; ++i) {
	      var span = old[i], marker = span.marker;
	      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
	      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
	        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
	        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
	                                              span.to == null ? null : span.to - endCh));
	      }
	    }
	    return nw;
	  }

	  // Given a change object, compute the new set of marker spans that
	  // cover the line in which the change took place. Removes spans
	  // entirely within the change, reconnects spans belonging to the
	  // same marker that appear on both sides of the change, and cuts off
	  // spans partially within the change. Returns an array of span
	  // arrays with one element for each line in (after) the change.
	  function stretchSpansOverChange(doc, change) {
	    if (change.full) return null;
	    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
	    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
	    if (!oldFirst && !oldLast) return null;

	    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
	    // Get the spans that 'stick out' on both sides
	    var first = markedSpansBefore(oldFirst, startCh, isInsert);
	    var last = markedSpansAfter(oldLast, endCh, isInsert);

	    // Next, merge those two ends
	    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
	    if (first) {
	      // Fix up .to properties of first
	      for (var i = 0; i < first.length; ++i) {
	        var span = first[i];
	        if (span.to == null) {
	          var found = getMarkedSpanFor(last, span.marker);
	          if (!found) span.to = startCh;
	          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
	        }
	      }
	    }
	    if (last) {
	      // Fix up .from in last (or move them into first in case of sameLine)
	      for (var i = 0; i < last.length; ++i) {
	        var span = last[i];
	        if (span.to != null) span.to += offset;
	        if (span.from == null) {
	          var found = getMarkedSpanFor(first, span.marker);
	          if (!found) {
	            span.from = offset;
	            if (sameLine) (first || (first = [])).push(span);
	          }
	        } else {
	          span.from += offset;
	          if (sameLine) (first || (first = [])).push(span);
	        }
	      }
	    }
	    // Make sure we didn't create any zero-length spans
	    if (first) first = clearEmptySpans(first);
	    if (last && last != first) last = clearEmptySpans(last);

	    var newMarkers = [first];
	    if (!sameLine) {
	      // Fill gap with whole-line-spans
	      var gap = change.text.length - 2, gapMarkers;
	      if (gap > 0 && first)
	        for (var i = 0; i < first.length; ++i)
	          if (first[i].to == null)
	            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
	      for (var i = 0; i < gap; ++i)
	        newMarkers.push(gapMarkers);
	      newMarkers.push(last);
	    }
	    return newMarkers;
	  }

	  // Remove spans that are empty and don't have a clearWhenEmpty
	  // option of false.
	  function clearEmptySpans(spans) {
	    for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
	        spans.splice(i--, 1);
	    }
	    if (!spans.length) return null;
	    return spans;
	  }

	  // Used for un/re-doing changes from the history. Combines the
	  // result of computing the existing spans with the set of spans that
	  // existed in the history (so that deleting around a span and then
	  // undoing brings back the span).
	  function mergeOldSpans(doc, change) {
	    var old = getOldSpans(doc, change);
	    var stretched = stretchSpansOverChange(doc, change);
	    if (!old) return stretched;
	    if (!stretched) return old;

	    for (var i = 0; i < old.length; ++i) {
	      var oldCur = old[i], stretchCur = stretched[i];
	      if (oldCur && stretchCur) {
	        spans: for (var j = 0; j < stretchCur.length; ++j) {
	          var span = stretchCur[j];
	          for (var k = 0; k < oldCur.length; ++k)
	            if (oldCur[k].marker == span.marker) continue spans;
	          oldCur.push(span);
	        }
	      } else if (stretchCur) {
	        old[i] = stretchCur;
	      }
	    }
	    return old;
	  }

	  // Used to 'clip' out readOnly ranges when making a change.
	  function removeReadOnlyRanges(doc, from, to) {
	    var markers = null;
	    doc.iter(from.line, to.line + 1, function(line) {
	      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
	        var mark = line.markedSpans[i].marker;
	        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
	          (markers || (markers = [])).push(mark);
	      }
	    });
	    if (!markers) return null;
	    var parts = [{from: from, to: to}];
	    for (var i = 0; i < markers.length; ++i) {
	      var mk = markers[i], m = mk.find(0);
	      for (var j = 0; j < parts.length; ++j) {
	        var p = parts[j];
	        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
	        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
	        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
	          newParts.push({from: p.from, to: m.from});
	        if (dto > 0 || !mk.inclusiveRight && !dto)
	          newParts.push({from: m.to, to: p.to});
	        parts.splice.apply(parts, newParts);
	        j += newParts.length - 1;
	      }
	    }
	    return parts;
	  }

	  // Connect or disconnect spans from a line.
	  function detachMarkedSpans(line) {
	    var spans = line.markedSpans;
	    if (!spans) return;
	    for (var i = 0; i < spans.length; ++i)
	      spans[i].marker.detachLine(line);
	    line.markedSpans = null;
	  }
	  function attachMarkedSpans(line, spans) {
	    if (!spans) return;
	    for (var i = 0; i < spans.length; ++i)
	      spans[i].marker.attachLine(line);
	    line.markedSpans = spans;
	  }

	  // Helpers used when computing which overlapping collapsed span
	  // counts as the larger one.
	  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
	  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

	  // Returns a number indicating which of two overlapping collapsed
	  // spans is larger (and thus includes the other). Falls back to
	  // comparing ids when the spans cover exactly the same range.
	  function compareCollapsedMarkers(a, b) {
	    var lenDiff = a.lines.length - b.lines.length;
	    if (lenDiff != 0) return lenDiff;
	    var aPos = a.find(), bPos = b.find();
	    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
	    if (fromCmp) return -fromCmp;
	    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
	    if (toCmp) return toCmp;
	    return b.id - a.id;
	  }

	  // Find out whether a line ends or starts in a collapsed span. If
	  // so, return the marker for that span.
	  function collapsedSpanAtSide(line, start) {
	    var sps = sawCollapsedSpans && line.markedSpans, found;
	    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
	      sp = sps[i];
	      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
	          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
	        found = sp.marker;
	    }
	    return found;
	  }
	  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
	  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

	  // Test whether there exists a collapsed span that partially
	  // overlaps (covers the start or end, but not both) of a new span.
	  // Such overlap is not allowed.
	  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
	    var line = getLine(doc, lineNo);
	    var sps = sawCollapsedSpans && line.markedSpans;
	    if (sps) for (var i = 0; i < sps.length; ++i) {
	      var sp = sps[i];
	      if (!sp.marker.collapsed) continue;
	      var found = sp.marker.find(0);
	      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
	      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
	      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
	      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||
	          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))
	        return true;
	    }
	  }

	  // A visual line is a line as drawn on the screen. Folding, for
	  // example, can cause multiple logical lines to appear on the same
	  // visual line. This finds the start of the visual line that the
	  // given line is part of (usually that is the line itself).
	  function visualLine(line) {
	    var merged;
	    while (merged = collapsedSpanAtStart(line))
	      line = merged.find(-1, true).line;
	    return line;
	  }

	  // Returns an array of logical lines that continue the visual line
	  // started by the argument, or undefined if there are no such lines.
	  function visualLineContinued(line) {
	    var merged, lines;
	    while (merged = collapsedSpanAtEnd(line)) {
	      line = merged.find(1, true).line;
	      (lines || (lines = [])).push(line);
	    }
	    return lines;
	  }

	  // Get the line number of the start of the visual line that the
	  // given line number is part of.
	  function visualLineNo(doc, lineN) {
	    var line = getLine(doc, lineN), vis = visualLine(line);
	    if (line == vis) return lineN;
	    return lineNo(vis);
	  }
	  // Get the line number of the start of the next visual line after
	  // the given line.
	  function visualLineEndNo(doc, lineN) {
	    if (lineN > doc.lastLine()) return lineN;
	    var line = getLine(doc, lineN), merged;
	    if (!lineIsHidden(doc, line)) return lineN;
	    while (merged = collapsedSpanAtEnd(line))
	      line = merged.find(1, true).line;
	    return lineNo(line) + 1;
	  }

	  // Compute whether a line is hidden. Lines count as hidden when they
	  // are part of a visual line that starts with another line, or when
	  // they are entirely covered by collapsed, non-widget span.
	  function lineIsHidden(doc, line) {
	    var sps = sawCollapsedSpans && line.markedSpans;
	    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
	      sp = sps[i];
	      if (!sp.marker.collapsed) continue;
	      if (sp.from == null) return true;
	      if (sp.marker.widgetNode) continue;
	      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
	        return true;
	    }
	  }
	  function lineIsHiddenInner(doc, line, span) {
	    if (span.to == null) {
	      var end = span.marker.find(1, true);
	      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
	    }
	    if (span.marker.inclusiveRight && span.to == line.text.length)
	      return true;
	    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
	      sp = line.markedSpans[i];
	      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
	          (sp.to == null || sp.to != span.from) &&
	          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
	          lineIsHiddenInner(doc, line, sp)) return true;
	    }
	  }

	  // LINE WIDGETS

	  // Line widgets are block elements displayed above or below a line.

	  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {
	    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
	      this[opt] = options[opt];
	    this.cm = cm;
	    this.node = node;
	  };
	  eventMixin(LineWidget);

	  function adjustScrollWhenAboveVisible(cm, line, diff) {
	    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
	      addToScrollPos(cm, null, diff);
	  }

	  LineWidget.prototype.clear = function() {
	    var cm = this.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
	    if (no == null || !ws) return;
	    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
	    if (!ws.length) line.widgets = null;
	    var height = widgetHeight(this);
	    runInOp(cm, function() {
	      adjustScrollWhenAboveVisible(cm, line, -height);
	      regLineChange(cm, no, "widget");
	      updateLineHeight(line, Math.max(0, line.height - height));
	    });
	  };
	  LineWidget.prototype.changed = function() {
	    var oldH = this.height, cm = this.cm, line = this.line;
	    this.height = null;
	    var diff = widgetHeight(this) - oldH;
	    if (!diff) return;
	    runInOp(cm, function() {
	      cm.curOp.forceUpdate = true;
	      adjustScrollWhenAboveVisible(cm, line, diff);
	      updateLineHeight(line, line.height + diff);
	    });
	  };

	  function widgetHeight(widget) {
	    if (widget.height != null) return widget.height;
	    if (!contains(document.body, widget.node)) {
	      var parentStyle = "position: relative;";
	      if (widget.coverGutter)
	        parentStyle += "margin-left: -" + widget.cm.display.gutters.offsetWidth + "px;";
	      if (widget.noHScroll)
	        parentStyle += "width: " + widget.cm.display.wrapper.clientWidth + "px;";
	      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, parentStyle));
	    }
	    return widget.height = widget.node.offsetHeight;
	  }

	  function addLineWidget(cm, handle, node, options) {
	    var widget = new LineWidget(cm, node, options);
	    if (widget.noHScroll) cm.display.alignWidgets = true;
	    changeLine(cm.doc, handle, "widget", function(line) {
	      var widgets = line.widgets || (line.widgets = []);
	      if (widget.insertAt == null) widgets.push(widget);
	      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
	      widget.line = line;
	      if (!lineIsHidden(cm.doc, line)) {
	        var aboveVisible = heightAtLine(line) < cm.doc.scrollTop;
	        updateLineHeight(line, line.height + widgetHeight(widget));
	        if (aboveVisible) addToScrollPos(cm, null, widget.height);
	        cm.curOp.forceUpdate = true;
	      }
	      return true;
	    });
	    return widget;
	  }

	  // LINE DATA STRUCTURE

	  // Line objects. These hold state related to a line, including
	  // highlighting info (the styles array).
	  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
	    this.text = text;
	    attachMarkedSpans(this, markedSpans);
	    this.height = estimateHeight ? estimateHeight(this) : 1;
	  };
	  eventMixin(Line);
	  Line.prototype.lineNo = function() { return lineNo(this); };

	  // Change the content (text, markers) of a line. Automatically
	  // invalidates cached information and tries to re-estimate the
	  // line's height.
	  function updateLine(line, text, markedSpans, estimateHeight) {
	    line.text = text;
	    if (line.stateAfter) line.stateAfter = null;
	    if (line.styles) line.styles = null;
	    if (line.order != null) line.order = null;
	    detachMarkedSpans(line);
	    attachMarkedSpans(line, markedSpans);
	    var estHeight = estimateHeight ? estimateHeight(line) : 1;
	    if (estHeight != line.height) updateLineHeight(line, estHeight);
	  }

	  // Detach a line from the document tree and its markers.
	  function cleanUpLine(line) {
	    line.parent = null;
	    detachMarkedSpans(line);
	  }

	  function extractLineClasses(type, output) {
	    if (type) for (;;) {
	      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
	      if (!lineClass) break;
	      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
	      var prop = lineClass[1] ? "bgClass" : "textClass";
	      if (output[prop] == null)
	        output[prop] = lineClass[2];
	      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
	        output[prop] += " " + lineClass[2];
	    }
	    return type;
	  }

	  function callBlankLine(mode, state) {
	    if (mode.blankLine) return mode.blankLine(state);
	    if (!mode.innerMode) return;
	    var inner = CodeMirror.innerMode(mode, state);
	    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
	  }

	  function readToken(mode, stream, state, inner) {
	    for (var i = 0; i < 10; i++) {
	      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;
	      var style = mode.token(stream, state);
	      if (stream.pos > stream.start) return style;
	    }
	    throw new Error("Mode " + mode.name + " failed to advance stream.");
	  }

	  // Utility for getTokenAt and getLineTokens
	  function takeToken(cm, pos, precise, asArray) {
	    function getObj(copy) {
	      return {start: stream.start, end: stream.pos,
	              string: stream.current(),
	              type: style || null,
	              state: copy ? copyState(doc.mode, state) : state};
	    }

	    var doc = cm.doc, mode = doc.mode, style;
	    pos = clipPos(doc, pos);
	    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
	    var stream = new StringStream(line.text, cm.options.tabSize), tokens;
	    if (asArray) tokens = [];
	    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
	      stream.start = stream.pos;
	      style = readToken(mode, stream, state);
	      if (asArray) tokens.push(getObj(true));
	    }
	    return asArray ? tokens : getObj();
	  }

	  // Run the given mode's parser over a line, calling f for each token.
	  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
	    var flattenSpans = mode.flattenSpans;
	    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
	    var curStart = 0, curStyle = null;
	    var stream = new StringStream(text, cm.options.tabSize), style;
	    var inner = cm.options.addModeClass && [null];
	    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
	    while (!stream.eol()) {
	      if (stream.pos > cm.options.maxHighlightLength) {
	        flattenSpans = false;
	        if (forceToEnd) processLine(cm, text, state, stream.pos);
	        stream.pos = text.length;
	        style = null;
	      } else {
	        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
	      }
	      if (inner) {
	        var mName = inner[0].name;
	        if (mName) style = "m-" + (style ? mName + " " + style : mName);
	      }
	      if (!flattenSpans || curStyle != style) {
	        while (curStart < stream.start) {
	          curStart = Math.min(stream.start, curStart + 50000);
	          f(curStart, curStyle);
	        }
	        curStyle = style;
	      }
	      stream.start = stream.pos;
	    }
	    while (curStart < stream.pos) {
	      // Webkit seems to refuse to render text nodes longer than 57444 characters
	      var pos = Math.min(stream.pos, curStart + 50000);
	      f(pos, curStyle);
	      curStart = pos;
	    }
	  }

	  // Compute a style array (an array starting with a mode generation
	  // -- for invalidation -- followed by pairs of end positions and
	  // style strings), which is used to highlight the tokens on the
	  // line.
	  function highlightLine(cm, line, state, forceToEnd) {
	    // A styles array always starts with a number identifying the
	    // mode/overlays that it is based on (for easy invalidation).
	    var st = [cm.state.modeGen], lineClasses = {};
	    // Compute the base array of styles
	    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
	      st.push(end, style);
	    }, lineClasses, forceToEnd);

	    // Run overlays, adjust style array.
	    for (var o = 0; o < cm.state.overlays.length; ++o) {
	      var overlay = cm.state.overlays[o], i = 1, at = 0;
	      runMode(cm, line.text, overlay.mode, true, function(end, style) {
	        var start = i;
	        // Ensure there's a token end at the current position, and that i points at it
	        while (at < end) {
	          var i_end = st[i];
	          if (i_end > end)
	            st.splice(i, 1, end, st[i+1], i_end);
	          i += 2;
	          at = Math.min(end, i_end);
	        }
	        if (!style) return;
	        if (overlay.opaque) {
	          st.splice(start, i - start, end, "cm-overlay " + style);
	          i = start + 2;
	        } else {
	          for (; start < i; start += 2) {
	            var cur = st[start+1];
	            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
	          }
	        }
	      }, lineClasses);
	    }

	    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
	  }

	  function getLineStyles(cm, line, updateFrontier) {
	    if (!line.styles || line.styles[0] != cm.state.modeGen) {
	      var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
	      line.styles = result.styles;
	      if (result.classes) line.styleClasses = result.classes;
	      else if (line.styleClasses) line.styleClasses = null;
	      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
	    }
	    return line.styles;
	  }

	  // Lightweight form of highlight -- proceed over this line and
	  // update state, but don't save a style array. Used for lines that
	  // aren't currently visible.
	  function processLine(cm, text, state, startAt) {
	    var mode = cm.doc.mode;
	    var stream = new StringStream(text, cm.options.tabSize);
	    stream.start = stream.pos = startAt || 0;
	    if (text == "") callBlankLine(mode, state);
	    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
	      readToken(mode, stream, state);
	      stream.start = stream.pos;
	    }
	  }

	  // Convert a style as returned by a mode (either null, or a string
	  // containing one or more styles) to a CSS style. This is cached,
	  // and also looks for line-wide styles.
	  var styleToClassCache = {}, styleToClassCacheWithMode = {};
	  function interpretTokenStyle(style, options) {
	    if (!style || /^\s*$/.test(style)) return null;
	    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
	    return cache[style] ||
	      (cache[style] = style.replace(/\S+/g, "cm-$&"));
	  }

	  // Render the DOM representation of the text of a line. Also builds
	  // up a 'line map', which points at the DOM nodes that represent
	  // specific stretches of text, and is used by the measuring code.
	  // The returned object contains the DOM node, this map, and
	  // information about line-wide styles that were set by the mode.
	  function buildLineContent(cm, lineView) {
	    // The padding-right forces the element to have a 'border', which
	    // is needed on Webkit to be able to get line-level bounding
	    // rectangles for it (in measureChar).
	    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
	    var builder = {pre: elt("pre", [content]), content: content, col: 0, pos: 0, cm: cm};
	    lineView.measure = {};

	    // Iterate over the logical lines that make up this visual line.
	    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
	      var line = i ? lineView.rest[i - 1] : lineView.line, order;
	      builder.pos = 0;
	      builder.addToken = buildToken;
	      // Optionally wire in some hacks into the token-rendering
	      // algorithm, to deal with browser quirks.
	      if ((ie || webkit) && cm.getOption("lineWrapping"))
	        builder.addToken = buildTokenSplitSpaces(builder.addToken);
	      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
	        builder.addToken = buildTokenBadBidi(builder.addToken, order);
	      builder.map = [];
	      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
	      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
	      if (line.styleClasses) {
	        if (line.styleClasses.bgClass)
	          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
	        if (line.styleClasses.textClass)
	          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
	      }

	      // Ensure at least a single node is present, for measuring.
	      if (builder.map.length == 0)
	        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

	      // Store the map and a cache object for the current logical line
	      if (i == 0) {
	        lineView.measure.map = builder.map;
	        lineView.measure.cache = {};
	      } else {
	        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
	        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
	      }
	    }

	    // See issue #2901
	    if (webkit && /\bcm-tab\b/.test(builder.content.lastChild.className))
	      builder.content.className = "cm-tab-wrap-hack";

	    signal(cm, "renderLine", cm, lineView.line, builder.pre);
	    if (builder.pre.className)
	      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");

	    return builder;
	  }

	  function defaultSpecialCharPlaceholder(ch) {
	    var token = elt("span", "\u2022", "cm-invalidchar");
	    token.title = "\\u" + ch.charCodeAt(0).toString(16);
	    token.setAttribute("aria-label", token.title);
	    return token;
	  }

	  // Build up the DOM representation for a single token, and add it to
	  // the line map. Takes care to render special characters separately.
	  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
	    if (!text) return;
	    var special = builder.cm.options.specialChars, mustWrap = false;
	    if (!special.test(text)) {
	      builder.col += text.length;
	      var content = document.createTextNode(text);
	      builder.map.push(builder.pos, builder.pos + text.length, content);
	      if (ie && ie_version < 9) mustWrap = true;
	      builder.pos += text.length;
	    } else {
	      var content = document.createDocumentFragment(), pos = 0;
	      while (true) {
	        special.lastIndex = pos;
	        var m = special.exec(text);
	        var skipped = m ? m.index - pos : text.length - pos;
	        if (skipped) {
	          var txt = document.createTextNode(text.slice(pos, pos + skipped));
	          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
	          else content.appendChild(txt);
	          builder.map.push(builder.pos, builder.pos + skipped, txt);
	          builder.col += skipped;
	          builder.pos += skipped;
	        }
	        if (!m) break;
	        pos += skipped + 1;
	        if (m[0] == "\t") {
	          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
	          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
	          txt.setAttribute("role", "presentation");
	          builder.col += tabWidth;
	        } else {
	          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
	          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
	          else content.appendChild(txt);
	          builder.col += 1;
	        }
	        builder.map.push(builder.pos, builder.pos + 1, txt);
	        builder.pos++;
	      }
	    }
	    if (style || startStyle || endStyle || mustWrap || css) {
	      var fullStyle = style || "";
	      if (startStyle) fullStyle += startStyle;
	      if (endStyle) fullStyle += endStyle;
	      var token = elt("span", [content], fullStyle, css);
	      if (title) token.title = title;
	      return builder.content.appendChild(token);
	    }
	    builder.content.appendChild(content);
	  }

	  function buildTokenSplitSpaces(inner) {
	    function split(old) {
	      var out = " ";
	      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
	      out += " ";
	      return out;
	    }
	    return function(builder, text, style, startStyle, endStyle, title) {
	      inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);
	    };
	  }

	  // Work around nonsense dimensions being reported for stretches of
	  // right-to-left text.
	  function buildTokenBadBidi(inner, order) {
	    return function(builder, text, style, startStyle, endStyle, title) {
	      style = style ? style + " cm-force-border" : "cm-force-border";
	      var start = builder.pos, end = start + text.length;
	      for (;;) {
	        // Find the part that overlaps with the start of this text
	        for (var i = 0; i < order.length; i++) {
	          var part = order[i];
	          if (part.to > start && part.from <= start) break;
	        }
	        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title);
	        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title);
	        startStyle = null;
	        text = text.slice(part.to - start);
	        start = part.to;
	      }
	    };
	  }

	  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
	    var widget = !ignoreWidget && marker.widgetNode;
	    if (widget) {
	      builder.map.push(builder.pos, builder.pos + size, widget);
	      builder.content.appendChild(widget);
	    }
	    builder.pos += size;
	  }

	  // Outputs a number of spans to make up a line, taking highlighting
	  // and marked text into account.
	  function insertLineContent(line, builder, styles) {
	    var spans = line.markedSpans, allText = line.text, at = 0;
	    if (!spans) {
	      for (var i = 1; i < styles.length; i+=2)
	        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
	      return;
	    }

	    var len = allText.length, pos = 0, i = 1, text = "", style, css;
	    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
	    for (;;) {
	      if (nextChange == pos) { // Update current marker set
	        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
	        collapsed = null; nextChange = Infinity;
	        var foundBookmarks = [];
	        for (var j = 0; j < spans.length; ++j) {
	          var sp = spans[j], m = sp.marker;
	          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
	            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }
	            if (m.className) spanStyle += " " + m.className;
	            if (m.css) css = m.css;
	            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
	            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
	            if (m.title && !title) title = m.title;
	            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
	              collapsed = sp;
	          } else if (sp.from > pos && nextChange > sp.from) {
	            nextChange = sp.from;
	          }
	          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) foundBookmarks.push(m);
	        }
	        if (collapsed && (collapsed.from || 0) == pos) {
	          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
	                             collapsed.marker, collapsed.from == null);
	          if (collapsed.to == null) return;
	        }
	        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)
	          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
	      }
	      if (pos >= len) break;

	      var upto = Math.min(len, nextChange);
	      while (true) {
	        if (text) {
	          var end = pos + text.length;
	          if (!collapsed) {
	            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
	            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
	                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
	          }
	          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
	          pos = end;
	          spanStartStyle = "";
	        }
	        text = allText.slice(at, at = styles[i++]);
	        style = interpretTokenStyle(styles[i++], builder.cm.options);
	      }
	    }
	  }

	  // DOCUMENT DATA STRUCTURE

	  // By default, updates that start and end at the beginning of a line
	  // are treated specially, in order to make the association of line
	  // widgets and marker elements with the text behave more intuitive.
	  function isWholeLineUpdate(doc, change) {
	    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
	      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
	  }

	  // Perform a change on the document data structure.
	  function updateDoc(doc, change, markedSpans, estimateHeight) {
	    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
	    function update(line, text, spans) {
	      updateLine(line, text, spans, estimateHeight);
	      signalLater(line, "change", line, change);
	    }
	    function linesFor(start, end) {
	      for (var i = start, result = []; i < end; ++i)
	        result.push(new Line(text[i], spansFor(i), estimateHeight));
	      return result;
	    }

	    var from = change.from, to = change.to, text = change.text;
	    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
	    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

	    // Adjust the line structure
	    if (change.full) {
	      doc.insert(0, linesFor(0, text.length));
	      doc.remove(text.length, doc.size - text.length);
	    } else if (isWholeLineUpdate(doc, change)) {
	      // This is a whole-line replace. Treated specially to make
	      // sure line objects move the way they are supposed to.
	      var added = linesFor(0, text.length - 1);
	      update(lastLine, lastLine.text, lastSpans);
	      if (nlines) doc.remove(from.line, nlines);
	      if (added.length) doc.insert(from.line, added);
	    } else if (firstLine == lastLine) {
	      if (text.length == 1) {
	        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
	      } else {
	        var added = linesFor(1, text.length - 1);
	        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
	        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	        doc.insert(from.line + 1, added);
	      }
	    } else if (text.length == 1) {
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
	      doc.remove(from.line + 1, nlines);
	    } else {
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
	      var added = linesFor(1, text.length - 1);
	      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
	      doc.insert(from.line + 1, added);
	    }

	    signalLater(doc, "change", doc, change);
	  }

	  // The document is represented as a BTree consisting of leaves, with
	  // chunk of lines in them, and branches, with up to ten leaves or
	  // other branch nodes below them. The top node is always a branch
	  // node, and is the document object itself (meaning it has
	  // additional methods and properties).
	  //
	  // All nodes have parent links. The tree is used both to go from
	  // line numbers to line objects, and to go from objects to numbers.
	  // It also indexes by height, and is used to convert between height
	  // and line object, and to find the total height of the document.
	  //
	  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

	  function LeafChunk(lines) {
	    this.lines = lines;
	    this.parent = null;
	    for (var i = 0, height = 0; i < lines.length; ++i) {
	      lines[i].parent = this;
	      height += lines[i].height;
	    }
	    this.height = height;
	  }

	  LeafChunk.prototype = {
	    chunkSize: function() { return this.lines.length; },
	    // Remove the n lines at offset 'at'.
	    removeInner: function(at, n) {
	      for (var i = at, e = at + n; i < e; ++i) {
	        var line = this.lines[i];
	        this.height -= line.height;
	        cleanUpLine(line);
	        signalLater(line, "delete");
	      }
	      this.lines.splice(at, n);
	    },
	    // Helper used to collapse a small branch into a single leaf.
	    collapse: function(lines) {
	      lines.push.apply(lines, this.lines);
	    },
	    // Insert the given array of lines at offset 'at', count them as
	    // having the given height.
	    insertInner: function(at, lines, height) {
	      this.height += height;
	      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
	      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
	    },
	    // Used to iterate over a part of the tree.
	    iterN: function(at, n, op) {
	      for (var e = at + n; at < e; ++at)
	        if (op(this.lines[at])) return true;
	    }
	  };

	  function BranchChunk(children) {
	    this.children = children;
	    var size = 0, height = 0;
	    for (var i = 0; i < children.length; ++i) {
	      var ch = children[i];
	      size += ch.chunkSize(); height += ch.height;
	      ch.parent = this;
	    }
	    this.size = size;
	    this.height = height;
	    this.parent = null;
	  }

	  BranchChunk.prototype = {
	    chunkSize: function() { return this.size; },
	    removeInner: function(at, n) {
	      this.size -= n;
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at < sz) {
	          var rm = Math.min(n, sz - at), oldHeight = child.height;
	          child.removeInner(at, rm);
	          this.height -= oldHeight - child.height;
	          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
	          if ((n -= rm) == 0) break;
	          at = 0;
	        } else at -= sz;
	      }
	      // If the result is smaller than 25 lines, ensure that it is a
	      // single leaf node.
	      if (this.size - n < 25 &&
	          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
	        var lines = [];
	        this.collapse(lines);
	        this.children = [new LeafChunk(lines)];
	        this.children[0].parent = this;
	      }
	    },
	    collapse: function(lines) {
	      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
	    },
	    insertInner: function(at, lines, height) {
	      this.size += lines.length;
	      this.height += height;
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at <= sz) {
	          child.insertInner(at, lines, height);
	          if (child.lines && child.lines.length > 50) {
	            while (child.lines.length > 50) {
	              var spilled = child.lines.splice(child.lines.length - 25, 25);
	              var newleaf = new LeafChunk(spilled);
	              child.height -= newleaf.height;
	              this.children.splice(i + 1, 0, newleaf);
	              newleaf.parent = this;
	            }
	            this.maybeSpill();
	          }
	          break;
	        }
	        at -= sz;
	      }
	    },
	    // When a node has grown, check whether it should be split.
	    maybeSpill: function() {
	      if (this.children.length <= 10) return;
	      var me = this;
	      do {
	        var spilled = me.children.splice(me.children.length - 5, 5);
	        var sibling = new BranchChunk(spilled);
	        if (!me.parent) { // Become the parent node
	          var copy = new BranchChunk(me.children);
	          copy.parent = me;
	          me.children = [copy, sibling];
	          me = copy;
	        } else {
	          me.size -= sibling.size;
	          me.height -= sibling.height;
	          var myIndex = indexOf(me.parent.children, me);
	          me.parent.children.splice(myIndex + 1, 0, sibling);
	        }
	        sibling.parent = me.parent;
	      } while (me.children.length > 10);
	      me.parent.maybeSpill();
	    },
	    iterN: function(at, n, op) {
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at < sz) {
	          var used = Math.min(n, sz - at);
	          if (child.iterN(at, used, op)) return true;
	          if ((n -= used) == 0) break;
	          at = 0;
	        } else at -= sz;
	      }
	    }
	  };

	  var nextDocId = 0;
	  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {
	    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
	    if (firstLine == null) firstLine = 0;

	    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
	    this.first = firstLine;
	    this.scrollTop = this.scrollLeft = 0;
	    this.cantEdit = false;
	    this.cleanGeneration = 1;
	    this.frontier = firstLine;
	    var start = Pos(firstLine, 0);
	    this.sel = simpleSelection(start);
	    this.history = new History(null);
	    this.id = ++nextDocId;
	    this.modeOption = mode;

	    if (typeof text == "string") text = splitLines(text);
	    updateDoc(this, {from: start, to: start, text: text});
	    setSelection(this, simpleSelection(start), sel_dontScroll);
	  };

	  Doc.prototype = createObj(BranchChunk.prototype, {
	    constructor: Doc,
	    // Iterate over the document. Supports two forms -- with only one
	    // argument, it calls that for each line in the document. With
	    // three, it iterates over the range given by the first two (with
	    // the second being non-inclusive).
	    iter: function(from, to, op) {
	      if (op) this.iterN(from - this.first, to - from, op);
	      else this.iterN(this.first, this.first + this.size, from);
	    },

	    // Non-public interface for adding and removing lines.
	    insert: function(at, lines) {
	      var height = 0;
	      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
	      this.insertInner(at - this.first, lines, height);
	    },
	    remove: function(at, n) { this.removeInner(at - this.first, n); },

	    // From here, the methods are part of the public interface. Most
	    // are also available from CodeMirror (editor) instances.

	    getValue: function(lineSep) {
	      var lines = getLines(this, this.first, this.first + this.size);
	      if (lineSep === false) return lines;
	      return lines.join(lineSep || "\n");
	    },
	    setValue: docMethodOp(function(code) {
	      var top = Pos(this.first, 0), last = this.first + this.size - 1;
	      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
	                        text: splitLines(code), origin: "setValue", full: true}, true);
	      setSelection(this, simpleSelection(top));
	    }),
	    replaceRange: function(code, from, to, origin) {
	      from = clipPos(this, from);
	      to = to ? clipPos(this, to) : from;
	      replaceRange(this, code, from, to, origin);
	    },
	    getRange: function(from, to, lineSep) {
	      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
	      if (lineSep === false) return lines;
	      return lines.join(lineSep || "\n");
	    },

	    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

	    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
	    getLineNumber: function(line) {return lineNo(line);},

	    getLineHandleVisualStart: function(line) {
	      if (typeof line == "number") line = getLine(this, line);
	      return visualLine(line);
	    },

	    lineCount: function() {return this.size;},
	    firstLine: function() {return this.first;},
	    lastLine: function() {return this.first + this.size - 1;},

	    clipPos: function(pos) {return clipPos(this, pos);},

	    getCursor: function(start) {
	      var range = this.sel.primary(), pos;
	      if (start == null || start == "head") pos = range.head;
	      else if (start == "anchor") pos = range.anchor;
	      else if (start == "end" || start == "to" || start === false) pos = range.to();
	      else pos = range.from();
	      return pos;
	    },
	    listSelections: function() { return this.sel.ranges; },
	    somethingSelected: function() {return this.sel.somethingSelected();},

	    setCursor: docMethodOp(function(line, ch, options) {
	      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
	    }),
	    setSelection: docMethodOp(function(anchor, head, options) {
	      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
	    }),
	    extendSelection: docMethodOp(function(head, other, options) {
	      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
	    }),
	    extendSelections: docMethodOp(function(heads, options) {
	      extendSelections(this, clipPosArray(this, heads, options));
	    }),
	    extendSelectionsBy: docMethodOp(function(f, options) {
	      extendSelections(this, map(this.sel.ranges, f), options);
	    }),
	    setSelections: docMethodOp(function(ranges, primary, options) {
	      if (!ranges.length) return;
	      for (var i = 0, out = []; i < ranges.length; i++)
	        out[i] = new Range(clipPos(this, ranges[i].anchor),
	                           clipPos(this, ranges[i].head));
	      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
	      setSelection(this, normalizeSelection(out, primary), options);
	    }),
	    addSelection: docMethodOp(function(anchor, head, options) {
	      var ranges = this.sel.ranges.slice(0);
	      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
	      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
	    }),

	    getSelection: function(lineSep) {
	      var ranges = this.sel.ranges, lines;
	      for (var i = 0; i < ranges.length; i++) {
	        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
	        lines = lines ? lines.concat(sel) : sel;
	      }
	      if (lineSep === false) return lines;
	      else return lines.join(lineSep || "\n");
	    },
	    getSelections: function(lineSep) {
	      var parts = [], ranges = this.sel.ranges;
	      for (var i = 0; i < ranges.length; i++) {
	        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
	        if (lineSep !== false) sel = sel.join(lineSep || "\n");
	        parts[i] = sel;
	      }
	      return parts;
	    },
	    replaceSelection: function(code, collapse, origin) {
	      var dup = [];
	      for (var i = 0; i < this.sel.ranges.length; i++)
	        dup[i] = code;
	      this.replaceSelections(dup, collapse, origin || "+input");
	    },
	    replaceSelections: docMethodOp(function(code, collapse, origin) {
	      var changes = [], sel = this.sel;
	      for (var i = 0; i < sel.ranges.length; i++) {
	        var range = sel.ranges[i];
	        changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin};
	      }
	      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
	      for (var i = changes.length - 1; i >= 0; i--)
	        makeChange(this, changes[i]);
	      if (newSel) setSelectionReplaceHistory(this, newSel);
	      else if (this.cm) ensureCursorVisible(this.cm);
	    }),
	    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
	    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
	    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
	    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

	    setExtending: function(val) {this.extend = val;},
	    getExtending: function() {return this.extend;},

	    historySize: function() {
	      var hist = this.history, done = 0, undone = 0;
	      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
	      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
	      return {undo: done, redo: undone};
	    },
	    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

	    markClean: function() {
	      this.cleanGeneration = this.changeGeneration(true);
	    },
	    changeGeneration: function(forceSplit) {
	      if (forceSplit)
	        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
	      return this.history.generation;
	    },
	    isClean: function (gen) {
	      return this.history.generation == (gen || this.cleanGeneration);
	    },

	    getHistory: function() {
	      return {done: copyHistoryArray(this.history.done),
	              undone: copyHistoryArray(this.history.undone)};
	    },
	    setHistory: function(histData) {
	      var hist = this.history = new History(this.history.maxGeneration);
	      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
	      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
	    },

	    addLineClass: docMethodOp(function(handle, where, cls) {
	      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
	        var prop = where == "text" ? "textClass"
	                 : where == "background" ? "bgClass"
	                 : where == "gutter" ? "gutterClass" : "wrapClass";
	        if (!line[prop]) line[prop] = cls;
	        else if (classTest(cls).test(line[prop])) return false;
	        else line[prop] += " " + cls;
	        return true;
	      });
	    }),
	    removeLineClass: docMethodOp(function(handle, where, cls) {
	      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
	        var prop = where == "text" ? "textClass"
	                 : where == "background" ? "bgClass"
	                 : where == "gutter" ? "gutterClass" : "wrapClass";
	        var cur = line[prop];
	        if (!cur) return false;
	        else if (cls == null) line[prop] = null;
	        else {
	          var found = cur.match(classTest(cls));
	          if (!found) return false;
	          var end = found.index + found[0].length;
	          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
	        }
	        return true;
	      });
	    }),

	    markText: function(from, to, options) {
	      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
	    },
	    setBookmark: function(pos, options) {
	      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
	                      insertLeft: options && options.insertLeft,
	                      clearWhenEmpty: false, shared: options && options.shared};
	      pos = clipPos(this, pos);
	      return markText(this, pos, pos, realOpts, "bookmark");
	    },
	    findMarksAt: function(pos) {
	      pos = clipPos(this, pos);
	      var markers = [], spans = getLine(this, pos.line).markedSpans;
	      if (spans) for (var i = 0; i < spans.length; ++i) {
	        var span = spans[i];
	        if ((span.from == null || span.from <= pos.ch) &&
	            (span.to == null || span.to >= pos.ch))
	          markers.push(span.marker.parent || span.marker);
	      }
	      return markers;
	    },
	    findMarks: function(from, to, filter) {
	      from = clipPos(this, from); to = clipPos(this, to);
	      var found = [], lineNo = from.line;
	      this.iter(from.line, to.line + 1, function(line) {
	        var spans = line.markedSpans;
	        if (spans) for (var i = 0; i < spans.length; i++) {
	          var span = spans[i];
	          if (!(lineNo == from.line && from.ch > span.to ||
	                span.from == null && lineNo != from.line||
	                lineNo == to.line && span.from > to.ch) &&
	              (!filter || filter(span.marker)))
	            found.push(span.marker.parent || span.marker);
	        }
	        ++lineNo;
	      });
	      return found;
	    },
	    getAllMarks: function() {
	      var markers = [];
	      this.iter(function(line) {
	        var sps = line.markedSpans;
	        if (sps) for (var i = 0; i < sps.length; ++i)
	          if (sps[i].from != null) markers.push(sps[i].marker);
	      });
	      return markers;
	    },

	    posFromIndex: function(off) {
	      var ch, lineNo = this.first;
	      this.iter(function(line) {
	        var sz = line.text.length + 1;
	        if (sz > off) { ch = off; return true; }
	        off -= sz;
	        ++lineNo;
	      });
	      return clipPos(this, Pos(lineNo, ch));
	    },
	    indexFromPos: function (coords) {
	      coords = clipPos(this, coords);
	      var index = coords.ch;
	      if (coords.line < this.first || coords.ch < 0) return 0;
	      this.iter(this.first, coords.line, function (line) {
	        index += line.text.length + 1;
	      });
	      return index;
	    },

	    copy: function(copyHistory) {
	      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
	      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
	      doc.sel = this.sel;
	      doc.extend = false;
	      if (copyHistory) {
	        doc.history.undoDepth = this.history.undoDepth;
	        doc.setHistory(this.getHistory());
	      }
	      return doc;
	    },

	    linkedDoc: function(options) {
	      if (!options) options = {};
	      var from = this.first, to = this.first + this.size;
	      if (options.from != null && options.from > from) from = options.from;
	      if (options.to != null && options.to < to) to = options.to;
	      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
	      if (options.sharedHist) copy.history = this.history;
	      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
	      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
	      copySharedMarkers(copy, findSharedMarkers(this));
	      return copy;
	    },
	    unlinkDoc: function(other) {
	      if (other instanceof CodeMirror) other = other.doc;
	      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
	        var link = this.linked[i];
	        if (link.doc != other) continue;
	        this.linked.splice(i, 1);
	        other.unlinkDoc(this);
	        detachSharedMarkers(findSharedMarkers(this));
	        break;
	      }
	      // If the histories were shared, split them again
	      if (other.history == this.history) {
	        var splitIds = [other.id];
	        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
	        other.history = new History(null);
	        other.history.done = copyHistoryArray(this.history.done, splitIds);
	        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
	      }
	    },
	    iterLinkedDocs: function(f) {linkedDocs(this, f);},

	    getMode: function() {return this.mode;},
	    getEditor: function() {return this.cm;}
	  });

	  // Public alias.
	  Doc.prototype.eachLine = Doc.prototype.iter;

	  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
	  var dontDelegate = "iter insert remove copy getEditor".split(" ");
	  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
	    CodeMirror.prototype[prop] = (function(method) {
	      return function() {return method.apply(this.doc, arguments);};
	    })(Doc.prototype[prop]);

	  eventMixin(Doc);

	  // Call f for all linked documents.
	  function linkedDocs(doc, f, sharedHistOnly) {
	    function propagate(doc, skip, sharedHist) {
	      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
	        var rel = doc.linked[i];
	        if (rel.doc == skip) continue;
	        var shared = sharedHist && rel.sharedHist;
	        if (sharedHistOnly && !shared) continue;
	        f(rel.doc, shared);
	        propagate(rel.doc, doc, shared);
	      }
	    }
	    propagate(doc, null, true);
	  }

	  // Attach a document to an editor.
	  function attachDoc(cm, doc) {
	    if (doc.cm) throw new Error("This document is already in use.");
	    cm.doc = doc;
	    doc.cm = cm;
	    estimateLineHeights(cm);
	    loadMode(cm);
	    if (!cm.options.lineWrapping) findMaxLine(cm);
	    cm.options.mode = doc.modeOption;
	    regChange(cm);
	  }

	  // LINE UTILITIES

	  // Find the line object corresponding to the given line number.
	  function getLine(doc, n) {
	    n -= doc.first;
	    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
	    for (var chunk = doc; !chunk.lines;) {
	      for (var i = 0;; ++i) {
	        var child = chunk.children[i], sz = child.chunkSize();
	        if (n < sz) { chunk = child; break; }
	        n -= sz;
	      }
	    }
	    return chunk.lines[n];
	  }

	  // Get the part of a document between two positions, as an array of
	  // strings.
	  function getBetween(doc, start, end) {
	    var out = [], n = start.line;
	    doc.iter(start.line, end.line + 1, function(line) {
	      var text = line.text;
	      if (n == end.line) text = text.slice(0, end.ch);
	      if (n == start.line) text = text.slice(start.ch);
	      out.push(text);
	      ++n;
	    });
	    return out;
	  }
	  // Get the lines between from and to, as array of strings.
	  function getLines(doc, from, to) {
	    var out = [];
	    doc.iter(from, to, function(line) { out.push(line.text); });
	    return out;
	  }

	  // Update the height of a line, propagating the height change
	  // upwards to parent nodes.
	  function updateLineHeight(line, height) {
	    var diff = height - line.height;
	    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
	  }

	  // Given a line object, find its line number by walking up through
	  // its parent links.
	  function lineNo(line) {
	    if (line.parent == null) return null;
	    var cur = line.parent, no = indexOf(cur.lines, line);
	    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
	      for (var i = 0;; ++i) {
	        if (chunk.children[i] == cur) break;
	        no += chunk.children[i].chunkSize();
	      }
	    }
	    return no + cur.first;
	  }

	  // Find the line at the given vertical position, using the height
	  // information in the document tree.
	  function lineAtHeight(chunk, h) {
	    var n = chunk.first;
	    outer: do {
	      for (var i = 0; i < chunk.children.length; ++i) {
	        var child = chunk.children[i], ch = child.height;
	        if (h < ch) { chunk = child; continue outer; }
	        h -= ch;
	        n += child.chunkSize();
	      }
	      return n;
	    } while (!chunk.lines);
	    for (var i = 0; i < chunk.lines.length; ++i) {
	      var line = chunk.lines[i], lh = line.height;
	      if (h < lh) break;
	      h -= lh;
	    }
	    return n + i;
	  }


	  // Find the height above the given line.
	  function heightAtLine(lineObj) {
	    lineObj = visualLine(lineObj);

	    var h = 0, chunk = lineObj.parent;
	    for (var i = 0; i < chunk.lines.length; ++i) {
	      var line = chunk.lines[i];
	      if (line == lineObj) break;
	      else h += line.height;
	    }
	    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
	      for (var i = 0; i < p.children.length; ++i) {
	        var cur = p.children[i];
	        if (cur == chunk) break;
	        else h += cur.height;
	      }
	    }
	    return h;
	  }

	  // Get the bidi ordering for the given line (and cache it). Returns
	  // false for lines that are fully left-to-right, and an array of
	  // BidiSpan objects otherwise.
	  function getOrder(line) {
	    var order = line.order;
	    if (order == null) order = line.order = bidiOrdering(line.text);
	    return order;
	  }

	  // HISTORY

	  function History(startGen) {
	    // Arrays of change events and selections. Doing something adds an
	    // event to done and clears undo. Undoing moves events from done
	    // to undone, redoing moves them in the other direction.
	    this.done = []; this.undone = [];
	    this.undoDepth = Infinity;
	    // Used to track when changes can be merged into a single undo
	    // event
	    this.lastModTime = this.lastSelTime = 0;
	    this.lastOp = this.lastSelOp = null;
	    this.lastOrigin = this.lastSelOrigin = null;
	    // Used by the isClean() method
	    this.generation = this.maxGeneration = startGen || 1;
	  }

	  // Create a history change event from an updateDoc-style change
	  // object.
	  function historyChangeFromChange(doc, change) {
	    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
	    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
	    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
	    return histChange;
	  }

	  // Pop all selection events off the end of a history array. Stop at
	  // a change event.
	  function clearSelectionEvents(array) {
	    while (array.length) {
	      var last = lst(array);
	      if (last.ranges) array.pop();
	      else break;
	    }
	  }

	  // Find the top change event in the history. Pop off selection
	  // events that are in the way.
	  function lastChangeEvent(hist, force) {
	    if (force) {
	      clearSelectionEvents(hist.done);
	      return lst(hist.done);
	    } else if (hist.done.length && !lst(hist.done).ranges) {
	      return lst(hist.done);
	    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
	      hist.done.pop();
	      return lst(hist.done);
	    }
	  }

	  // Register a change in the history. Merges changes that are within
	  // a single operation, ore are close together with an origin that
	  // allows merging (starting with "+") into a single event.
	  function addChangeToHistory(doc, change, selAfter, opId) {
	    var hist = doc.history;
	    hist.undone.length = 0;
	    var time = +new Date, cur;

	    if ((hist.lastOp == opId ||
	         hist.lastOrigin == change.origin && change.origin &&
	         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
	          change.origin.charAt(0) == "*")) &&
	        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
	      // Merge this change into the last event
	      var last = lst(cur.changes);
	      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
	        // Optimized case for simple insertion -- don't want to add
	        // new changesets for every character typed
	        last.to = changeEnd(change);
	      } else {
	        // Add new sub-event
	        cur.changes.push(historyChangeFromChange(doc, change));
	      }
	    } else {
	      // Can not be merged, start a new event.
	      var before = lst(hist.done);
	      if (!before || !before.ranges)
	        pushSelectionToHistory(doc.sel, hist.done);
	      cur = {changes: [historyChangeFromChange(doc, change)],
	             generation: hist.generation};
	      hist.done.push(cur);
	      while (hist.done.length > hist.undoDepth) {
	        hist.done.shift();
	        if (!hist.done[0].ranges) hist.done.shift();
	      }
	    }
	    hist.done.push(selAfter);
	    hist.generation = ++hist.maxGeneration;
	    hist.lastModTime = hist.lastSelTime = time;
	    hist.lastOp = hist.lastSelOp = opId;
	    hist.lastOrigin = hist.lastSelOrigin = change.origin;

	    if (!last) signal(doc, "historyAdded");
	  }

	  function selectionEventCanBeMerged(doc, origin, prev, sel) {
	    var ch = origin.charAt(0);
	    return ch == "*" ||
	      ch == "+" &&
	      prev.ranges.length == sel.ranges.length &&
	      prev.somethingSelected() == sel.somethingSelected() &&
	      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
	  }

	  // Called whenever the selection changes, sets the new selection as
	  // the pending selection in the history, and pushes the old pending
	  // selection into the 'done' array when it was significantly
	  // different (in number of selected ranges, emptiness, or time).
	  function addSelectionToHistory(doc, sel, opId, options) {
	    var hist = doc.history, origin = options && options.origin;

	    // A new event is started when the previous origin does not match
	    // the current, or the origins don't allow matching. Origins
	    // starting with * are always merged, those starting with + are
	    // merged when similar and close together in time.
	    if (opId == hist.lastSelOp ||
	        (origin && hist.lastSelOrigin == origin &&
	         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
	          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
	      hist.done[hist.done.length - 1] = sel;
	    else
	      pushSelectionToHistory(sel, hist.done);

	    hist.lastSelTime = +new Date;
	    hist.lastSelOrigin = origin;
	    hist.lastSelOp = opId;
	    if (options && options.clearRedo !== false)
	      clearSelectionEvents(hist.undone);
	  }

	  function pushSelectionToHistory(sel, dest) {
	    var top = lst(dest);
	    if (!(top && top.ranges && top.equals(sel)))
	      dest.push(sel);
	  }

	  // Used to store marked span information in the history.
	  function attachLocalSpans(doc, change, from, to) {
	    var existing = change["spans_" + doc.id], n = 0;
	    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
	      if (line.markedSpans)
	        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
	      ++n;
	    });
	  }

	  // When un/re-doing restores text containing marked spans, those
	  // that have been explicitly cleared should not be restored.
	  function removeClearedSpans(spans) {
	    if (!spans) return null;
	    for (var i = 0, out; i < spans.length; ++i) {
	      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
	      else if (out) out.push(spans[i]);
	    }
	    return !out ? spans : out.length ? out : null;
	  }

	  // Retrieve and filter the old marked spans stored in a change event.
	  function getOldSpans(doc, change) {
	    var found = change["spans_" + doc.id];
	    if (!found) return null;
	    for (var i = 0, nw = []; i < change.text.length; ++i)
	      nw.push(removeClearedSpans(found[i]));
	    return nw;
	  }

	  // Used both to provide a JSON-safe object in .getHistory, and, when
	  // detaching a document, to split the history in two
	  function copyHistoryArray(events, newGroup, instantiateSel) {
	    for (var i = 0, copy = []; i < events.length; ++i) {
	      var event = events[i];
	      if (event.ranges) {
	        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
	        continue;
	      }
	      var changes = event.changes, newChanges = [];
	      copy.push({changes: newChanges});
	      for (var j = 0; j < changes.length; ++j) {
	        var change = changes[j], m;
	        newChanges.push({from: change.from, to: change.to, text: change.text});
	        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
	          if (indexOf(newGroup, Number(m[1])) > -1) {
	            lst(newChanges)[prop] = change[prop];
	            delete change[prop];
	          }
	        }
	      }
	    }
	    return copy;
	  }

	  // Rebasing/resetting history to deal with externally-sourced changes

	  function rebaseHistSelSingle(pos, from, to, diff) {
	    if (to < pos.line) {
	      pos.line += diff;
	    } else if (from < pos.line) {
	      pos.line = from;
	      pos.ch = 0;
	    }
	  }

	  // Tries to rebase an array of history events given a change in the
	  // document. If the change touches the same lines as the event, the
	  // event, and everything 'behind' it, is discarded. If the change is
	  // before the event, the event's positions are updated. Uses a
	  // copy-on-write scheme for the positions, to avoid having to
	  // reallocate them all on every rebase, but also avoid problems with
	  // shared position objects being unsafely updated.
	  function rebaseHistArray(array, from, to, diff) {
	    for (var i = 0; i < array.length; ++i) {
	      var sub = array[i], ok = true;
	      if (sub.ranges) {
	        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
	        for (var j = 0; j < sub.ranges.length; j++) {
	          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
	          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
	        }
	        continue;
	      }
	      for (var j = 0; j < sub.changes.length; ++j) {
	        var cur = sub.changes[j];
	        if (to < cur.from.line) {
	          cur.from = Pos(cur.from.line + diff, cur.from.ch);
	          cur.to = Pos(cur.to.line + diff, cur.to.ch);
	        } else if (from <= cur.to.line) {
	          ok = false;
	          break;
	        }
	      }
	      if (!ok) {
	        array.splice(0, i + 1);
	        i = 0;
	      }
	    }
	  }

	  function rebaseHist(hist, change) {
	    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
	    rebaseHistArray(hist.done, from, to, diff);
	    rebaseHistArray(hist.undone, from, to, diff);
	  }

	  // EVENT UTILITIES

	  // Due to the fact that we still support jurassic IE versions, some
	  // compatibility wrappers are needed.

	  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
	    if (e.preventDefault) e.preventDefault();
	    else e.returnValue = false;
	  };
	  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
	    if (e.stopPropagation) e.stopPropagation();
	    else e.cancelBubble = true;
	  };
	  function e_defaultPrevented(e) {
	    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
	  }
	  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

	  function e_target(e) {return e.target || e.srcElement;}
	  function e_button(e) {
	    var b = e.which;
	    if (b == null) {
	      if (e.button & 1) b = 1;
	      else if (e.button & 2) b = 3;
	      else if (e.button & 4) b = 2;
	    }
	    if (mac && e.ctrlKey && b == 1) b = 3;
	    return b;
	  }

	  // EVENT HANDLING

	  // Lightweight event framework. on/off also work on DOM nodes,
	  // registering native DOM handlers.

	  var on = CodeMirror.on = function(emitter, type, f) {
	    if (emitter.addEventListener)
	      emitter.addEventListener(type, f, false);
	    else if (emitter.attachEvent)
	      emitter.attachEvent("on" + type, f);
	    else {
	      var map = emitter._handlers || (emitter._handlers = {});
	      var arr = map[type] || (map[type] = []);
	      arr.push(f);
	    }
	  };

	  var off = CodeMirror.off = function(emitter, type, f) {
	    if (emitter.removeEventListener)
	      emitter.removeEventListener(type, f, false);
	    else if (emitter.detachEvent)
	      emitter.detachEvent("on" + type, f);
	    else {
	      var arr = emitter._handlers && emitter._handlers[type];
	      if (!arr) return;
	      for (var i = 0; i < arr.length; ++i)
	        if (arr[i] == f) { arr.splice(i, 1); break; }
	    }
	  };

	  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
	    var arr = emitter._handlers && emitter._handlers[type];
	    if (!arr) return;
	    var args = Array.prototype.slice.call(arguments, 2);
	    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
	  };

	  var orphanDelayedCallbacks = null;

	  // Often, we want to signal events at a point where we are in the
	  // middle of some work, but don't want the handler to start calling
	  // other methods on the editor, which might be in an inconsistent
	  // state or simply not expect any other events to happen.
	  // signalLater looks whether there are any handlers, and schedules
	  // them to be executed when the last operation ends, or, if no
	  // operation is active, when a timeout fires.
	  function signalLater(emitter, type /*, values...*/) {
	    var arr = emitter._handlers && emitter._handlers[type];
	    if (!arr) return;
	    var args = Array.prototype.slice.call(arguments, 2), list;
	    if (operationGroup) {
	      list = operationGroup.delayedCallbacks;
	    } else if (orphanDelayedCallbacks) {
	      list = orphanDelayedCallbacks;
	    } else {
	      list = orphanDelayedCallbacks = [];
	      setTimeout(fireOrphanDelayed, 0);
	    }
	    function bnd(f) {return function(){f.apply(null, args);};};
	    for (var i = 0; i < arr.length; ++i)
	      list.push(bnd(arr[i]));
	  }

	  function fireOrphanDelayed() {
	    var delayed = orphanDelayedCallbacks;
	    orphanDelayedCallbacks = null;
	    for (var i = 0; i < delayed.length; ++i) delayed[i]();
	  }

	  // The DOM events that CodeMirror handles can be overridden by
	  // registering a (non-DOM) handler on the editor for the event name,
	  // and preventDefault-ing the event in that handler.
	  function signalDOMEvent(cm, e, override) {
	    if (typeof e == "string")
	      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};
	    signal(cm, override || e.type, cm, e);
	    return e_defaultPrevented(e) || e.codemirrorIgnore;
	  }

	  function signalCursorActivity(cm) {
	    var arr = cm._handlers && cm._handlers.cursorActivity;
	    if (!arr) return;
	    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
	    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
	      set.push(arr[i]);
	  }

	  function hasHandler(emitter, type) {
	    var arr = emitter._handlers && emitter._handlers[type];
	    return arr && arr.length > 0;
	  }

	  // Add on and off methods to a constructor's prototype, to make
	  // registering events on such objects more convenient.
	  function eventMixin(ctor) {
	    ctor.prototype.on = function(type, f) {on(this, type, f);};
	    ctor.prototype.off = function(type, f) {off(this, type, f);};
	  }

	  // MISC UTILITIES

	  // Number of pixels added to scroller and sizer to hide scrollbar
	  var scrollerGap = 30;

	  // Returned or thrown by various protocols to signal 'I'm not
	  // handling this'.
	  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

	  // Reused option objects for setSelection & friends
	  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

	  function Delayed() {this.id = null;}
	  Delayed.prototype.set = function(ms, f) {
	    clearTimeout(this.id);
	    this.id = setTimeout(f, ms);
	  };

	  // Counts the column offset in a string, taking tabs into account.
	  // Used mostly to find indentation.
	  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
	    if (end == null) {
	      end = string.search(/[^\s\u00a0]/);
	      if (end == -1) end = string.length;
	    }
	    for (var i = startIndex || 0, n = startValue || 0;;) {
	      var nextTab = string.indexOf("\t", i);
	      if (nextTab < 0 || nextTab >= end)
	        return n + (end - i);
	      n += nextTab - i;
	      n += tabSize - (n % tabSize);
	      i = nextTab + 1;
	    }
	  };

	  // The inverse of countColumn -- find the offset that corresponds to
	  // a particular column.
	  function findColumn(string, goal, tabSize) {
	    for (var pos = 0, col = 0;;) {
	      var nextTab = string.indexOf("\t", pos);
	      if (nextTab == -1) nextTab = string.length;
	      var skipped = nextTab - pos;
	      if (nextTab == string.length || col + skipped >= goal)
	        return pos + Math.min(skipped, goal - col);
	      col += nextTab - pos;
	      col += tabSize - (col % tabSize);
	      pos = nextTab + 1;
	      if (col >= goal) return pos;
	    }
	  }

	  var spaceStrs = [""];
	  function spaceStr(n) {
	    while (spaceStrs.length <= n)
	      spaceStrs.push(lst(spaceStrs) + " ");
	    return spaceStrs[n];
	  }

	  function lst(arr) { return arr[arr.length-1]; }

	  var selectInput = function(node) { node.select(); };
	  if (ios) // Mobile Safari apparently has a bug where select() is broken.
	    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
	  else if (ie) // Suppress mysterious IE10 errors
	    selectInput = function(node) { try { node.select(); } catch(_e) {} };

	  function indexOf(array, elt) {
	    for (var i = 0; i < array.length; ++i)
	      if (array[i] == elt) return i;
	    return -1;
	  }
	  function map(array, f) {
	    var out = [];
	    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
	    return out;
	  }

	  function createObj(base, props) {
	    var inst;
	    if (Object.create) {
	      inst = Object.create(base);
	    } else {
	      var ctor = function() {};
	      ctor.prototype = base;
	      inst = new ctor();
	    }
	    if (props) copyObj(props, inst);
	    return inst;
	  };

	  function copyObj(obj, target, overwrite) {
	    if (!target) target = {};
	    for (var prop in obj)
	      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
	        target[prop] = obj[prop];
	    return target;
	  }

	  function bind(f) {
	    var args = Array.prototype.slice.call(arguments, 1);
	    return function(){return f.apply(null, args);};
	  }

	  var nonASCIISingleCaseWordChar = /[\u00df\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
	  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
	    return /\w/.test(ch) || ch > "\x80" &&
	      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
	  };
	  function isWordChar(ch, helper) {
	    if (!helper) return isWordCharBasic(ch);
	    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
	    return helper.test(ch);
	  }

	  function isEmpty(obj) {
	    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
	    return true;
	  }

	  // Extending unicode characters. A series of a non-extending char +
	  // any number of extending chars is treated as a single unit as far
	  // as editing and measuring is concerned. This is not fully correct,
	  // since some scripts/fonts/browsers also treat other configurations
	  // of code points as a group.
	  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
	  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

	  // DOM UTILITIES

	  function elt(tag, content, className, style) {
	    var e = document.createElement(tag);
	    if (className) e.className = className;
	    if (style) e.style.cssText = style;
	    if (typeof content == "string") e.appendChild(document.createTextNode(content));
	    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
	    return e;
	  }

	  var range;
	  if (document.createRange) range = function(node, start, end) {
	    var r = document.createRange();
	    r.setEnd(node, end);
	    r.setStart(node, start);
	    return r;
	  };
	  else range = function(node, start, end) {
	    var r = document.body.createTextRange();
	    try { r.moveToElementText(node.parentNode); }
	    catch(e) { return r; }
	    r.collapse(true);
	    r.moveEnd("character", end);
	    r.moveStart("character", start);
	    return r;
	  };

	  function removeChildren(e) {
	    for (var count = e.childNodes.length; count > 0; --count)
	      e.removeChild(e.firstChild);
	    return e;
	  }

	  function removeChildrenAndAdd(parent, e) {
	    return removeChildren(parent).appendChild(e);
	  }

	  var contains = CodeMirror.contains = function(parent, child) {
	    if (parent.contains)
	      return parent.contains(child);
	    while (child = child.parentNode) {
	      if (child.nodeType == 11) child = child.host;
	      if (child == parent) return true;
	    }
	  };

	  function activeElt() { return document.activeElement; }
	  // Older versions of IE throws unspecified error when touching
	  // document.activeElement in some cases (during loading, in iframe)
	  if (ie && ie_version < 11) activeElt = function() {
	    try { return document.activeElement; }
	    catch(e) { return document.body; }
	  };

	  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*"); }
	  var rmClass = CodeMirror.rmClass = function(node, cls) {
	    var current = node.className;
	    var match = classTest(cls).exec(current);
	    if (match) {
	      var after = current.slice(match.index + match[0].length);
	      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
	    }
	  };
	  var addClass = CodeMirror.addClass = function(node, cls) {
	    var current = node.className;
	    if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;
	  };
	  function joinClasses(a, b) {
	    var as = a.split(" ");
	    for (var i = 0; i < as.length; i++)
	      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
	    return b;
	  }

	  // WINDOW-WIDE EVENTS

	  // These must be handled carefully, because naively registering a
	  // handler for each editor will cause the editors to never be
	  // garbage collected.

	  function forEachCodeMirror(f) {
	    if (!document.body.getElementsByClassName) return;
	    var byClass = document.body.getElementsByClassName("CodeMirror");
	    for (var i = 0; i < byClass.length; i++) {
	      var cm = byClass[i].CodeMirror;
	      if (cm) f(cm);
	    }
	  }

	  var globalsRegistered = false;
	  function ensureGlobalHandlers() {
	    if (globalsRegistered) return;
	    registerGlobalHandlers();
	    globalsRegistered = true;
	  }
	  function registerGlobalHandlers() {
	    // When the window resizes, we need to refresh active editors.
	    var resizeTimer;
	    on(window, "resize", function() {
	      if (resizeTimer == null) resizeTimer = setTimeout(function() {
	        resizeTimer = null;
	        forEachCodeMirror(onResize);
	      }, 100);
	    });
	    // When the window loses focus, we want to show the editor as blurred
	    on(window, "blur", function() {
	      forEachCodeMirror(onBlur);
	    });
	  }

	  // FEATURE DETECTION

	  // Detect drag-and-drop
	  var dragAndDrop = function() {
	    // There is *some* kind of drag-and-drop support in IE6-8, but I
	    // couldn't get it to work yet.
	    if (ie && ie_version < 9) return false;
	    var div = elt('div');
	    return "draggable" in div || "dragDrop" in div;
	  }();

	  var zwspSupported;
	  function zeroWidthElement(measure) {
	    if (zwspSupported == null) {
	      var test = elt("span", "\u200b");
	      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
	      if (measure.firstChild.offsetHeight != 0)
	        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
	    }
	    if (zwspSupported) return elt("span", "\u200b");
	    else return elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
	  }

	  // Feature-detect IE's crummy client rect reporting for bidi text
	  var badBidiRects;
	  function hasBadBidiRects(measure) {
	    if (badBidiRects != null) return badBidiRects;
	    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
	    var r0 = range(txt, 0, 1).getBoundingClientRect();
	    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)
	    var r1 = range(txt, 1, 2).getBoundingClientRect();
	    return badBidiRects = (r1.right - r0.right < 3);
	  }

	  // See if "".split is the broken IE version, if so, provide an
	  // alternative way to split lines.
	  var splitLines = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
	    var pos = 0, result = [], l = string.length;
	    while (pos <= l) {
	      var nl = string.indexOf("\n", pos);
	      if (nl == -1) nl = string.length;
	      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
	      var rt = line.indexOf("\r");
	      if (rt != -1) {
	        result.push(line.slice(0, rt));
	        pos += rt + 1;
	      } else {
	        result.push(line);
	        pos = nl + 1;
	      }
	    }
	    return result;
	  } : function(string){return string.split(/\r\n?|\n/);};

	  var hasSelection = window.getSelection ? function(te) {
	    try { return te.selectionStart != te.selectionEnd; }
	    catch(e) { return false; }
	  } : function(te) {
	    try {var range = te.ownerDocument.selection.createRange();}
	    catch(e) {}
	    if (!range || range.parentElement() != te) return false;
	    return range.compareEndPoints("StartToEnd", range) != 0;
	  };

	  var hasCopyEvent = (function() {
	    var e = elt("div");
	    if ("oncopy" in e) return true;
	    e.setAttribute("oncopy", "return;");
	    return typeof e.oncopy == "function";
	  })();

	  var badZoomedRects = null;
	  function hasBadZoomedRects(measure) {
	    if (badZoomedRects != null) return badZoomedRects;
	    var node = removeChildrenAndAdd(measure, elt("span", "x"));
	    var normal = node.getBoundingClientRect();
	    var fromRange = range(node, 0, 1).getBoundingClientRect();
	    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
	  }

	  // KEY NAMES

	  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
	                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
	                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
	                  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",
	                  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
	                  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
	                  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};
	  CodeMirror.keyNames = keyNames;
	  (function() {
	    // Number keys
	    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
	    // Alphabetic keys
	    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
	    // Function keys
	    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
	  })();

	  // BIDI HELPERS

	  function iterateBidiSections(order, from, to, f) {
	    if (!order) return f(from, to, "ltr");
	    var found = false;
	    for (var i = 0; i < order.length; ++i) {
	      var part = order[i];
	      if (part.from < to && part.to > from || from == to && part.to == from) {
	        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
	        found = true;
	      }
	    }
	    if (!found) f(from, to, "ltr");
	  }

	  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
	  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

	  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
	  function lineRight(line) {
	    var order = getOrder(line);
	    if (!order) return line.text.length;
	    return bidiRight(lst(order));
	  }

	  function lineStart(cm, lineN) {
	    var line = getLine(cm.doc, lineN);
	    var visual = visualLine(line);
	    if (visual != line) lineN = lineNo(visual);
	    var order = getOrder(visual);
	    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
	    return Pos(lineN, ch);
	  }
	  function lineEnd(cm, lineN) {
	    var merged, line = getLine(cm.doc, lineN);
	    while (merged = collapsedSpanAtEnd(line)) {
	      line = merged.find(1, true).line;
	      lineN = null;
	    }
	    var order = getOrder(line);
	    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
	    return Pos(lineN == null ? lineNo(line) : lineN, ch);
	  }
	  function lineStartSmart(cm, pos) {
	    var start = lineStart(cm, pos.line);
	    var line = getLine(cm.doc, start.line);
	    var order = getOrder(line);
	    if (!order || order[0].level == 0) {
	      var firstNonWS = Math.max(0, line.text.search(/\S/));
	      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
	      return Pos(start.line, inWS ? 0 : firstNonWS);
	    }
	    return start;
	  }

	  function compareBidiLevel(order, a, b) {
	    var linedir = order[0].level;
	    if (a == linedir) return true;
	    if (b == linedir) return false;
	    return a < b;
	  }
	  var bidiOther;
	  function getBidiPartAt(order, pos) {
	    bidiOther = null;
	    for (var i = 0, found; i < order.length; ++i) {
	      var cur = order[i];
	      if (cur.from < pos && cur.to > pos) return i;
	      if ((cur.from == pos || cur.to == pos)) {
	        if (found == null) {
	          found = i;
	        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
	          if (cur.from != cur.to) bidiOther = found;
	          return i;
	        } else {
	          if (cur.from != cur.to) bidiOther = i;
	          return found;
	        }
	      }
	    }
	    return found;
	  }

	  function moveInLine(line, pos, dir, byUnit) {
	    if (!byUnit) return pos + dir;
	    do pos += dir;
	    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
	    return pos;
	  }

	  // This is needed in order to move 'visually' through bi-directional
	  // text -- i.e., pressing left should make the cursor go left, even
	  // when in RTL text. The tricky part is the 'jumps', where RTL and
	  // LTR text touch each other. This often requires the cursor offset
	  // to move more than one unit, in order to visually move one unit.
	  function moveVisually(line, start, dir, byUnit) {
	    var bidi = getOrder(line);
	    if (!bidi) return moveLogically(line, start, dir, byUnit);
	    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
	    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

	    for (;;) {
	      if (target > part.from && target < part.to) return target;
	      if (target == part.from || target == part.to) {
	        if (getBidiPartAt(bidi, target) == pos) return target;
	        part = bidi[pos += dir];
	        return (dir > 0) == part.level % 2 ? part.to : part.from;
	      } else {
	        part = bidi[pos += dir];
	        if (!part) return null;
	        if ((dir > 0) == part.level % 2)
	          target = moveInLine(line, part.to, -1, byUnit);
	        else
	          target = moveInLine(line, part.from, 1, byUnit);
	      }
	    }
	  }

	  function moveLogically(line, start, dir, byUnit) {
	    var target = start + dir;
	    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
	    return target < 0 || target > line.text.length ? null : target;
	  }

	  // Bidirectional ordering algorithm
	  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
	  // that this (partially) implements.

	  // One-char codes used for character types:
	  // L (L):   Left-to-Right
	  // R (R):   Right-to-Left
	  // r (AL):  Right-to-Left Arabic
	  // 1 (EN):  European Number
	  // + (ES):  European Number Separator
	  // % (ET):  European Number Terminator
	  // n (AN):  Arabic Number
	  // , (CS):  Common Number Separator
	  // m (NSM): Non-Spacing Mark
	  // b (BN):  Boundary Neutral
	  // s (B):   Paragraph Separator
	  // t (S):   Segment Separator
	  // w (WS):  Whitespace
	  // N (ON):  Other Neutrals

	  // Returns null if characters are ordered as they appear
	  // (left-to-right), or an array of sections ({from, to, level}
	  // objects) in the order in which they occur visually.
	  var bidiOrdering = (function() {
	    // Character types for codepoints 0 to 0xff
	    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
	    // Character types for codepoints 0x600 to 0x6ff
	    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
	    function charType(code) {
	      if (code <= 0xf7) return lowTypes.charAt(code);
	      else if (0x590 <= code && code <= 0x5f4) return "R";
	      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
	      else if (0x6ee <= code && code <= 0x8ac) return "r";
	      else if (0x2000 <= code && code <= 0x200b) return "w";
	      else if (code == 0x200c) return "b";
	      else return "L";
	    }

	    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
	    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
	    // Browsers seem to always treat the boundaries of block elements as being L.
	    var outerType = "L";

	    function BidiSpan(level, from, to) {
	      this.level = level;
	      this.from = from; this.to = to;
	    }

	    return function(str) {
	      if (!bidiRE.test(str)) return false;
	      var len = str.length, types = [];
	      for (var i = 0, type; i < len; ++i)
	        types.push(type = charType(str.charCodeAt(i)));

	      // W1. Examine each non-spacing mark (NSM) in the level run, and
	      // change the type of the NSM to the type of the previous
	      // character. If the NSM is at the start of the level run, it will
	      // get the type of sor.
	      for (var i = 0, prev = outerType; i < len; ++i) {
	        var type = types[i];
	        if (type == "m") types[i] = prev;
	        else prev = type;
	      }

	      // W2. Search backwards from each instance of a European number
	      // until the first strong type (R, L, AL, or sor) is found. If an
	      // AL is found, change the type of the European number to Arabic
	      // number.
	      // W3. Change all ALs to R.
	      for (var i = 0, cur = outerType; i < len; ++i) {
	        var type = types[i];
	        if (type == "1" && cur == "r") types[i] = "n";
	        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
	      }

	      // W4. A single European separator between two European numbers
	      // changes to a European number. A single common separator between
	      // two numbers of the same type changes to that type.
	      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
	        var type = types[i];
	        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
	        else if (type == "," && prev == types[i+1] &&
	                 (prev == "1" || prev == "n")) types[i] = prev;
	        prev = type;
	      }

	      // W5. A sequence of European terminators adjacent to European
	      // numbers changes to all European numbers.
	      // W6. Otherwise, separators and terminators change to Other
	      // Neutral.
	      for (var i = 0; i < len; ++i) {
	        var type = types[i];
	        if (type == ",") types[i] = "N";
	        else if (type == "%") {
	          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
	          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
	          for (var j = i; j < end; ++j) types[j] = replace;
	          i = end - 1;
	        }
	      }

	      // W7. Search backwards from each instance of a European number
	      // until the first strong type (R, L, or sor) is found. If an L is
	      // found, then change the type of the European number to L.
	      for (var i = 0, cur = outerType; i < len; ++i) {
	        var type = types[i];
	        if (cur == "L" && type == "1") types[i] = "L";
	        else if (isStrong.test(type)) cur = type;
	      }

	      // N1. A sequence of neutrals takes the direction of the
	      // surrounding strong text if the text on both sides has the same
	      // direction. European and Arabic numbers act as if they were R in
	      // terms of their influence on neutrals. Start-of-level-run (sor)
	      // and end-of-level-run (eor) are used at level run boundaries.
	      // N2. Any remaining neutrals take the embedding direction.
	      for (var i = 0; i < len; ++i) {
	        if (isNeutral.test(types[i])) {
	          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
	          var before = (i ? types[i-1] : outerType) == "L";
	          var after = (end < len ? types[end] : outerType) == "L";
	          var replace = before || after ? "L" : "R";
	          for (var j = i; j < end; ++j) types[j] = replace;
	          i = end - 1;
	        }
	      }

	      // Here we depart from the documented algorithm, in order to avoid
	      // building up an actual levels array. Since there are only three
	      // levels (0, 1, 2) in an implementation that doesn't take
	      // explicit embedding into account, we can build up the order on
	      // the fly, without following the level-based algorithm.
	      var order = [], m;
	      for (var i = 0; i < len;) {
	        if (countsAsLeft.test(types[i])) {
	          var start = i;
	          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
	          order.push(new BidiSpan(0, start, i));
	        } else {
	          var pos = i, at = order.length;
	          for (++i; i < len && types[i] != "L"; ++i) {}
	          for (var j = pos; j < i;) {
	            if (countsAsNum.test(types[j])) {
	              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
	              var nstart = j;
	              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
	              order.splice(at, 0, new BidiSpan(2, nstart, j));
	              pos = j;
	            } else ++j;
	          }
	          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
	        }
	      }
	      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
	        order[0].from = m[0].length;
	        order.unshift(new BidiSpan(0, 0, m[0].length));
	      }
	      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
	        lst(order).to -= m[0].length;
	        order.push(new BidiSpan(0, len - m[0].length, len));
	      }
	      if (order[0].level != lst(order).level)
	        order.push(new BidiSpan(order[0].level, len, len));

	      return order;
	    };
	  })();

	  // THE END

	  CodeMirror.version = "4.13.0";

	  return CodeMirror;
	});


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	// TODO actually recognize syntax of TypeScript constructs

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(1));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";

	CodeMirror.defineMode("javascript", function(config, parserConfig) {
	  var indentUnit = config.indentUnit;
	  var statementIndent = parserConfig.statementIndent;
	  var jsonldMode = parserConfig.jsonld;
	  var jsonMode = parserConfig.json || jsonldMode;
	  var isTS = parserConfig.typescript;
	  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

	  // Tokenizer

	  var keywords = function(){
	    function kw(type) {return {type: type, style: "keyword"};}
	    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
	    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

	    var jsKeywords = {
	      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
	      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C, "debugger": C,
	      "var": kw("var"), "const": kw("var"), "let": kw("var"),
	      "function": kw("function"), "catch": kw("catch"),
	      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
	      "in": operator, "typeof": operator, "instanceof": operator,
	      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
	      "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),
	      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C
	    };

	    // Extend the 'normal' keywords with the TypeScript language extensions
	    if (isTS) {
	      var type = {type: "variable", style: "variable-3"};
	      var tsKeywords = {
	        // object-like things
	        "interface": kw("interface"),
	        "extends": kw("extends"),
	        "constructor": kw("constructor"),

	        // scope modifiers
	        "public": kw("public"),
	        "private": kw("private"),
	        "protected": kw("protected"),
	        "static": kw("static"),

	        // types
	        "string": type, "number": type, "bool": type, "any": type
	      };

	      for (var attr in tsKeywords) {
	        jsKeywords[attr] = tsKeywords[attr];
	      }
	    }

	    return jsKeywords;
	  }();

	  var isOperatorChar = /[+\-*&%=<>!?|~^]/;
	  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

	  function readRegexp(stream) {
	    var escaped = false, next, inSet = false;
	    while ((next = stream.next()) != null) {
	      if (!escaped) {
	        if (next == "/" && !inSet) return;
	        if (next == "[") inSet = true;
	        else if (inSet && next == "]") inSet = false;
	      }
	      escaped = !escaped && next == "\\";
	    }
	  }

	  // Used as scratch variables to communicate multiple values without
	  // consing up tons of objects.
	  var type, content;
	  function ret(tp, style, cont) {
	    type = tp; content = cont;
	    return style;
	  }
	  function tokenBase(stream, state) {
	    var ch = stream.next();
	    if (ch == '"' || ch == "'") {
	      state.tokenize = tokenString(ch);
	      return state.tokenize(stream, state);
	    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
	      return ret("number", "number");
	    } else if (ch == "." && stream.match("..")) {
	      return ret("spread", "meta");
	    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
	      return ret(ch);
	    } else if (ch == "=" && stream.eat(">")) {
	      return ret("=>", "operator");
	    } else if (ch == "0" && stream.eat(/x/i)) {
	      stream.eatWhile(/[\da-f]/i);
	      return ret("number", "number");
	    } else if (/\d/.test(ch)) {
	      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
	      return ret("number", "number");
	    } else if (ch == "/") {
	      if (stream.eat("*")) {
	        state.tokenize = tokenComment;
	        return tokenComment(stream, state);
	      } else if (stream.eat("/")) {
	        stream.skipToEnd();
	        return ret("comment", "comment");
	      } else if (state.lastType == "operator" || state.lastType == "keyword c" ||
	               state.lastType == "sof" || /^[\[{}\(,;:]$/.test(state.lastType)) {
	        readRegexp(stream);
	        stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
	        return ret("regexp", "string-2");
	      } else {
	        stream.eatWhile(isOperatorChar);
	        return ret("operator", "operator", stream.current());
	      }
	    } else if (ch == "`") {
	      state.tokenize = tokenQuasi;
	      return tokenQuasi(stream, state);
	    } else if (ch == "#") {
	      stream.skipToEnd();
	      return ret("error", "error");
	    } else if (isOperatorChar.test(ch)) {
	      stream.eatWhile(isOperatorChar);
	      return ret("operator", "operator", stream.current());
	    } else if (wordRE.test(ch)) {
	      stream.eatWhile(wordRE);
	      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
	      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
	                     ret("variable", "variable", word);
	    }
	  }

	  function tokenString(quote) {
	    return function(stream, state) {
	      var escaped = false, next;
	      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
	        state.tokenize = tokenBase;
	        return ret("jsonld-keyword", "meta");
	      }
	      while ((next = stream.next()) != null) {
	        if (next == quote && !escaped) break;
	        escaped = !escaped && next == "\\";
	      }
	      if (!escaped) state.tokenize = tokenBase;
	      return ret("string", "string");
	    };
	  }

	  function tokenComment(stream, state) {
	    var maybeEnd = false, ch;
	    while (ch = stream.next()) {
	      if (ch == "/" && maybeEnd) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      maybeEnd = (ch == "*");
	    }
	    return ret("comment", "comment");
	  }

	  function tokenQuasi(stream, state) {
	    var escaped = false, next;
	    while ((next = stream.next()) != null) {
	      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
	        state.tokenize = tokenBase;
	        break;
	      }
	      escaped = !escaped && next == "\\";
	    }
	    return ret("quasi", "string-2", stream.current());
	  }

	  var brackets = "([{}])";
	  // This is a crude lookahead trick to try and notice that we're
	  // parsing the argument patterns for a fat-arrow function before we
	  // actually hit the arrow token. It only works if the arrow is on
	  // the same line as the arguments and there's no strange noise
	  // (comments) in between. Fallback is to only notice when we hit the
	  // arrow, and not declare the arguments as locals for the arrow
	  // body.
	  function findFatArrow(stream, state) {
	    if (state.fatArrowAt) state.fatArrowAt = null;
	    var arrow = stream.string.indexOf("=>", stream.start);
	    if (arrow < 0) return;

	    var depth = 0, sawSomething = false;
	    for (var pos = arrow - 1; pos >= 0; --pos) {
	      var ch = stream.string.charAt(pos);
	      var bracket = brackets.indexOf(ch);
	      if (bracket >= 0 && bracket < 3) {
	        if (!depth) { ++pos; break; }
	        if (--depth == 0) break;
	      } else if (bracket >= 3 && bracket < 6) {
	        ++depth;
	      } else if (wordRE.test(ch)) {
	        sawSomething = true;
	      } else if (/["'\/]/.test(ch)) {
	        return;
	      } else if (sawSomething && !depth) {
	        ++pos;
	        break;
	      }
	    }
	    if (sawSomething && !depth) state.fatArrowAt = pos;
	  }

	  // Parser

	  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

	  function JSLexical(indented, column, type, align, prev, info) {
	    this.indented = indented;
	    this.column = column;
	    this.type = type;
	    this.prev = prev;
	    this.info = info;
	    if (align != null) this.align = align;
	  }

	  function inScope(state, varname) {
	    for (var v = state.localVars; v; v = v.next)
	      if (v.name == varname) return true;
	    for (var cx = state.context; cx; cx = cx.prev) {
	      for (var v = cx.vars; v; v = v.next)
	        if (v.name == varname) return true;
	    }
	  }

	  function parseJS(state, style, type, content, stream) {
	    var cc = state.cc;
	    // Communicate our context to the combinators.
	    // (Less wasteful than consing up a hundred closures on every call.)
	    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

	    if (!state.lexical.hasOwnProperty("align"))
	      state.lexical.align = true;

	    while(true) {
	      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
	      if (combinator(type, content)) {
	        while(cc.length && cc[cc.length - 1].lex)
	          cc.pop()();
	        if (cx.marked) return cx.marked;
	        if (type == "variable" && inScope(state, content)) return "variable-2";
	        return style;
	      }
	    }
	  }

	  // Combinator utils

	  var cx = {state: null, column: null, marked: null, cc: null};
	  function pass() {
	    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
	  }
	  function cont() {
	    pass.apply(null, arguments);
	    return true;
	  }
	  function register(varname) {
	    function inList(list) {
	      for (var v = list; v; v = v.next)
	        if (v.name == varname) return true;
	      return false;
	    }
	    var state = cx.state;
	    if (state.context) {
	      cx.marked = "def";
	      if (inList(state.localVars)) return;
	      state.localVars = {name: varname, next: state.localVars};
	    } else {
	      if (inList(state.globalVars)) return;
	      if (parserConfig.globalVars)
	        state.globalVars = {name: varname, next: state.globalVars};
	    }
	  }

	  // Combinators

	  var defaultVars = {name: "this", next: {name: "arguments"}};
	  function pushcontext() {
	    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
	    cx.state.localVars = defaultVars;
	  }
	  function popcontext() {
	    cx.state.localVars = cx.state.context.vars;
	    cx.state.context = cx.state.context.prev;
	  }
	  function pushlex(type, info) {
	    var result = function() {
	      var state = cx.state, indent = state.indented;
	      if (state.lexical.type == "stat") indent = state.lexical.indented;
	      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
	        indent = outer.indented;
	      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
	    };
	    result.lex = true;
	    return result;
	  }
	  function poplex() {
	    var state = cx.state;
	    if (state.lexical.prev) {
	      if (state.lexical.type == ")")
	        state.indented = state.lexical.indented;
	      state.lexical = state.lexical.prev;
	    }
	  }
	  poplex.lex = true;

	  function expect(wanted) {
	    function exp(type) {
	      if (type == wanted) return cont();
	      else if (wanted == ";") return pass();
	      else return cont(exp);
	    };
	    return exp;
	  }

	  function statement(type, value) {
	    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
	    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
	    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
	    if (type == "{") return cont(pushlex("}"), block, poplex);
	    if (type == ";") return cont();
	    if (type == "if") {
	      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
	        cx.state.cc.pop()();
	      return cont(pushlex("form"), expression, statement, poplex, maybeelse);
	    }
	    if (type == "function") return cont(functiondef);
	    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
	    if (type == "variable") return cont(pushlex("stat"), maybelabel);
	    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
	                                      block, poplex, poplex);
	    if (type == "case") return cont(expression, expect(":"));
	    if (type == "default") return cont(expect(":"));
	    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
	                                     statement, poplex, popcontext);
	    if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);
	    if (type == "class") return cont(pushlex("form"), className, poplex);
	    if (type == "export") return cont(pushlex("form"), afterExport, poplex);
	    if (type == "import") return cont(pushlex("form"), afterImport, poplex);
	    return pass(pushlex("stat"), expression, expect(";"), poplex);
	  }
	  function expression(type) {
	    return expressionInner(type, false);
	  }
	  function expressionNoComma(type) {
	    return expressionInner(type, true);
	  }
	  function expressionInner(type, noComma) {
	    if (cx.state.fatArrowAt == cx.stream.start) {
	      var body = noComma ? arrowBodyNoComma : arrowBody;
	      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
	      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
	    }

	    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
	    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
	    if (type == "function") return cont(functiondef, maybeop);
	    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
	    if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
	    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
	    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
	    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
	    if (type == "quasi") { return pass(quasi, maybeop); }
	    return cont();
	  }
	  function maybeexpression(type) {
	    if (type.match(/[;\}\)\],]/)) return pass();
	    return pass(expression);
	  }
	  function maybeexpressionNoComma(type) {
	    if (type.match(/[;\}\)\],]/)) return pass();
	    return pass(expressionNoComma);
	  }

	  function maybeoperatorComma(type, value) {
	    if (type == ",") return cont(expression);
	    return maybeoperatorNoComma(type, value, false);
	  }
	  function maybeoperatorNoComma(type, value, noComma) {
	    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
	    var expr = noComma == false ? expression : expressionNoComma;
	    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
	    if (type == "operator") {
	      if (/\+\+|--/.test(value)) return cont(me);
	      if (value == "?") return cont(expression, expect(":"), expr);
	      return cont(expr);
	    }
	    if (type == "quasi") { return pass(quasi, me); }
	    if (type == ";") return;
	    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
	    if (type == ".") return cont(property, me);
	    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
	  }
	  function quasi(type, value) {
	    if (type != "quasi") return pass();
	    if (value.slice(value.length - 2) != "${") return cont(quasi);
	    return cont(expression, continueQuasi);
	  }
	  function continueQuasi(type) {
	    if (type == "}") {
	      cx.marked = "string-2";
	      cx.state.tokenize = tokenQuasi;
	      return cont(quasi);
	    }
	  }
	  function arrowBody(type) {
	    findFatArrow(cx.stream, cx.state);
	    return pass(type == "{" ? statement : expression);
	  }
	  function arrowBodyNoComma(type) {
	    findFatArrow(cx.stream, cx.state);
	    return pass(type == "{" ? statement : expressionNoComma);
	  }
	  function maybelabel(type) {
	    if (type == ":") return cont(poplex, statement);
	    return pass(maybeoperatorComma, expect(";"), poplex);
	  }
	  function property(type) {
	    if (type == "variable") {cx.marked = "property"; return cont();}
	  }
	  function objprop(type, value) {
	    if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property";
	      if (value == "get" || value == "set") return cont(getterSetter);
	      return cont(afterprop);
	    } else if (type == "number" || type == "string") {
	      cx.marked = jsonldMode ? "property" : (cx.style + " property");
	      return cont(afterprop);
	    } else if (type == "jsonld-keyword") {
	      return cont(afterprop);
	    } else if (type == "[") {
	      return cont(expression, expect("]"), afterprop);
	    }
	  }
	  function getterSetter(type) {
	    if (type != "variable") return pass(afterprop);
	    cx.marked = "property";
	    return cont(functiondef);
	  }
	  function afterprop(type) {
	    if (type == ":") return cont(expressionNoComma);
	    if (type == "(") return pass(functiondef);
	  }
	  function commasep(what, end) {
	    function proceed(type) {
	      if (type == ",") {
	        var lex = cx.state.lexical;
	        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
	        return cont(what, proceed);
	      }
	      if (type == end) return cont();
	      return cont(expect(end));
	    }
	    return function(type) {
	      if (type == end) return cont();
	      return pass(what, proceed);
	    };
	  }
	  function contCommasep(what, end, info) {
	    for (var i = 3; i < arguments.length; i++)
	      cx.cc.push(arguments[i]);
	    return cont(pushlex(end, info), commasep(what, end), poplex);
	  }
	  function block(type) {
	    if (type == "}") return cont();
	    return pass(statement, block);
	  }
	  function maybetype(type) {
	    if (isTS && type == ":") return cont(typedef);
	  }
	  function typedef(type) {
	    if (type == "variable"){cx.marked = "variable-3"; return cont();}
	  }
	  function vardef() {
	    return pass(pattern, maybetype, maybeAssign, vardefCont);
	  }
	  function pattern(type, value) {
	    if (type == "variable") { register(value); return cont(); }
	    if (type == "[") return contCommasep(pattern, "]");
	    if (type == "{") return contCommasep(proppattern, "}");
	  }
	  function proppattern(type, value) {
	    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
	      register(value);
	      return cont(maybeAssign);
	    }
	    if (type == "variable") cx.marked = "property";
	    return cont(expect(":"), pattern, maybeAssign);
	  }
	  function maybeAssign(_type, value) {
	    if (value == "=") return cont(expressionNoComma);
	  }
	  function vardefCont(type) {
	    if (type == ",") return cont(vardef);
	  }
	  function maybeelse(type, value) {
	    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
	  }
	  function forspec(type) {
	    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
	  }
	  function forspec1(type) {
	    if (type == "var") return cont(vardef, expect(";"), forspec2);
	    if (type == ";") return cont(forspec2);
	    if (type == "variable") return cont(formaybeinof);
	    return pass(expression, expect(";"), forspec2);
	  }
	  function formaybeinof(_type, value) {
	    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
	    return cont(maybeoperatorComma, forspec2);
	  }
	  function forspec2(type, value) {
	    if (type == ";") return cont(forspec3);
	    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
	    return pass(expression, expect(";"), forspec3);
	  }
	  function forspec3(type) {
	    if (type != ")") cont(expression);
	  }
	  function functiondef(type, value) {
	    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
	    if (type == "variable") {register(value); return cont(functiondef);}
	    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);
	  }
	  function funarg(type) {
	    if (type == "spread") return cont(funarg);
	    return pass(pattern, maybetype);
	  }
	  function className(type, value) {
	    if (type == "variable") {register(value); return cont(classNameAfter);}
	  }
	  function classNameAfter(type, value) {
	    if (value == "extends") return cont(expression, classNameAfter);
	    if (type == "{") return cont(pushlex("}"), classBody, poplex);
	  }
	  function classBody(type, value) {
	    if (type == "variable" || cx.style == "keyword") {
	      cx.marked = "property";
	      if (value == "get" || value == "set") return cont(classGetterSetter, functiondef, classBody);
	      return cont(functiondef, classBody);
	    }
	    if (value == "*") {
	      cx.marked = "keyword";
	      return cont(classBody);
	    }
	    if (type == ";") return cont(classBody);
	    if (type == "}") return cont();
	  }
	  function classGetterSetter(type) {
	    if (type != "variable") return pass();
	    cx.marked = "property";
	    return cont();
	  }
	  function afterModule(type, value) {
	    if (type == "string") return cont(statement);
	    if (type == "variable") { register(value); return cont(maybeFrom); }
	  }
	  function afterExport(_type, value) {
	    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
	    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
	    return pass(statement);
	  }
	  function afterImport(type) {
	    if (type == "string") return cont();
	    return pass(importSpec, maybeFrom);
	  }
	  function importSpec(type, value) {
	    if (type == "{") return contCommasep(importSpec, "}");
	    if (type == "variable") register(value);
	    return cont();
	  }
	  function maybeFrom(_type, value) {
	    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
	  }
	  function arrayLiteral(type) {
	    if (type == "]") return cont();
	    return pass(expressionNoComma, maybeArrayComprehension);
	  }
	  function maybeArrayComprehension(type) {
	    if (type == "for") return pass(comprehension, expect("]"));
	    if (type == ",") return cont(commasep(maybeexpressionNoComma, "]"));
	    return pass(commasep(expressionNoComma, "]"));
	  }
	  function comprehension(type) {
	    if (type == "for") return cont(forspec, comprehension);
	    if (type == "if") return cont(expression, comprehension);
	  }

	  function isContinuedStatement(state, textAfter) {
	    return state.lastType == "operator" || state.lastType == "," ||
	      isOperatorChar.test(textAfter.charAt(0)) ||
	      /[,.]/.test(textAfter.charAt(0));
	  }

	  // Interface

	  return {
	    startState: function(basecolumn) {
	      var state = {
	        tokenize: tokenBase,
	        lastType: "sof",
	        cc: [],
	        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
	        localVars: parserConfig.localVars,
	        context: parserConfig.localVars && {vars: parserConfig.localVars},
	        indented: 0
	      };
	      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
	        state.globalVars = parserConfig.globalVars;
	      return state;
	    },

	    token: function(stream, state) {
	      if (stream.sol()) {
	        if (!state.lexical.hasOwnProperty("align"))
	          state.lexical.align = false;
	        state.indented = stream.indentation();
	        findFatArrow(stream, state);
	      }
	      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
	      var style = state.tokenize(stream, state);
	      if (type == "comment") return style;
	      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
	      return parseJS(state, style, type, content, stream);
	    },

	    indent: function(state, textAfter) {
	      if (state.tokenize == tokenComment) return CodeMirror.Pass;
	      if (state.tokenize != tokenBase) return 0;
	      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
	      // Kludge to prevent 'maybelse' from blocking lexical scope pops
	      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
	        var c = state.cc[i];
	        if (c == poplex) lexical = lexical.prev;
	        else if (c != maybeelse) break;
	      }
	      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
	      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
	        lexical = lexical.prev;
	      var type = lexical.type, closing = firstChar == type;

	      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
	      else if (type == "form" && firstChar == "{") return lexical.indented;
	      else if (type == "form") return lexical.indented + indentUnit;
	      else if (type == "stat")
	        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
	      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
	        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
	      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
	      else return lexical.indented + (closing ? 0 : indentUnit);
	    },

	    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
	    blockCommentStart: jsonMode ? null : "/*",
	    blockCommentEnd: jsonMode ? null : "*/",
	    lineComment: jsonMode ? null : "//",
	    fold: "brace",

	    helperType: jsonMode ? "json" : "javascript",
	    jsonldMode: jsonldMode,
	    jsonMode: jsonMode
	  };
	});

	CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

	CodeMirror.defineMIME("text/javascript", "javascript");
	CodeMirror.defineMIME("text/ecmascript", "javascript");
	CodeMirror.defineMIME("application/javascript", "javascript");
	CodeMirror.defineMIME("application/x-javascript", "javascript");
	CodeMirror.defineMIME("application/ecmascript", "javascript");
	CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
	CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
	CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
	CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
	CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

	});


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(1));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  CodeMirror.defineOption("showTrailingSpace", false, function(cm, val, prev) {
	    if (prev == CodeMirror.Init) prev = false;
	    if (prev && !val)
	      cm.removeOverlay("trailingspace");
	    else if (!prev && val)
	      cm.addOverlay({
	        token: function(stream) {
	          for (var l = stream.string.length, i = l; i && /\s/.test(stream.string.charAt(i - 1)); --i) {}
	          if (i > stream.pos) { stream.pos = i; return null; }
	          stream.pos = l;
	          return "trailingspace";
	        },
	        name: "trailingspace"
	      });
	  });
	});


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(1));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) &&
	    (document.documentMode == null || document.documentMode < 8);

	  var Pos = CodeMirror.Pos;

	  var matching = {"(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<"};

	  function findMatchingBracket(cm, where, strict, config) {
	    var line = cm.getLineHandle(where.line), pos = where.ch - 1;
	    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];
	    if (!match) return null;
	    var dir = match.charAt(1) == ">" ? 1 : -1;
	    if (strict && (dir > 0) != (pos == where.ch)) return null;
	    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));

	    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);
	    if (found == null) return null;
	    return {from: Pos(where.line, pos), to: found && found.pos,
	            match: found && found.ch == match.charAt(0), forward: dir > 0};
	  }

	  // bracketRegex is used to specify which type of bracket to scan
	  // should be a regexp, e.g. /[[\]]/
	  //
	  // Note: If "where" is on an open bracket, then this bracket is ignored.
	  //
	  // Returns false when no bracket was found, null when it reached
	  // maxScanLines and gave up
	  function scanForBracket(cm, where, dir, style, config) {
	    var maxScanLen = (config && config.maxScanLineLength) || 10000;
	    var maxScanLines = (config && config.maxScanLines) || 1000;

	    var stack = [];
	    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\]]/;
	    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)
	                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
	    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
	      var line = cm.getLine(lineNo);
	      if (!line) continue;
	      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;
	      if (line.length > maxScanLen) continue;
	      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);
	      for (; pos != end; pos += dir) {
	        var ch = line.charAt(pos);
	        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {
	          var match = matching[ch];
	          if ((match.charAt(1) == ">") == (dir > 0)) stack.push(ch);
	          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};
	          else stack.pop();
	        }
	      }
	    }
	    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
	  }

	  function matchBrackets(cm, autoclear, config) {
	    // Disable brace matching in long lines, since it'll cause hugely slow updates
	    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
	    var marks = [], ranges = cm.listSelections();
	    for (var i = 0; i < ranges.length; i++) {
	      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);
	      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {
	        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
	        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));
	        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)
	          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));
	      }
	    }

	    if (marks.length) {
	      // Kludge to work around the IE bug from issue #1193, where text
	      // input stops going to the textare whever this fires.
	      if (ie_lt8 && cm.state.focused) cm.display.input.focus();

	      var clear = function() {
	        cm.operation(function() {
	          for (var i = 0; i < marks.length; i++) marks[i].clear();
	        });
	      };
	      if (autoclear) setTimeout(clear, 800);
	      else return clear;
	    }
	  }

	  var currentlyHighlighted = null;
	  function doMatchBrackets(cm) {
	    cm.operation(function() {
	      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}
	      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
	    });
	  }

	  CodeMirror.defineOption("matchBrackets", false, function(cm, val, old) {
	    if (old && old != CodeMirror.Init)
	      cm.off("cursorActivity", doMatchBrackets);
	    if (val) {
	      cm.state.matchBrackets = typeof val == "object" ? val : {};
	      cm.on("cursorActivity", doMatchBrackets);
	    }
	  });

	  CodeMirror.defineExtension("matchBrackets", function() {matchBrackets(this, true);});
	  CodeMirror.defineExtension("findMatchingBracket", function(pos, strict, config){
	    return findMatchingBracket(this, pos, strict, config);
	  });
	  CodeMirror.defineExtension("scanForBracket", function(pos, dir, style, config){
	    return scanForBracket(this, pos, dir, style, config);
	  });
	});


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(1));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  var DEFAULT_BRACKETS = "()[]{}''\"\"";
	  var DEFAULT_TRIPLES = "'\"";
	  var DEFAULT_EXPLODE_ON_ENTER = "[]{}";
	  var SPACE_CHAR_REGEX = /\s/;

	  var Pos = CodeMirror.Pos;

	  CodeMirror.defineOption("autoCloseBrackets", false, function(cm, val, old) {
	    if (old != CodeMirror.Init && old)
	      cm.removeKeyMap("autoCloseBrackets");
	    if (!val) return;
	    var pairs = DEFAULT_BRACKETS, triples = DEFAULT_TRIPLES, explode = DEFAULT_EXPLODE_ON_ENTER;
	    if (typeof val == "string") pairs = val;
	    else if (typeof val == "object") {
	      if (val.pairs != null) pairs = val.pairs;
	      if (val.triples != null) triples = val.triples;
	      if (val.explode != null) explode = val.explode;
	    }
	    var map = buildKeymap(pairs, triples);
	    if (explode) map.Enter = buildExplodeHandler(explode);
	    cm.addKeyMap(map);
	  });

	  function charsAround(cm, pos) {
	    var str = cm.getRange(Pos(pos.line, pos.ch - 1),
	                          Pos(pos.line, pos.ch + 1));
	    return str.length == 2 ? str : null;
	  }

	  // Project the token type that will exists after the given char is
	  // typed, and use it to determine whether it would cause the start
	  // of a string token.
	  function enteringString(cm, pos, ch) {
	    var line = cm.getLine(pos.line);
	    var token = cm.getTokenAt(pos);
	    if (/\bstring2?\b/.test(token.type)) return false;
	    var stream = new CodeMirror.StringStream(line.slice(0, pos.ch) + ch + line.slice(pos.ch), 4);
	    stream.pos = stream.start = token.start;
	    for (;;) {
	      var type1 = cm.getMode().token(stream, token.state);
	      if (stream.pos >= pos.ch + 1) return /\bstring2?\b/.test(type1);
	      stream.start = stream.pos;
	    }
	  }

	  function buildKeymap(pairs, triples) {
	    var map = {
	      name : "autoCloseBrackets",
	      Backspace: function(cm) {
	        if (cm.getOption("disableInput")) return CodeMirror.Pass;
	        var ranges = cm.listSelections();
	        for (var i = 0; i < ranges.length; i++) {
	          if (!ranges[i].empty()) return CodeMirror.Pass;
	          var around = charsAround(cm, ranges[i].head);
	          if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
	        }
	        for (var i = ranges.length - 1; i >= 0; i--) {
	          var cur = ranges[i].head;
	          cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
	        }
	      }
	    };
	    var closingBrackets = "";
	    for (var i = 0; i < pairs.length; i += 2) (function(left, right) {
	      closingBrackets += right;
	      map["'" + left + "'"] = function(cm) {
	        if (cm.getOption("disableInput")) return CodeMirror.Pass;
	        var ranges = cm.listSelections(), type, next;
	        for (var i = 0; i < ranges.length; i++) {
	          var range = ranges[i], cur = range.head, curType;
	          var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
	          if (!range.empty()) {
	            curType = "surround";
	          } else if (left == right && next == right) {
	            if (cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == left + left + left)
	              curType = "skipThree";
	            else
	              curType = "skip";
	          } else if (left == right && cur.ch > 1 && triples.indexOf(left) >= 0 &&
	                     cm.getRange(Pos(cur.line, cur.ch - 2), cur) == left + left &&
	                     (cur.ch <= 2 || cm.getRange(Pos(cur.line, cur.ch - 3), Pos(cur.line, cur.ch - 2)) != left)) {
	            curType = "addFour";
	          } else if (left == '"' || left == "'") {
	            if (!CodeMirror.isWordChar(next) && enteringString(cm, cur, left)) curType = "both";
	            else return CodeMirror.Pass;
	          } else if (cm.getLine(cur.line).length == cur.ch || closingBrackets.indexOf(next) >= 0 || SPACE_CHAR_REGEX.test(next)) {
	            curType = "both";
	          } else {
	            return CodeMirror.Pass;
	          }
	          if (!type) type = curType;
	          else if (type != curType) return CodeMirror.Pass;
	        }

	        cm.operation(function() {
	          if (type == "skip") {
	            cm.execCommand("goCharRight");
	          } else if (type == "skipThree") {
	            for (var i = 0; i < 3; i++)
	              cm.execCommand("goCharRight");
	          } else if (type == "surround") {
	            var sels = cm.getSelections();
	            for (var i = 0; i < sels.length; i++)
	              sels[i] = left + sels[i] + right;
	            cm.replaceSelections(sels, "around");
	          } else if (type == "both") {
	            cm.replaceSelection(left + right, null);
	            cm.execCommand("goCharLeft");
	          } else if (type == "addFour") {
	            cm.replaceSelection(left + left + left + left, "before");
	            cm.execCommand("goCharRight");
	          }
	        });
	      };
	      if (left != right) map["'" + right + "'"] = function(cm) {
	        var ranges = cm.listSelections();
	        for (var i = 0; i < ranges.length; i++) {
	          var range = ranges[i];
	          if (!range.empty() ||
	              cm.getRange(range.head, Pos(range.head.line, range.head.ch + 1)) != right)
	            return CodeMirror.Pass;
	        }
	        cm.execCommand("goCharRight");
	      };
	    })(pairs.charAt(i), pairs.charAt(i + 1));
	    return map;
	  }

	  function buildExplodeHandler(pairs) {
	    return function(cm) {
	      if (cm.getOption("disableInput")) return CodeMirror.Pass;
	      var ranges = cm.listSelections();
	      for (var i = 0; i < ranges.length; i++) {
	        if (!ranges[i].empty()) return CodeMirror.Pass;
	        var around = charsAround(cm, ranges[i].head);
	        if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
	      }
	      cm.operation(function() {
	        cm.replaceSelection("\n\n", null);
	        cm.execCommand("goCharLeft");
	        ranges = cm.listSelections();
	        for (var i = 0; i < ranges.length; i++) {
	          var line = ranges[i].head.line;
	          cm.indentLine(line, null, true);
	          cm.indentLine(line + 1, null, true);
	        }
	      });
	    };
	  }
	});


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(1));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	  var GUTTER_ID = "CodeMirror-lint-markers";

	  function showTooltip(e, content) {
	    var tt = document.createElement("div");
	    tt.className = "CodeMirror-lint-tooltip";
	    tt.appendChild(content.cloneNode(true));
	    document.body.appendChild(tt);

	    function position(e) {
	      if (!tt.parentNode) return CodeMirror.off(document, "mousemove", position);
	      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + "px";
	      tt.style.left = (e.clientX + 5) + "px";
	    }
	    CodeMirror.on(document, "mousemove", position);
	    position(e);
	    if (tt.style.opacity != null) tt.style.opacity = 1;
	    return tt;
	  }
	  function rm(elt) {
	    if (elt.parentNode) elt.parentNode.removeChild(elt);
	  }
	  function hideTooltip(tt) {
	    if (!tt.parentNode) return;
	    if (tt.style.opacity == null) rm(tt);
	    tt.style.opacity = 0;
	    setTimeout(function() { rm(tt); }, 600);
	  }

	  function showTooltipFor(e, content, node) {
	    var tooltip = showTooltip(e, content);
	    function hide() {
	      CodeMirror.off(node, "mouseout", hide);
	      if (tooltip) { hideTooltip(tooltip); tooltip = null; }
	    }
	    var poll = setInterval(function() {
	      if (tooltip) for (var n = node;; n = n.parentNode) {
	        if (n && n.nodeType == 11) n = n.host;
	        if (n == document.body) return;
	        if (!n) { hide(); break; }
	      }
	      if (!tooltip) return clearInterval(poll);
	    }, 400);
	    CodeMirror.on(node, "mouseout", hide);
	  }

	  function LintState(cm, options, hasGutter) {
	    this.marked = [];
	    this.options = options;
	    this.timeout = null;
	    this.hasGutter = hasGutter;
	    this.onMouseOver = function(e) { onMouseOver(cm, e); };
	  }

	  function parseOptions(cm, options) {
	    if (options instanceof Function) return {getAnnotations: options};
	    if (!options || options === true) options = {};
	    if (!options.getAnnotations) options.getAnnotations = cm.getHelper(CodeMirror.Pos(0, 0), "lint");
	    if (!options.getAnnotations) throw new Error("Required option 'getAnnotations' missing (lint addon)");
	    return options;
	  }

	  function clearMarks(cm) {
	    var state = cm.state.lint;
	    if (state.hasGutter) cm.clearGutter(GUTTER_ID);
	    for (var i = 0; i < state.marked.length; ++i)
	      state.marked[i].clear();
	    state.marked.length = 0;
	  }

	  function makeMarker(labels, severity, multiple, tooltips) {
	    var marker = document.createElement("div"), inner = marker;
	    marker.className = "CodeMirror-lint-marker-" + severity;
	    if (multiple) {
	      inner = marker.appendChild(document.createElement("div"));
	      inner.className = "CodeMirror-lint-marker-multiple";
	    }

	    if (tooltips != false) CodeMirror.on(inner, "mouseover", function(e) {
	      showTooltipFor(e, labels, inner);
	    });

	    return marker;
	  }

	  function getMaxSeverity(a, b) {
	    if (a == "error") return a;
	    else return b;
	  }

	  function groupByLine(annotations) {
	    var lines = [];
	    for (var i = 0; i < annotations.length; ++i) {
	      var ann = annotations[i], line = ann.from.line;
	      (lines[line] || (lines[line] = [])).push(ann);
	    }
	    return lines;
	  }

	  function annotationTooltip(ann) {
	    var severity = ann.severity;
	    if (!severity) severity = "error";
	    var tip = document.createElement("div");
	    tip.className = "CodeMirror-lint-message-" + severity;
	    tip.appendChild(document.createTextNode(ann.message));
	    return tip;
	  }

	  function startLinting(cm) {
	    var state = cm.state.lint, options = state.options;
	    var passOptions = options.options || options; // Support deprecated passing of `options` property in options
	    if (options.async || options.getAnnotations.async)
	      options.getAnnotations(cm.getValue(), updateLinting, passOptions, cm);
	    else
	      updateLinting(cm, options.getAnnotations(cm.getValue(), passOptions, cm));
	  }

	  function updateLinting(cm, annotationsNotSorted) {
	    clearMarks(cm);
	    var state = cm.state.lint, options = state.options;

	    var annotations = groupByLine(annotationsNotSorted);

	    for (var line = 0; line < annotations.length; ++line) {
	      var anns = annotations[line];
	      if (!anns) continue;

	      var maxSeverity = null;
	      var tipLabel = state.hasGutter && document.createDocumentFragment();

	      for (var i = 0; i < anns.length; ++i) {
	        var ann = anns[i];
	        var severity = ann.severity;
	        if (!severity) severity = "error";
	        maxSeverity = getMaxSeverity(maxSeverity, severity);

	        if (options.formatAnnotation) ann = options.formatAnnotation(ann);
	        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));

	        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
	          className: "CodeMirror-lint-mark-" + severity,
	          __annotation: ann
	        }));
	      }

	      if (state.hasGutter)
	        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,
	                                                       state.options.tooltips));
	    }
	    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
	  }

	  function onChange(cm) {
	    var state = cm.state.lint;
	    clearTimeout(state.timeout);
	    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);
	  }

	  function popupSpanTooltip(ann, e) {
	    var target = e.target || e.srcElement;
	    showTooltipFor(e, annotationTooltip(ann), target);
	  }

	  function onMouseOver(cm, e) {
	    var target = e.target || e.srcElement;
	    if (!/\bCodeMirror-lint-mark-/.test(target.className)) return;
	    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;
	    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, "client"));
	    for (var i = 0; i < spans.length; ++i) {
	      var ann = spans[i].__annotation;
	      if (ann) return popupSpanTooltip(ann, e);
	    }
	  }

	  CodeMirror.defineOption("lint", false, function(cm, val, old) {
	    if (old && old != CodeMirror.Init) {
	      clearMarks(cm);
	      cm.off("change", onChange);
	      CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
	      delete cm.state.lint;
	    }

	    if (val) {
	      var gutters = cm.getOption("gutters"), hasLintGutter = false;
	      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
	      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);
	      cm.on("change", onChange);
	      if (state.options.tooltips != false)
	        CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);

	      startLinting(cm);
	    }
	  });
	});


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(8);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/Users/joshua/dev/gits/mrdoobapproves/node_modules/css-loader/index.js!/Users/joshua/dev/gits/mrdoobapproves/node_modules/codemirror/addon/lint/lint.css", function() {
			var newContent = require("!!/Users/joshua/dev/gits/mrdoobapproves/node_modules/css-loader/index.js!/Users/joshua/dev/gits/mrdoobapproves/node_modules/codemirror/addon/lint/lint.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	exports.push([module.id, "/* The lint marker gutter */\n.CodeMirror-lint-markers {\n  width: 16px;\n}\n\n.CodeMirror-lint-tooltip {\n  background-color: infobackground;\n  border: 1px solid black;\n  border-radius: 4px 4px 4px 4px;\n  color: infotext;\n  font-family: monospace;\n  font-size: 10pt;\n  overflow: hidden;\n  padding: 2px 5px;\n  position: fixed;\n  white-space: pre;\n  white-space: pre-wrap;\n  z-index: 100;\n  max-width: 600px;\n  opacity: 0;\n  transition: opacity .4s;\n  -moz-transition: opacity .4s;\n  -webkit-transition: opacity .4s;\n  -o-transition: opacity .4s;\n  -ms-transition: opacity .4s;\n}\n\n.CodeMirror-lint-mark-error, .CodeMirror-lint-mark-warning {\n  background-position: left bottom;\n  background-repeat: repeat-x;\n}\n\n.CodeMirror-lint-mark-error {\n  background-image:\n  url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\")\n  ;\n}\n\n.CodeMirror-lint-mark-warning {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\");\n}\n\n.CodeMirror-lint-marker-error, .CodeMirror-lint-marker-warning {\n  background-position: center center;\n  background-repeat: no-repeat;\n  cursor: pointer;\n  display: inline-block;\n  height: 16px;\n  width: 16px;\n  vertical-align: middle;\n  position: relative;\n}\n\n.CodeMirror-lint-message-error, .CodeMirror-lint-message-warning {\n  padding-left: 18px;\n  background-position: top left;\n  background-repeat: no-repeat;\n}\n\n.CodeMirror-lint-marker-error, .CodeMirror-lint-message-error {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\");\n}\n\n.CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\");\n}\n\n.CodeMirror-lint-marker-multiple {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\");\n  background-repeat: no-repeat;\n  background-position: right bottom;\n  width: 100%; height: 100%;\n}\n", ""]);

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = function() {
		var list = [];
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
		return list;
	}

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isIE9 = memoize(function() {
			return /msie 9\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0;

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isIE9();

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function createStyleElement() {
		var styleElement = document.createElement("style");
		var head = getHeadElement();
		styleElement.type = "text/css";
		head.appendChild(styleElement);
		return styleElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement());
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else {
			styleElement = createStyleElement();
			update = applyToTag.bind(null, styleElement);
			remove = function () {
				styleElement.parentNode.removeChild(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	function replaceText(source, id, replacement) {
		var boundaries = ["/** >>" + id + " **/", "/** " + id + "<< **/"];
		var start = source.lastIndexOf(boundaries[0]);
		var wrappedReplacement = replacement
			? (boundaries[0] + replacement + boundaries[1])
			: "";
		if (source.lastIndexOf(boundaries[0]) >= 0) {
			var end = source.lastIndexOf(boundaries[1]) + boundaries[1].length;
			return source.slice(0, start) + wrappedReplacement + source.slice(end);
		} else {
			return source + wrappedReplacement;
		}
	}

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(styleElement.styleSheet.cssText, index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if(sourceMap && typeof btoa === "function") {
			try {
				css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(JSON.stringify(sourceMap)) + " */";
				css = "@import url(\"data:text/css;base64," + btoa(css) + "\")";
			} catch(e) {}
		}

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(12);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/Users/joshua/dev/gits/mrdoobapproves/node_modules/css-loader/index.js!/Users/joshua/dev/gits/mrdoobapproves/node_modules/codemirror/lib/codemirror.css", function() {
			var newContent = require("!!/Users/joshua/dev/gits/mrdoobapproves/node_modules/css-loader/index.js!/Users/joshua/dev/gits/mrdoobapproves/node_modules/codemirror/lib/codemirror.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	exports.push([module.id, "/* BASICS */\n\n.CodeMirror {\n  /* Set height, width, borders, and global font properties here */\n  font-family: monospace;\n  height: 300px;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n  padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre {\n  padding: 0 4px; /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  background-color: white; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n  border-right: 1px solid #ddd;\n  background-color: #f7f7f7;\n  white-space: nowrap;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n  padding: 0 3px 0 5px;\n  min-width: 20px;\n  text-align: right;\n  color: #999;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n.CodeMirror-guttermarker { color: black; }\n.CodeMirror-guttermarker-subtle { color: #999; }\n\n/* CURSOR */\n\n.CodeMirror div.CodeMirror-cursor {\n  border-left: 1px solid black;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n  border-left: 1px solid silver;\n}\n.CodeMirror.cm-fat-cursor div.CodeMirror-cursor {\n  width: auto;\n  border: 0;\n  background: #7e7;\n}\n.CodeMirror.cm-fat-cursor div.CodeMirror-cursors {\n  z-index: 1;\n}\n\n.cm-animate-fat-cursor {\n  width: auto;\n  border: 0;\n  -webkit-animation: blink 1.06s steps(1) infinite;\n  -moz-animation: blink 1.06s steps(1) infinite;\n  animation: blink 1.06s steps(1) infinite;\n}\n@-moz-keyframes blink {\n  0% { background: #7e7; }\n  50% { background: none; }\n  100% { background: #7e7; }\n}\n@-webkit-keyframes blink {\n  0% { background: #7e7; }\n  50% { background: none; }\n  100% { background: #7e7; }\n}\n@keyframes blink {\n  0% { background: #7e7; }\n  50% { background: none; }\n  100% { background: #7e7; }\n}\n\n/* Can style cursor different in overwrite (non-insert) mode */\ndiv.CodeMirror-overwrite div.CodeMirror-cursor {}\n\n.cm-tab { display: inline-block; text-decoration: inherit; }\n\n.CodeMirror-ruler {\n  border-left: 1px solid #ccc;\n  position: absolute;\n}\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable,\n.cm-s-default .cm-punctuation,\n.cm-s-default .cm-property,\n.cm-s-default .cm-operator {}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3 {color: #085;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n.cm-strikethrough {text-decoration: line-through;}\n\n.cm-s-default .cm-error {color: #f00;}\n.cm-invalidchar {color: #f00;}\n\n/* Default styles for common addons */\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\n.CodeMirror-activeline-background {background: #e8f2ff;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\n   the editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n  line-height: 1;\n  position: relative;\n  overflow: hidden;\n  background: white;\n  color: black;\n}\n\n.CodeMirror-scroll {\n  overflow: scroll !important; /* Things will break if this is overridden */\n  /* 30px is the magic margin used to hide the element's real scrollbars */\n  /* See overflow: hidden in .CodeMirror */\n  margin-bottom: -30px; margin-right: -30px;\n  padding-bottom: 30px;\n  height: 100%;\n  outline: none; /* Prevent dragging from highlighting the element */\n  position: relative;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n.CodeMirror-sizer {\n  position: relative;\n  border-right: 30px solid transparent;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\n   before actuall scrolling happens, thus preventing shaking and\n   flickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  position: absolute;\n  z-index: 6;\n  display: none;\n}\n.CodeMirror-vscrollbar {\n  right: 0; top: 0;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n  bottom: 0; left: 0;\n  overflow-y: hidden;\n  overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n  right: 0; bottom: 0;\n}\n.CodeMirror-gutter-filler {\n  left: 0; bottom: 0;\n}\n\n.CodeMirror-gutters {\n  position: absolute; left: 0; top: 0;\n  z-index: 3;\n}\n.CodeMirror-gutter {\n  white-space: normal;\n  height: 100%;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n  display: inline-block;\n  margin-bottom: -30px;\n  /* Hack to make IE7 behave */\n  *zoom:1;\n  *display:inline;\n}\n.CodeMirror-gutter-wrapper {\n  position: absolute;\n  z-index: 4;\n  height: 100%;\n}\n.CodeMirror-gutter-elt {\n  position: absolute;\n  cursor: default;\n  z-index: 4;\n}\n\n.CodeMirror-lines {\n  cursor: text;\n  min-height: 1px; /* prevents collapsing before first draw */\n}\n.CodeMirror pre {\n  /* Reset some styles that the rest of the page might have set */\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n  border-width: 0;\n  background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n  line-height: inherit;\n  color: inherit;\n  z-index: 2;\n  position: relative;\n  overflow: visible;\n}\n.CodeMirror-wrap pre {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: normal;\n}\n\n.CodeMirror-linebackground {\n  position: absolute;\n  left: 0; right: 0; top: 0; bottom: 0;\n  z-index: 0;\n}\n\n.CodeMirror-linewidget {\n  position: relative;\n  z-index: 2;\n  overflow: auto;\n}\n\n.CodeMirror-widget {}\n\n.CodeMirror-measure {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n.CodeMirror-measure pre { position: static; }\n\n.CodeMirror div.CodeMirror-cursor {\n  position: absolute;\n  border-right: none;\n  width: 0;\n}\n\ndiv.CodeMirror-cursors {\n  visibility: hidden;\n  position: relative;\n  z-index: 3;\n}\n.CodeMirror-focused div.CodeMirror-cursors {\n  visibility: visible;\n}\n\n.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\n.CodeMirror-crosshair { cursor: crosshair; }\n\n.cm-searching {\n  background: #ffa;\n  background: rgba(255, 255, 0, .4);\n}\n\n/* IE7 hack to prevent it from returning funny offsetTops on the spans */\n.CodeMirror span { *vertical-align: text-bottom; }\n\n/* Used to force a border model for a node */\n.cm-force-border { padding-right: .1px; }\n\n@media print {\n  /* Hide the cursor when printing */\n  .CodeMirror div.CodeMirror-cursors {\n    visibility: hidden;\n  }\n}\n\n/* See issue #2901 */\n.cm-tab-wrap-hack:after { content: ''; }\n\n/* Help users use markselection to safely style text background */\nspan.CodeMirror-selectedtext { background: none; }\n", ""]);

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(14);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		module.hot.accept("!!/Users/joshua/dev/gits/mrdoobapproves/node_modules/css-loader/index.js!/Users/joshua/dev/gits/mrdoobapproves/node_modules/codemirror/addon/merge/merge.css", function() {
			var newContent = require("!!/Users/joshua/dev/gits/mrdoobapproves/node_modules/css-loader/index.js!/Users/joshua/dev/gits/mrdoobapproves/node_modules/codemirror/addon/merge/merge.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	exports.push([module.id, ".CodeMirror-merge {\n  position: relative;\n  border: 1px solid #ddd;\n  white-space: pre;\n}\n\n.CodeMirror-merge, .CodeMirror-merge .CodeMirror {\n  height: 350px;\n}\n\n.CodeMirror-merge-2pane .CodeMirror-merge-pane { width: 47%; }\n.CodeMirror-merge-2pane .CodeMirror-merge-gap { width: 6%; }\n.CodeMirror-merge-3pane .CodeMirror-merge-pane { width: 31%; }\n.CodeMirror-merge-3pane .CodeMirror-merge-gap { width: 3.5%; }\n\n.CodeMirror-merge-pane {\n  display: inline-block;\n  white-space: normal;\n  vertical-align: top;\n}\n.CodeMirror-merge-pane-rightmost {\n  position: absolute;\n  right: 0px;\n  z-index: 1;\n}\n\n.CodeMirror-merge-gap {\n  z-index: 2;\n  display: inline-block;\n  height: 100%;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  overflow: hidden;\n  border-left: 1px solid #ddd;\n  border-right: 1px solid #ddd;\n  position: relative;\n  background: #f8f8f8;\n}\n\n.CodeMirror-merge-scrolllock-wrap {\n  position: absolute;\n  bottom: 0; left: 50%;\n}\n.CodeMirror-merge-scrolllock {\n  position: relative;\n  left: -50%;\n  cursor: pointer;\n  color: #555;\n  line-height: 1;\n}\n\n.CodeMirror-merge-copybuttons-left, .CodeMirror-merge-copybuttons-right {\n  position: absolute;\n  left: 0; top: 0;\n  right: 0; bottom: 0;\n  line-height: 1;\n}\n\n.CodeMirror-merge-copy {\n  position: absolute;\n  cursor: pointer;\n  color: #44c;\n}\n\n.CodeMirror-merge-copy-reverse {\n  position: absolute;\n  cursor: pointer;\n  color: #44c;\n}\n\n.CodeMirror-merge-copybuttons-left .CodeMirror-merge-copy { left: 2px; }\n.CodeMirror-merge-copybuttons-right .CodeMirror-merge-copy { right: 2px; }\n\n.CodeMirror-merge-r-inserted, .CodeMirror-merge-l-inserted {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAYAAACddGYaAAAAGUlEQVQI12MwuCXy3+CWyH8GBgYGJgYkAABZbAQ9ELXurwAAAABJRU5ErkJggg==);\n  background-position: bottom left;\n  background-repeat: repeat-x;\n}\n\n.CodeMirror-merge-r-deleted, .CodeMirror-merge-l-deleted {\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAACCAYAAACddGYaAAAAGUlEQVQI12M4Kyb2/6yY2H8GBgYGJgYkAABURgPz6Ks7wQAAAABJRU5ErkJggg==);\n  background-position: bottom left;\n  background-repeat: repeat-x;\n}\n\n.CodeMirror-merge-r-chunk { background: #ffffe0; }\n.CodeMirror-merge-r-chunk-start { border-top: 1px solid #ee8; }\n.CodeMirror-merge-r-chunk-end { border-bottom: 1px solid #ee8; }\n.CodeMirror-merge-r-connect { fill: #ffffe0; stroke: #ee8; stroke-width: 1px; }\n\n.CodeMirror-merge-l-chunk { background: #eef; }\n.CodeMirror-merge-l-chunk-start { border-top: 1px solid #88e; }\n.CodeMirror-merge-l-chunk-end { border-bottom: 1px solid #88e; }\n.CodeMirror-merge-l-connect { fill: #eef; stroke: #88e; stroke-width: 1px; }\n\n.CodeMirror-merge-l-chunk.CodeMirror-merge-r-chunk { background: #dfd; }\n.CodeMirror-merge-l-chunk-start.CodeMirror-merge-r-chunk-start { border-top: 1px solid #4e4; }\n.CodeMirror-merge-l-chunk-end.CodeMirror-merge-r-chunk-end { border-bottom: 1px solid #4e4; }\n\n.CodeMirror-merge-collapsed-widget:before {\n  content: \"(...)\";\n}\n.CodeMirror-merge-collapsed-widget {\n  cursor: pointer;\n  color: #88b;\n  background: #eef;\n  border: 1px solid #ddf;\n  font-size: 90%;\n  padding: 0 3px;\n  border-radius: 4px;\n}\n.CodeMirror-merge-collapsed-line .CodeMirror-gutter-elt { display: none; }\n", ""]);

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/// Modified addon/merge.js for use with mdcs

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	// declare global: diff_match_patch, DIFF_INSERT, DIFF_DELETE, DIFF_EQUAL

	(function(mod) {
	  if (true) { // CommonJS
	    mod(__webpack_require__(1), __webpack_require__(16));
	  }
	  else
	  if (typeof define == "function" && define.amd) { // AMD
	    define(["./node_modules/codemirror/lib/codemirror.js",
	      "./bower_components/google-diff-match-patch-js/diff_match_patch.js"], mod);
	  }
	  else {
	    // Plain browser env
	    mod(CodeMirror, diff_match_patch);
	  }
	})(function(CodeMirror, diff_match_patch) {
	  "use strict";
	  var Pos = CodeMirror.Pos;
	  var svgNS = "http://www.w3.org/2000/svg";

	  function DiffView(mv, type) {
	    this.mv = mv;
	    this.type = type;
	    this.classes = type == "left"
	      ? {chunk: "CodeMirror-merge-l-chunk",
	         start: "CodeMirror-merge-l-chunk-start",
	         end: "CodeMirror-merge-l-chunk-end",
	         insert: "CodeMirror-merge-l-inserted",
	         del: "CodeMirror-merge-l-deleted",
	         connect: "CodeMirror-merge-l-connect"}
	      : {chunk: "CodeMirror-merge-r-chunk",
	         start: "CodeMirror-merge-r-chunk-start",
	         end: "CodeMirror-merge-r-chunk-end",
	         insert: "CodeMirror-merge-r-inserted",
	         del: "CodeMirror-merge-r-deleted",
	         connect: "CodeMirror-merge-r-connect"};
	    if (mv.options.connect == "align")
	      this.aligners = [];
	  }

	  DiffView.prototype = {
	    constructor: DiffView,
	    init: function(pane, orig, options) {
	      this.edit = this.mv.edit;
	      this.orig = CodeMirror(pane, copyObj({value: orig, readOnly: !this.mv.options.allowEditingOriginals}, copyObj(options)));

	      this.diff = getDiff(asString(orig), asString(options.value));
	      this.diffOutOfDate = false;

	      this.showDifferences = options.showDifferences !== false;
	      this.forceUpdate = registerUpdate(this);
	      setScrollLock(this, true, false);
	      registerScroll(this);
	    },
	    setShowDifferences: function(val) {
	      val = val !== false;
	      if (val != this.showDifferences) {
	        this.showDifferences = val;
	        this.forceUpdate("full");
	      }
	    }
	  };

	  function ensureDiff(dv) {
	    if (dv.diffOutOfDate) {
	      dv.diff = getDiff(dv.orig.getValue(), dv.edit.getValue());
	      dv.diffOutOfDate = false;
	      CodeMirror.signal(dv.edit, "updateDiff", dv.diff);
	    }
	  }

	  function registerUpdate(dv) {
	    var edit = {from: 0, to: 0, marked: []};
	    var orig = {from: 0, to: 0, marked: []};
	    var debounceChange;
	    function update(mode) {
	      if (mode == "full") {
	        if (dv.svg) clear(dv.svg);
	        if (dv.copyButtons) clear(dv.copyButtons);
	        clearMarks(dv.edit, edit.marked, dv.classes);
	        clearMarks(dv.orig, orig.marked, dv.classes);
	        edit.from = edit.to = orig.from = orig.to = 0;
	      }
	      ensureDiff(dv);
	      if (dv.showDifferences) {
	        updateMarks(dv.edit, dv.diff, edit, DIFF_INSERT, dv.classes);
	        updateMarks(dv.orig, dv.diff, orig, DIFF_DELETE, dv.classes);
	      }
	      makeConnections(dv);
	    }
	    function set(slow) {
	      clearTimeout(debounceChange);
	      debounceChange = setTimeout(update, slow == true ? 250 : 100);
	    }
	    function change() {
	      if (!dv.diffOutOfDate) {
	        dv.diffOutOfDate = true;
	        edit.from = edit.to = orig.from = orig.to = 0;
	      }
	      set(true);
	    }
	    dv.edit.on("change", change);
	    dv.orig.on("change", change);
	    dv.edit.on("markerAdded", set);
	    dv.edit.on("markerCleared", set);
	    dv.orig.on("markerAdded", set);
	    dv.orig.on("markerCleared", set);
	    dv.edit.on("viewportChange", set);
	    dv.orig.on("viewportChange", set);
	    update();
	    return update;
	  }

	  function registerScroll(dv) {
	    dv.edit.on("scroll", function() {
	      syncScroll(dv, DIFF_INSERT) && makeConnections(dv);
	    });
	    dv.orig.on("scroll", function() {
	      syncScroll(dv, DIFF_DELETE) && makeConnections(dv);
	    });
	  }

	  function syncScroll(dv, type) {
	    // Change handler will do a refresh after a timeout when diff is out of date
	    if (dv.diffOutOfDate) return false;
	    if (!dv.lockScroll) return true;
	    var editor, other, now = +new Date;
	    if (type == DIFF_INSERT) { editor = dv.edit; other = dv.orig; }
	    else { editor = dv.orig; other = dv.edit; }
	    // Don't take action if the position of this editor was recently set
	    // (to prevent feedback loops)
	    if (editor.state.scrollSetBy == dv && (editor.state.scrollSetAt || 0) + 50 > now) return false;

	    var sInfo = editor.getScrollInfo();
	    if (dv.mv.options.connect == "align") {
	      targetPos = sInfo.top;
	    } else {
	      var halfScreen = .5 * sInfo.clientHeight, midY = sInfo.top + halfScreen;
	      var mid = editor.lineAtHeight(midY, "local");
	      var around = chunkBoundariesAround(dv.diff, mid, type == DIFF_INSERT);
	      var off = getOffsets(editor, type == DIFF_INSERT ? around.edit : around.orig);
	      var offOther = getOffsets(other, type == DIFF_INSERT ? around.orig : around.edit);
	      var ratio = (midY - off.top) / (off.bot - off.top);
	      var targetPos = (offOther.top - halfScreen) + ratio * (offOther.bot - offOther.top);

	      var botDist, mix;
	      // Some careful tweaking to make sure no space is left out of view
	      // when scrolling to top or bottom.
	      if (targetPos > sInfo.top && (mix = sInfo.top / halfScreen) < 1) {
	        targetPos = targetPos * mix + sInfo.top * (1 - mix);
	      } else if ((botDist = sInfo.height - sInfo.clientHeight - sInfo.top) < halfScreen) {
	        var otherInfo = other.getScrollInfo();
	        var botDistOther = otherInfo.height - otherInfo.clientHeight - targetPos;
	        if (botDistOther > botDist && (mix = botDist / halfScreen) < 1)
	          targetPos = targetPos * mix + (otherInfo.height - otherInfo.clientHeight - botDist) * (1 - mix);
	      }
	    }

	    other.scrollTo(sInfo.left, targetPos);
	    other.state.scrollSetAt = now;
	    other.state.scrollSetBy = dv;
	    return true;
	  }

	  function getOffsets(editor, around) {
	    var bot = around.after;
	    if (bot == null) bot = editor.lastLine() + 1;
	    return {top: editor.heightAtLine(around.before || 0, "local"),
	            bot: editor.heightAtLine(bot, "local")};
	  }

	  function setScrollLock(dv, val, action) {
	    dv.lockScroll = val;
	    if (val && action != false) syncScroll(dv, DIFF_INSERT) && makeConnections(dv);
	    dv.lockButton.innerHTML = val ? "\u21db\u21da" : "\u21db&nbsp;&nbsp;\u21da";
	  }

	  // Updating the marks for editor content

	  function clearMarks(editor, arr, classes) {
	    for (var i = 0; i < arr.length; ++i) {
	      var mark = arr[i];
	      if (mark instanceof CodeMirror.TextMarker) {
	        mark.clear();
	      } else if (mark.parent) {
	        editor.removeLineClass(mark, "background", classes.chunk);
	        editor.removeLineClass(mark, "background", classes.start);
	        editor.removeLineClass(mark, "background", classes.end);
	      }
	    }
	    arr.length = 0;
	  }

	  // FIXME maybe add a margin around viewport to prevent too many updates
	  function updateMarks(editor, diff, state, type, classes) {
	    var vp = editor.getViewport();
	    editor.operation(function() {
	      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
	        clearMarks(editor, state.marked, classes);
	        markChanges(editor, diff, type, state.marked, vp.from, vp.to, classes);
	        state.from = vp.from; state.to = vp.to;
	      } else {
	        if (vp.from < state.from) {
	          markChanges(editor, diff, type, state.marked, vp.from, state.from, classes);
	          state.from = vp.from;
	        }
	        if (vp.to > state.to) {
	          markChanges(editor, diff, type, state.marked, state.to, vp.to, classes);
	          state.to = vp.to;
	        }
	      }
	    });
	  }

	  function markChanges(editor, diff, type, marks, from, to, classes) {
	    var pos = Pos(0, 0);
	    var top = Pos(from, 0), bot = editor.clipPos(Pos(to - 1));
	    var cls = type == DIFF_DELETE ? classes.del : classes.insert;
	    function markChunk(start, end) {
	      var bfrom = Math.max(from, start), bto = Math.min(to, end);
	      for (var i = bfrom; i < bto; ++i) {
	        var line = editor.addLineClass(i, "background", classes.chunk);
	        if (i == start) editor.addLineClass(line, "background", classes.start);
	        if (i == end - 1) editor.addLineClass(line, "background", classes.end);
	        marks.push(line);
	      }
	      // When the chunk is empty, make sure a horizontal line shows up
	      if (start == end && bfrom == end && bto == end) {
	        if (bfrom)
	          marks.push(editor.addLineClass(bfrom - 1, "background", classes.end));
	        else
	          marks.push(editor.addLineClass(bfrom, "background", classes.start));
	      }
	    }

	    var chunkStart = 0;
	    for (var i = 0; i < diff.length; ++i) {
	      var part = diff[i], tp = part[0], str = part[1];
	      if (tp == DIFF_EQUAL) {
	        var cleanFrom = pos.line + (startOfLineClean(diff, i) ? 0 : 1);
	        moveOver(pos, str);
	        var cleanTo = pos.line + (endOfLineClean(diff, i) ? 1 : 0);
	        if (cleanTo > cleanFrom) {
	          if (i) markChunk(chunkStart, cleanFrom);
	          chunkStart = cleanTo;
	        }
	      } else {
	        if (tp == type) {
	          var end = moveOver(pos, str, true);
	          var a = posMax(top, pos), b = posMin(bot, end);
	          if (!posEq(a, b))
	            marks.push(editor.markText(a, b, {className: cls}));
	          pos = end;
	        }
	      }
	    }
	    if (chunkStart <= pos.line) markChunk(chunkStart, pos.line + 1);
	  }

	  // Updating the gap between editor and original

	  function makeConnections(dv) {
	    if (!dv.showDifferences) return;

	    var align = dv.mv.options.connect == "align";
	    if (align) {
	      if (!dv.orig.curOp) return dv.orig.operation(function() {
	        makeConnections(dv);
	      });
	      for (var i = 0; i < dv.aligners.length; i++)
	        dv.aligners[i].clear();
	      dv.aligners.length = 0;
	      var extraSpaceAbove = {edit: 0, orig: 0};
	    }

	    if (dv.svg) {
	      clear(dv.svg);
	      var w = dv.gap.offsetWidth;
	      attrs(dv.svg, "width", w, "height", dv.gap.offsetHeight);
	    }
	    if (dv.copyButtons) clear(dv.copyButtons);

	    var vpEdit = dv.edit.getViewport(), vpOrig = dv.orig.getViewport();
	    var sTopEdit = dv.edit.getScrollInfo().top, sTopOrig = dv.orig.getScrollInfo().top;
	    iterateChunks(dv.diff, function(topOrig, botOrig, topEdit, botEdit) {
	      if (topEdit <= vpEdit.to && botEdit >= vpEdit.from &&
	          topOrig <= vpOrig.to && botOrig >= vpOrig.from)
	        drawConnectorsForChunk(dv, topOrig, botOrig, topEdit, botEdit, sTopOrig, sTopEdit, w);
	      if (align && (topEdit <= vpEdit.to || topOrig <= vpOrig.to)) {
	        var above = (botEdit < vpEdit.from && botOrig < vpOrig.from);
	        alignChunks(dv, topOrig, botOrig, topEdit, botEdit, above && extraSpaceAbove);
	      }
	    });
	    if (align) {
	      if (extraSpaceAbove.edit)
	        dv.aligners.push(padBelow(dv.edit, 0, extraSpaceAbove.edit));
	      if (extraSpaceAbove.orig)
	        dv.aligners.push(padBelow(dv.orig, 0, extraSpaceAbove.orig));
	    }
	  }

	  function drawConnectorsForChunk(dv, topOrig, botOrig, topEdit, botEdit, sTopOrig, sTopEdit, w) {
	    var flip = dv.type == "left";
	    var top = dv.orig.heightAtLine(topOrig, "local") - sTopOrig;
	    if (dv.svg) {
	      var topLpx = top;
	      var topRpx = dv.edit.heightAtLine(topEdit, "local") - sTopEdit;
	      if (flip) { var tmp = topLpx; topLpx = topRpx; topRpx = tmp; }
	      var botLpx = dv.orig.heightAtLine(botOrig, "local") - sTopOrig;
	      var botRpx = dv.edit.heightAtLine(botEdit, "local") - sTopEdit;
	      if (flip) { var tmp = botLpx; botLpx = botRpx; botRpx = tmp; }
	      var curveTop = " C " + w/2 + " " + topRpx + " " + w/2 + " " + topLpx + " " + (w + 2) + " " + topLpx;
	      var curveBot = " C " + w/2 + " " + botLpx + " " + w/2 + " " + botRpx + " -1 " + botRpx;
	      attrs(dv.svg.appendChild(document.createElementNS(svgNS, "path")),
	            "d", "M -1 " + topRpx + curveTop + " L " + (w + 2) + " " + botLpx + curveBot + " z",
	            "class", dv.classes.connect);
	    }
	    if (dv.copyButtons) {
	      var copy = dv.copyButtons.appendChild(elt("div", dv.type == "left" ? "\u21dd" : "\u21dc",
	                                                "CodeMirror-merge-copy"));
	      var editOriginals = dv.mv.options.allowEditingOriginals;
	      copy.title = editOriginals ? "Push to left" : "Revert chunk";
	      copy.chunk = {topEdit: topEdit, botEdit: botEdit, topOrig: topOrig, botOrig: botOrig};
	      copy.style.top = top + "px";

	      if (editOriginals) {
	        var topReverse = dv.orig.heightAtLine(topEdit, "local") - sTopEdit;
	        var copyReverse = dv.copyButtons.appendChild(elt("div", dv.type == "right" ? "\u21dd" : "\u21dc",
	                                                         "CodeMirror-merge-copy-reverse"));
	        copyReverse.title = "Push to right";
	        copyReverse.chunk = {topEdit: topOrig, botEdit: botOrig, topOrig: topEdit, botOrig: botEdit};
	        copyReverse.style.top = topReverse + "px";
	        dv.type == "right" ? copyReverse.style.left = "2px" : copyReverse.style.right = "2px";
	      }
	    }
	  }

	  function alignChunks(dv, topOrig, botOrig, topEdit, botEdit, aboveViewport) {
	    var topOrigPx = dv.orig.heightAtLine(topOrig, "local");
	    var botOrigPx = dv.orig.heightAtLine(botOrig, "local");
	    var topEditPx = dv.edit.heightAtLine(topEdit, "local");
	    var botEditPx = dv.edit.heightAtLine(botEdit, "local");
	    var origH = botOrigPx -topOrigPx, editH = botEditPx - topEditPx;
	    var diff = editH - origH;
	    if (diff > 1) {
	      if (aboveViewport) aboveViewport.orig += diff;
	      else dv.aligners.push(padBelow(dv.orig, botOrig - 1, diff));
	    } else if (diff < -1) {
	      if (aboveViewport) aboveViewport.edit -= diff;
	      else dv.aligners.push(padBelow(dv.edit, botEdit - 1, -diff));
	    }
	    return 0;
	  }

	  function padBelow(cm, line, size) {
	    var elt = document.createElement("div");
	    elt.style.height = size + "px"; elt.style.minWidth = "1px";
	    return cm.addLineWidget(line, elt, {height: size});
	  }

	  function copyChunk(dv, to, from, chunk) {
	    if (dv.diffOutOfDate) return;
	    to.replaceRange(from.getRange(Pos(chunk.topOrig, 0), Pos(chunk.botOrig, 0)),
	                         Pos(chunk.topEdit, 0), Pos(chunk.botEdit, 0));
	  }

	  // Merge view, containing 0, 1, or 2 diff views.

	  var MergeView = CodeMirror.MergeView = function(node, options) {
	    if (!(this instanceof MergeView)) return new MergeView(node, options);

	    this.options = options;
	    var origLeft = options.origLeft, origRight = options.origRight == null ? options.orig : options.origRight;
	    if (origLeft && origRight) {
	      if (options.connect == "align")
	        throw new Error("connect: \"align\" is not supported for three-way merge views");
	      if (options.collapseIdentical)
	        throw new Error("collapseIdentical option is not supported for three-way merge views");
	    }

	    var hasLeft = origLeft != null, hasRight = origRight != null;
	    var panes = 1 + (hasLeft ? 1 : 0) + (hasRight ? 1 : 0);
	    var wrap = [], left = this.left = null, right = this.right = null;

	    if (hasLeft) {
	      left = this.left = new DiffView(this, "left");
	      var leftPane = elt("div", null, "CodeMirror-merge-pane");
	      wrap.push(leftPane);
	      wrap.push(buildGap(left));
	    }

	    var editPane = elt("div", null, "CodeMirror-merge-pane");
	    this.wrapEdit = editPane;
	    wrap.push(editPane);

	    if (hasRight) {
	      right = this.right = new DiffView(this, "right");
	      wrap.push(buildGap(right));
	      var rightPane = elt("div", null, "CodeMirror-merge-pane");
	      wrap.push(rightPane);
	      this.wrapRight = rightPane;
	    }

	    (hasRight ? rightPane : editPane).className += " CodeMirror-merge-pane-rightmost";

	    wrap.push(elt("div", null, null, "height: 0; clear: both;"));

	    var wrapElt = this.wrap = node.appendChild(elt("div", wrap, "CodeMirror-merge CodeMirror-merge-" + panes + "pane"));
	    this.edit = CodeMirror(editPane, copyObj(options));

	    if (left) left.init(leftPane, origLeft, options);
	    if (right) {
	      var rightOptions = copyObj(options);
	      rightOptions.lint = null;
	      right.init(rightPane, origRight, rightOptions);
	    }

	    if (options.collapseIdentical)
	      collapseIdenticalStretches(left || right, options.collapseIdentical);

	    var onResize = function() {
	      if (left) makeConnections(left);
	      if (right) makeConnections(right);
	    };
	    CodeMirror.on(window, "resize", onResize);
	    var resizeInterval = setInterval(function() {
	      for (var p = wrapElt.parentNode; p && p != document.body; p = p.parentNode) {}
	      if (!p) { clearInterval(resizeInterval); CodeMirror.off(window, "resize", onResize); }
	    }, 5000);
	  };

	  function buildGap(dv) {
	    var lock = dv.lockButton = elt("div", null, "CodeMirror-merge-scrolllock");
	    lock.title = "Toggle locked scrolling";
	    var lockWrap = elt("div", [lock], "CodeMirror-merge-scrolllock-wrap");
	    CodeMirror.on(lock, "click", function() { setScrollLock(dv, !dv.lockScroll); });
	    var gapElts = [lockWrap];
	    if (dv.mv.options.revertButtons !== false) {
	      dv.copyButtons = elt("div", null, "CodeMirror-merge-copybuttons-" + dv.type);
	      CodeMirror.on(dv.copyButtons, "click", function(e) {
	        var node = e.target || e.srcElement;
	        if (!node.chunk) return;
	        if (node.className == "CodeMirror-merge-copy-reverse") {
	          copyChunk(dv, dv.orig, dv.edit, node.chunk);
	          return;
	        }
	        copyChunk(dv, dv.edit, dv.orig, node.chunk);
	      });
	      gapElts.unshift(dv.copyButtons);
	    }
	    if (dv.mv.options.connect != "align") {
	      var svg = document.createElementNS && document.createElementNS(svgNS, "svg");
	      if (svg && !svg.createSVGRect) svg = null;
	      dv.svg = svg;
	      if (svg) gapElts.push(svg);
	    }

	    return dv.gap = elt("div", gapElts, "CodeMirror-merge-gap");
	  }

	  MergeView.prototype = {
	    constuctor: MergeView,
	    editor: function() { return this.edit; },
	    rightOriginal: function() { return this.right && this.right.orig; },
	    leftOriginal: function() { return this.left && this.left.orig; },
	    setShowDifferences: function(val) {
	      if (this.right) this.right.setShowDifferences(val);
	      if (this.left) this.left.setShowDifferences(val);
	    },
	    rightChunks: function() {
	      return this.right && getChunks(this.right);
	    },
	    leftChunks: function() {
	      return this.left && getChunks(this.left);
	    }
	  };

	  function asString(obj) {
	    if (typeof obj == "string") return obj;
	    else return obj.getValue();
	  }

	  // Operations on diffs

	  var dmp = new window.diff_match_patch();
	  function getDiff(a, b) {
	    var diff = dmp.diff_main(a, b);
	    dmp.diff_cleanupSemantic(diff);
	    // The library sometimes leaves in empty parts, which confuse the algorithm
	    for (var i = 0; i < diff.length; ++i) {
	      var part = diff[i];
	      if (!part[1]) {
	        diff.splice(i--, 1);
	      } else if (i && diff[i - 1][0] == part[0]) {
	        diff.splice(i--, 1);
	        diff[i][1] += part[1];
	      }
	    }
	    return diff;
	  }

	  function iterateChunks(diff, f) {
	    var startEdit = 0, startOrig = 0;
	    var edit = Pos(0, 0), orig = Pos(0, 0);
	    for (var i = 0; i < diff.length; ++i) {
	      var part = diff[i], tp = part[0];
	      if (tp == DIFF_EQUAL) {
	        var startOff = startOfLineClean(diff, i) ? 0 : 1;
	        var cleanFromEdit = edit.line + startOff, cleanFromOrig = orig.line + startOff;
	        moveOver(edit, part[1], null, orig);
	        var endOff = endOfLineClean(diff, i) ? 1 : 0;
	        var cleanToEdit = edit.line + endOff, cleanToOrig = orig.line + endOff;
	        if (cleanToEdit > cleanFromEdit) {
	          if (i) f(startOrig, cleanFromOrig, startEdit, cleanFromEdit);
	          startEdit = cleanToEdit; startOrig = cleanToOrig;
	        }
	      } else {
	        moveOver(tp == DIFF_INSERT ? edit : orig, part[1]);
	      }
	    }
	    if (startEdit <= edit.line || startOrig <= orig.line)
	      f(startOrig, orig.line + 1, startEdit, edit.line + 1);
	  }

	  function getChunks(dv) {
	    ensureDiff(dv);
	    var collect = [];
	    iterateChunks(dv.diff, function(topOrig, botOrig, topEdit, botEdit) {
	      collect.push({origFrom: topOrig, origTo: botOrig,
	                    editFrom: topEdit, editTo: botEdit});
	    });
	    return collect;
	  }

	  function endOfLineClean(diff, i) {
	    if (i == diff.length - 1) return true;
	    var next = diff[i + 1][1];
	    if (next.length == 1 || next.charCodeAt(0) != 10) return false;
	    if (i == diff.length - 2) return true;
	    next = diff[i + 2][1];
	    return next.length > 1 && next.charCodeAt(0) == 10;
	  }

	  function startOfLineClean(diff, i) {
	    if (i == 0) return true;
	    var last = diff[i - 1][1];
	    if (last.charCodeAt(last.length - 1) != 10) return false;
	    if (i == 1) return true;
	    last = diff[i - 2][1];
	    return last.charCodeAt(last.length - 1) == 10;
	  }

	  function chunkBoundariesAround(diff, n, nInEdit) {
	    var beforeE, afterE, beforeO, afterO;
	    iterateChunks(diff, function(fromOrig, toOrig, fromEdit, toEdit) {
	      var fromLocal = nInEdit ? fromEdit : fromOrig;
	      var toLocal = nInEdit ? toEdit : toOrig;
	      if (afterE == null) {
	        if (fromLocal > n) { afterE = fromEdit; afterO = fromOrig; }
	        else if (toLocal > n) { afterE = toEdit; afterO = toOrig; }
	      }
	      if (toLocal <= n) { beforeE = toEdit; beforeO = toOrig; }
	      else if (fromLocal <= n) { beforeE = fromEdit; beforeO = fromOrig; }
	    });
	    return {edit: {before: beforeE, after: afterE}, orig: {before: beforeO, after: afterO}};
	  }

	  function collapseSingle(cm, from, to) {
	    cm.addLineClass(from, "wrap", "CodeMirror-merge-collapsed-line");
	    var widget = document.createElement("span");
	    widget.className = "CodeMirror-merge-collapsed-widget";
	    widget.title = "Identical text collapsed. Click to expand.";
	    var mark = cm.markText(Pos(from, 0), Pos(to - 1), {
	      inclusiveLeft: true,
	      inclusiveRight: true,
	      replacedWith: widget,
	      clearOnEnter: true
	    });
	    function clear() {
	      mark.clear();
	      cm.removeLineClass(from, "wrap", "CodeMirror-merge-collapsed-line");
	    }
	    widget.addEventListener("click", clear);
	    return {mark: mark, clear: clear};
	  }

	  function collapseStretch(dv, origStart, editStart, size) {
	    var mOrig = collapseSingle(dv.orig, origStart, origStart + size);
	    var mEdit = collapseSingle(dv.edit, editStart, editStart + size);
	    mOrig.mark.on("clear", function() { mEdit.clear(); });
	    mEdit.mark.on("clear", function() { mOrig.clear(); });
	  }

	  function collapseIdenticalStretches(dv, margin) {
	    if (typeof margin != "number") margin = 2;
	    var lastOrig = dv.orig.firstLine(), lastEdit = dv.edit.firstLine();
	    iterateChunks(dv.diff, function(topOrig, botOrig, _topEdit, botEdit) {
	      var identicalSize = topOrig - margin - lastOrig;
	      if (identicalSize > margin)
	        collapseStretch(dv, lastOrig, lastEdit, identicalSize);
	      lastOrig = botOrig + margin; lastEdit = botEdit + margin;
	    });
	    var bottomSize = dv.orig.lastLine() + 1 - lastOrig;
	    if (bottomSize > margin)
	      collapseStretch(dv, lastOrig, lastEdit, bottomSize);
	  }

	  // General utilities

	  function elt(tag, content, className, style) {
	    var e = document.createElement(tag);
	    if (className) e.className = className;
	    if (style) e.style.cssText = style;
	    if (typeof content == "string") e.appendChild(document.createTextNode(content));
	    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
	    return e;
	  }

	  function clear(node) {
	    for (var count = node.childNodes.length; count > 0; --count)
	      node.removeChild(node.firstChild);
	  }

	  function attrs(elt) {
	    for (var i = 1; i < arguments.length; i += 2)
	      elt.setAttribute(arguments[i], arguments[i+1]);
	  }

	  function copyObj(obj, target) {
	    if (!target) target = {};
	    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];
	    return target;
	  }

	  function moveOver(pos, str, copy, other) {
	    var out = copy ? Pos(pos.line, pos.ch) : pos, at = 0;
	    for (;;) {
	      var nl = str.indexOf("\n", at);
	      if (nl == -1) break;
	      ++out.line;
	      if (other) ++other.line;
	      at = nl + 1;
	    }
	    out.ch = (at ? 0 : out.ch) + (str.length - at);
	    if (other) other.ch = (at ? 0 : other.ch) + (str.length - at);
	    return out;
	  }

	  function posMin(a, b) { return (a.line - b.line || a.ch - b.ch) < 0 ? a : b; }
	  function posMax(a, b) { return (a.line - b.line || a.ch - b.ch) > 0 ? a : b; }
	  function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }
	});


/***/ },
/* 16 */
/***/ function(module, exports) {

	(function(){function diff_match_patch(){this.Diff_Timeout=1;this.Diff_EditCost=4;this.Match_Threshold=0.5;this.Match_Distance=1E3;this.Patch_DeleteThreshold=0.5;this.Patch_Margin=4;this.Match_MaxBits=32}
	diff_match_patch.prototype.diff_main=function(a,b,c,d){"undefined"==typeof d&&(d=0>=this.Diff_Timeout?Number.MAX_VALUE:(new Date).getTime()+1E3*this.Diff_Timeout);if(null==a||null==b)throw Error("Null input. (diff_main)");if(a==b)return a?[[0,a]]:[];"undefined"==typeof c&&(c=!0);var e=c,f=this.diff_commonPrefix(a,b);c=a.substring(0,f);a=a.substring(f);b=b.substring(f);var f=this.diff_commonSuffix(a,b),g=a.substring(a.length-f);a=a.substring(0,a.length-f);b=b.substring(0,b.length-f);a=this.diff_compute_(a,
	b,e,d);c&&a.unshift([0,c]);g&&a.push([0,g]);this.diff_cleanupMerge(a);return a};
	diff_match_patch.prototype.diff_compute_=function(a,b,c,d){if(!a)return[[1,b]];if(!b)return[[-1,a]];var e=a.length>b.length?a:b,f=a.length>b.length?b:a,g=e.indexOf(f);return-1!=g?(c=[[1,e.substring(0,g)],[0,f],[1,e.substring(g+f.length)]],a.length>b.length&&(c[0][0]=c[2][0]=-1),c):1==f.length?[[-1,a],[1,b]]:(e=this.diff_halfMatch_(a,b))?(f=e[0],a=e[1],g=e[2],b=e[3],e=e[4],f=this.diff_main(f,g,c,d),c=this.diff_main(a,b,c,d),f.concat([[0,e]],c)):c&&100<a.length&&100<b.length?this.diff_lineMode_(a,b,
	d):this.diff_bisect_(a,b,d)};
	diff_match_patch.prototype.diff_lineMode_=function(a,b,c){var d=this.diff_linesToChars_(a,b);a=d.chars1;b=d.chars2;d=d.lineArray;a=this.diff_main(a,b,!1,c);this.diff_charsToLines_(a,d);this.diff_cleanupSemantic(a);a.push([0,""]);for(var e=d=b=0,f="",g="";b<a.length;){switch(a[b][0]){case 1:e++;g+=a[b][1];break;case -1:d++;f+=a[b][1];break;case 0:if(1<=d&&1<=e){a.splice(b-d-e,d+e);b=b-d-e;d=this.diff_main(f,g,!1,c);for(e=d.length-1;0<=e;e--)a.splice(b,0,d[e]);b+=d.length}d=e=0;g=f=""}b++}a.pop();return a};
	diff_match_patch.prototype.diff_bisect_=function(a,b,c){for(var d=a.length,e=b.length,f=Math.ceil((d+e)/2),g=f,h=2*f,j=Array(h),i=Array(h),k=0;k<h;k++)j[k]=-1,i[k]=-1;j[g+1]=0;i[g+1]=0;for(var k=d-e,q=0!=k%2,r=0,t=0,p=0,w=0,v=0;v<f&&!((new Date).getTime()>c);v++){for(var n=-v+r;n<=v-t;n+=2){var l=g+n,m;m=n==-v||n!=v&&j[l-1]<j[l+1]?j[l+1]:j[l-1]+1;for(var s=m-n;m<d&&s<e&&a.charAt(m)==b.charAt(s);)m++,s++;j[l]=m;if(m>d)t+=2;else if(s>e)r+=2;else if(q&&(l=g+k-n,0<=l&&l<h&&-1!=i[l])){var u=d-i[l];if(m>=
	u)return this.diff_bisectSplit_(a,b,m,s,c)}}for(n=-v+p;n<=v-w;n+=2){l=g+n;u=n==-v||n!=v&&i[l-1]<i[l+1]?i[l+1]:i[l-1]+1;for(m=u-n;u<d&&m<e&&a.charAt(d-u-1)==b.charAt(e-m-1);)u++,m++;i[l]=u;if(u>d)w+=2;else if(m>e)p+=2;else if(!q&&(l=g+k-n,0<=l&&(l<h&&-1!=j[l])&&(m=j[l],s=g+m-l,u=d-u,m>=u)))return this.diff_bisectSplit_(a,b,m,s,c)}}return[[-1,a],[1,b]]};
	diff_match_patch.prototype.diff_bisectSplit_=function(a,b,c,d,e){var f=a.substring(0,c),g=b.substring(0,d);a=a.substring(c);b=b.substring(d);f=this.diff_main(f,g,!1,e);e=this.diff_main(a,b,!1,e);return f.concat(e)};
	diff_match_patch.prototype.diff_linesToChars_=function(a,b){function c(a){for(var b="",c=0,f=-1,g=d.length;f<a.length-1;){f=a.indexOf("\n",c);-1==f&&(f=a.length-1);var r=a.substring(c,f+1),c=f+1;(e.hasOwnProperty?e.hasOwnProperty(r):void 0!==e[r])?b+=String.fromCharCode(e[r]):(b+=String.fromCharCode(g),e[r]=g,d[g++]=r)}return b}var d=[],e={};d[0]="";var f=c(a),g=c(b);return{chars1:f,chars2:g,lineArray:d}};
	diff_match_patch.prototype.diff_charsToLines_=function(a,b){for(var c=0;c<a.length;c++){for(var d=a[c][1],e=[],f=0;f<d.length;f++)e[f]=b[d.charCodeAt(f)];a[c][1]=e.join("")}};diff_match_patch.prototype.diff_commonPrefix=function(a,b){if(!a||!b||a.charAt(0)!=b.charAt(0))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;c<e;)a.substring(f,e)==b.substring(f,e)?f=c=e:d=e,e=Math.floor((d-c)/2+c);return e};
	diff_match_patch.prototype.diff_commonSuffix=function(a,b){if(!a||!b||a.charAt(a.length-1)!=b.charAt(b.length-1))return 0;for(var c=0,d=Math.min(a.length,b.length),e=d,f=0;c<e;)a.substring(a.length-e,a.length-f)==b.substring(b.length-e,b.length-f)?f=c=e:d=e,e=Math.floor((d-c)/2+c);return e};
	diff_match_patch.prototype.diff_commonOverlap_=function(a,b){var c=a.length,d=b.length;if(0==c||0==d)return 0;c>d?a=a.substring(c-d):c<d&&(b=b.substring(0,c));c=Math.min(c,d);if(a==b)return c;for(var d=0,e=1;;){var f=a.substring(c-e),f=b.indexOf(f);if(-1==f)return d;e+=f;if(0==f||a.substring(c-e)==b.substring(0,e))d=e,e++}};
	diff_match_patch.prototype.diff_halfMatch_=function(a,b){function c(a,b,c){for(var d=a.substring(c,c+Math.floor(a.length/4)),e=-1,g="",h,j,n,l;-1!=(e=b.indexOf(d,e+1));){var m=f.diff_commonPrefix(a.substring(c),b.substring(e)),s=f.diff_commonSuffix(a.substring(0,c),b.substring(0,e));g.length<s+m&&(g=b.substring(e-s,e)+b.substring(e,e+m),h=a.substring(0,c-s),j=a.substring(c+m),n=b.substring(0,e-s),l=b.substring(e+m))}return 2*g.length>=a.length?[h,j,n,l,g]:null}if(0>=this.Diff_Timeout)return null;
	var d=a.length>b.length?a:b,e=a.length>b.length?b:a;if(4>d.length||2*e.length<d.length)return null;var f=this,g=c(d,e,Math.ceil(d.length/4)),d=c(d,e,Math.ceil(d.length/2)),h;if(!g&&!d)return null;h=d?g?g[4].length>d[4].length?g:d:d:g;var j;a.length>b.length?(g=h[0],d=h[1],e=h[2],j=h[3]):(e=h[0],j=h[1],g=h[2],d=h[3]);h=h[4];return[g,d,e,j,h]};
	diff_match_patch.prototype.diff_cleanupSemantic=function(a){for(var b=!1,c=[],d=0,e=null,f=0,g=0,h=0,j=0,i=0;f<a.length;)0==a[f][0]?(c[d++]=f,g=j,h=i,i=j=0,e=a[f][1]):(1==a[f][0]?j+=a[f][1].length:i+=a[f][1].length,e&&(e.length<=Math.max(g,h)&&e.length<=Math.max(j,i))&&(a.splice(c[d-1],0,[-1,e]),a[c[d-1]+1][0]=1,d--,d--,f=0<d?c[d-1]:-1,i=j=h=g=0,e=null,b=!0)),f++;b&&this.diff_cleanupMerge(a);this.diff_cleanupSemanticLossless(a);for(f=1;f<a.length;){if(-1==a[f-1][0]&&1==a[f][0]){b=a[f-1][1];c=a[f][1];
	d=this.diff_commonOverlap_(b,c);e=this.diff_commonOverlap_(c,b);if(d>=e){if(d>=b.length/2||d>=c.length/2)a.splice(f,0,[0,c.substring(0,d)]),a[f-1][1]=b.substring(0,b.length-d),a[f+1][1]=c.substring(d),f++}else if(e>=b.length/2||e>=c.length/2)a.splice(f,0,[0,b.substring(0,e)]),a[f-1][0]=1,a[f-1][1]=c.substring(0,c.length-e),a[f+1][0]=-1,a[f+1][1]=b.substring(e),f++;f++}f++}};
	diff_match_patch.prototype.diff_cleanupSemanticLossless=function(a){function b(a,b){if(!a||!b)return 6;var c=a.charAt(a.length-1),d=b.charAt(0),e=c.match(diff_match_patch.nonAlphaNumericRegex_),f=d.match(diff_match_patch.nonAlphaNumericRegex_),g=e&&c.match(diff_match_patch.whitespaceRegex_),h=f&&d.match(diff_match_patch.whitespaceRegex_),c=g&&c.match(diff_match_patch.linebreakRegex_),d=h&&d.match(diff_match_patch.linebreakRegex_),i=c&&a.match(diff_match_patch.blanklineEndRegex_),j=d&&b.match(diff_match_patch.blanklineStartRegex_);
	return i||j?5:c||d?4:e&&!g&&h?3:g||h?2:e||f?1:0}for(var c=1;c<a.length-1;){if(0==a[c-1][0]&&0==a[c+1][0]){var d=a[c-1][1],e=a[c][1],f=a[c+1][1],g=this.diff_commonSuffix(d,e);if(g)var h=e.substring(e.length-g),d=d.substring(0,d.length-g),e=h+e.substring(0,e.length-g),f=h+f;for(var g=d,h=e,j=f,i=b(d,e)+b(e,f);e.charAt(0)===f.charAt(0);){var d=d+e.charAt(0),e=e.substring(1)+f.charAt(0),f=f.substring(1),k=b(d,e)+b(e,f);k>=i&&(i=k,g=d,h=e,j=f)}a[c-1][1]!=g&&(g?a[c-1][1]=g:(a.splice(c-1,1),c--),a[c][1]=
	h,j?a[c+1][1]=j:(a.splice(c+1,1),c--))}c++}};diff_match_patch.nonAlphaNumericRegex_=/[^a-zA-Z0-9]/;diff_match_patch.whitespaceRegex_=/\s/;diff_match_patch.linebreakRegex_=/[\r\n]/;diff_match_patch.blanklineEndRegex_=/\n\r?\n$/;diff_match_patch.blanklineStartRegex_=/^\r?\n\r?\n/;
	diff_match_patch.prototype.diff_cleanupEfficiency=function(a){for(var b=!1,c=[],d=0,e=null,f=0,g=!1,h=!1,j=!1,i=!1;f<a.length;){if(0==a[f][0])a[f][1].length<this.Diff_EditCost&&(j||i)?(c[d++]=f,g=j,h=i,e=a[f][1]):(d=0,e=null),j=i=!1;else if(-1==a[f][0]?i=!0:j=!0,e&&(g&&h&&j&&i||e.length<this.Diff_EditCost/2&&3==g+h+j+i))a.splice(c[d-1],0,[-1,e]),a[c[d-1]+1][0]=1,d--,e=null,g&&h?(j=i=!0,d=0):(d--,f=0<d?c[d-1]:-1,j=i=!1),b=!0;f++}b&&this.diff_cleanupMerge(a)};
	diff_match_patch.prototype.diff_cleanupMerge=function(a){a.push([0,""]);for(var b=0,c=0,d=0,e="",f="",g;b<a.length;)switch(a[b][0]){case 1:d++;f+=a[b][1];b++;break;case -1:c++;e+=a[b][1];b++;break;case 0:1<c+d?(0!==c&&0!==d&&(g=this.diff_commonPrefix(f,e),0!==g&&(0<b-c-d&&0==a[b-c-d-1][0]?a[b-c-d-1][1]+=f.substring(0,g):(a.splice(0,0,[0,f.substring(0,g)]),b++),f=f.substring(g),e=e.substring(g)),g=this.diff_commonSuffix(f,e),0!==g&&(a[b][1]=f.substring(f.length-g)+a[b][1],f=f.substring(0,f.length-
	g),e=e.substring(0,e.length-g))),0===c?a.splice(b-d,c+d,[1,f]):0===d?a.splice(b-c,c+d,[-1,e]):a.splice(b-c-d,c+d,[-1,e],[1,f]),b=b-c-d+(c?1:0)+(d?1:0)+1):0!==b&&0==a[b-1][0]?(a[b-1][1]+=a[b][1],a.splice(b,1)):b++,c=d=0,f=e=""}""===a[a.length-1][1]&&a.pop();c=!1;for(b=1;b<a.length-1;)0==a[b-1][0]&&0==a[b+1][0]&&(a[b][1].substring(a[b][1].length-a[b-1][1].length)==a[b-1][1]?(a[b][1]=a[b-1][1]+a[b][1].substring(0,a[b][1].length-a[b-1][1].length),a[b+1][1]=a[b-1][1]+a[b+1][1],a.splice(b-1,1),c=!0):a[b][1].substring(0,
	a[b+1][1].length)==a[b+1][1]&&(a[b-1][1]+=a[b+1][1],a[b][1]=a[b][1].substring(a[b+1][1].length)+a[b+1][1],a.splice(b+1,1),c=!0)),b++;c&&this.diff_cleanupMerge(a)};diff_match_patch.prototype.diff_xIndex=function(a,b){var c=0,d=0,e=0,f=0,g;for(g=0;g<a.length;g++){1!==a[g][0]&&(c+=a[g][1].length);-1!==a[g][0]&&(d+=a[g][1].length);if(c>b)break;e=c;f=d}return a.length!=g&&-1===a[g][0]?f:f+(b-e)};
	diff_match_patch.prototype.diff_prettyHtml=function(a){for(var b=[],c=/&/g,d=/</g,e=/>/g,f=/\n/g,g=0;g<a.length;g++){var h=a[g][0],j=a[g][1],j=j.replace(c,"&amp;").replace(d,"&lt;").replace(e,"&gt;").replace(f,"&para;<br>");switch(h){case 1:b[g]='<ins style="background:#e6ffe6;">'+j+"</ins>";break;case -1:b[g]='<del style="background:#ffe6e6;">'+j+"</del>";break;case 0:b[g]="<span>"+j+"</span>"}}return b.join("")};
	diff_match_patch.prototype.diff_text1=function(a){for(var b=[],c=0;c<a.length;c++)1!==a[c][0]&&(b[c]=a[c][1]);return b.join("")};diff_match_patch.prototype.diff_text2=function(a){for(var b=[],c=0;c<a.length;c++)-1!==a[c][0]&&(b[c]=a[c][1]);return b.join("")};diff_match_patch.prototype.diff_levenshtein=function(a){for(var b=0,c=0,d=0,e=0;e<a.length;e++){var f=a[e][0],g=a[e][1];switch(f){case 1:c+=g.length;break;case -1:d+=g.length;break;case 0:b+=Math.max(c,d),d=c=0}}return b+=Math.max(c,d)};
	diff_match_patch.prototype.diff_toDelta=function(a){for(var b=[],c=0;c<a.length;c++)switch(a[c][0]){case 1:b[c]="+"+encodeURI(a[c][1]);break;case -1:b[c]="-"+a[c][1].length;break;case 0:b[c]="="+a[c][1].length}return b.join("\t").replace(/%20/g," ")};
	diff_match_patch.prototype.diff_fromDelta=function(a,b){for(var c=[],d=0,e=0,f=b.split(/\t/g),g=0;g<f.length;g++){var h=f[g].substring(1);switch(f[g].charAt(0)){case "+":try{c[d++]=[1,decodeURI(h)]}catch(j){throw Error("Illegal escape in diff_fromDelta: "+h);}break;case "-":case "=":var i=parseInt(h,10);if(isNaN(i)||0>i)throw Error("Invalid number in diff_fromDelta: "+h);h=a.substring(e,e+=i);"="==f[g].charAt(0)?c[d++]=[0,h]:c[d++]=[-1,h];break;default:if(f[g])throw Error("Invalid diff operation in diff_fromDelta: "+
	f[g]);}}if(e!=a.length)throw Error("Delta length ("+e+") does not equal source text length ("+a.length+").");return c};diff_match_patch.prototype.match_main=function(a,b,c){if(null==a||null==b||null==c)throw Error("Null input. (match_main)");c=Math.max(0,Math.min(c,a.length));return a==b?0:a.length?a.substring(c,c+b.length)==b?c:this.match_bitap_(a,b,c):-1};
	diff_match_patch.prototype.match_bitap_=function(a,b,c){function d(a,d){var e=a/b.length,g=Math.abs(c-d);return!f.Match_Distance?g?1:e:e+g/f.Match_Distance}if(b.length>this.Match_MaxBits)throw Error("Pattern too long for this browser.");var e=this.match_alphabet_(b),f=this,g=this.Match_Threshold,h=a.indexOf(b,c);-1!=h&&(g=Math.min(d(0,h),g),h=a.lastIndexOf(b,c+b.length),-1!=h&&(g=Math.min(d(0,h),g)));for(var j=1<<b.length-1,h=-1,i,k,q=b.length+a.length,r,t=0;t<b.length;t++){i=0;for(k=q;i<k;)d(t,c+
	k)<=g?i=k:q=k,k=Math.floor((q-i)/2+i);q=k;i=Math.max(1,c-k+1);var p=Math.min(c+k,a.length)+b.length;k=Array(p+2);for(k[p+1]=(1<<t)-1;p>=i;p--){var w=e[a.charAt(p-1)];k[p]=0===t?(k[p+1]<<1|1)&w:(k[p+1]<<1|1)&w|((r[p+1]|r[p])<<1|1)|r[p+1];if(k[p]&j&&(w=d(t,p-1),w<=g))if(g=w,h=p-1,h>c)i=Math.max(1,2*c-h);else break}if(d(t+1,c)>g)break;r=k}return h};
	diff_match_patch.prototype.match_alphabet_=function(a){for(var b={},c=0;c<a.length;c++)b[a.charAt(c)]=0;for(c=0;c<a.length;c++)b[a.charAt(c)]|=1<<a.length-c-1;return b};
	diff_match_patch.prototype.patch_addContext_=function(a,b){if(0!=b.length){for(var c=b.substring(a.start2,a.start2+a.length1),d=0;b.indexOf(c)!=b.lastIndexOf(c)&&c.length<this.Match_MaxBits-this.Patch_Margin-this.Patch_Margin;)d+=this.Patch_Margin,c=b.substring(a.start2-d,a.start2+a.length1+d);d+=this.Patch_Margin;(c=b.substring(a.start2-d,a.start2))&&a.diffs.unshift([0,c]);(d=b.substring(a.start2+a.length1,a.start2+a.length1+d))&&a.diffs.push([0,d]);a.start1-=c.length;a.start2-=c.length;a.length1+=
	c.length+d.length;a.length2+=c.length+d.length}};
	diff_match_patch.prototype.patch_make=function(a,b,c){var d;if("string"==typeof a&&"string"==typeof b&&"undefined"==typeof c)d=a,b=this.diff_main(d,b,!0),2<b.length&&(this.diff_cleanupSemantic(b),this.diff_cleanupEfficiency(b));else if(a&&"object"==typeof a&&"undefined"==typeof b&&"undefined"==typeof c)b=a,d=this.diff_text1(b);else if("string"==typeof a&&b&&"object"==typeof b&&"undefined"==typeof c)d=a;else if("string"==typeof a&&"string"==typeof b&&c&&"object"==typeof c)d=a,b=c;else throw Error("Unknown call format to patch_make.");
	if(0===b.length)return[];c=[];a=new diff_match_patch.patch_obj;for(var e=0,f=0,g=0,h=d,j=0;j<b.length;j++){var i=b[j][0],k=b[j][1];!e&&0!==i&&(a.start1=f,a.start2=g);switch(i){case 1:a.diffs[e++]=b[j];a.length2+=k.length;d=d.substring(0,g)+k+d.substring(g);break;case -1:a.length1+=k.length;a.diffs[e++]=b[j];d=d.substring(0,g)+d.substring(g+k.length);break;case 0:k.length<=2*this.Patch_Margin&&e&&b.length!=j+1?(a.diffs[e++]=b[j],a.length1+=k.length,a.length2+=k.length):k.length>=2*this.Patch_Margin&&
	e&&(this.patch_addContext_(a,h),c.push(a),a=new diff_match_patch.patch_obj,e=0,h=d,f=g)}1!==i&&(f+=k.length);-1!==i&&(g+=k.length)}e&&(this.patch_addContext_(a,h),c.push(a));return c};diff_match_patch.prototype.patch_deepCopy=function(a){for(var b=[],c=0;c<a.length;c++){var d=a[c],e=new diff_match_patch.patch_obj;e.diffs=[];for(var f=0;f<d.diffs.length;f++)e.diffs[f]=d.diffs[f].slice();e.start1=d.start1;e.start2=d.start2;e.length1=d.length1;e.length2=d.length2;b[c]=e}return b};
	diff_match_patch.prototype.patch_apply=function(a,b){if(0==a.length)return[b,[]];a=this.patch_deepCopy(a);var c=this.patch_addPadding(a);b=c+b+c;this.patch_splitMax(a);for(var d=0,e=[],f=0;f<a.length;f++){var g=a[f].start2+d,h=this.diff_text1(a[f].diffs),j,i=-1;if(h.length>this.Match_MaxBits){if(j=this.match_main(b,h.substring(0,this.Match_MaxBits),g),-1!=j&&(i=this.match_main(b,h.substring(h.length-this.Match_MaxBits),g+h.length-this.Match_MaxBits),-1==i||j>=i))j=-1}else j=this.match_main(b,h,g);
	if(-1==j)e[f]=!1,d-=a[f].length2-a[f].length1;else if(e[f]=!0,d=j-g,g=-1==i?b.substring(j,j+h.length):b.substring(j,i+this.Match_MaxBits),h==g)b=b.substring(0,j)+this.diff_text2(a[f].diffs)+b.substring(j+h.length);else if(g=this.diff_main(h,g,!1),h.length>this.Match_MaxBits&&this.diff_levenshtein(g)/h.length>this.Patch_DeleteThreshold)e[f]=!1;else{this.diff_cleanupSemanticLossless(g);for(var h=0,k,i=0;i<a[f].diffs.length;i++){var q=a[f].diffs[i];0!==q[0]&&(k=this.diff_xIndex(g,h));1===q[0]?b=b.substring(0,
	j+k)+q[1]+b.substring(j+k):-1===q[0]&&(b=b.substring(0,j+k)+b.substring(j+this.diff_xIndex(g,h+q[1].length)));-1!==q[0]&&(h+=q[1].length)}}}b=b.substring(c.length,b.length-c.length);return[b,e]};
	diff_match_patch.prototype.patch_addPadding=function(a){for(var b=this.Patch_Margin,c="",d=1;d<=b;d++)c+=String.fromCharCode(d);for(d=0;d<a.length;d++)a[d].start1+=b,a[d].start2+=b;var d=a[0],e=d.diffs;if(0==e.length||0!=e[0][0])e.unshift([0,c]),d.start1-=b,d.start2-=b,d.length1+=b,d.length2+=b;else if(b>e[0][1].length){var f=b-e[0][1].length;e[0][1]=c.substring(e[0][1].length)+e[0][1];d.start1-=f;d.start2-=f;d.length1+=f;d.length2+=f}d=a[a.length-1];e=d.diffs;0==e.length||0!=e[e.length-1][0]?(e.push([0,
	c]),d.length1+=b,d.length2+=b):b>e[e.length-1][1].length&&(f=b-e[e.length-1][1].length,e[e.length-1][1]+=c.substring(0,f),d.length1+=f,d.length2+=f);return c};
	diff_match_patch.prototype.patch_splitMax=function(a){for(var b=this.Match_MaxBits,c=0;c<a.length;c++)if(!(a[c].length1<=b)){var d=a[c];a.splice(c--,1);for(var e=d.start1,f=d.start2,g="";0!==d.diffs.length;){var h=new diff_match_patch.patch_obj,j=!0;h.start1=e-g.length;h.start2=f-g.length;""!==g&&(h.length1=h.length2=g.length,h.diffs.push([0,g]));for(;0!==d.diffs.length&&h.length1<b-this.Patch_Margin;){var g=d.diffs[0][0],i=d.diffs[0][1];1===g?(h.length2+=i.length,f+=i.length,h.diffs.push(d.diffs.shift()),
	j=!1):-1===g&&1==h.diffs.length&&0==h.diffs[0][0]&&i.length>2*b?(h.length1+=i.length,e+=i.length,j=!1,h.diffs.push([g,i]),d.diffs.shift()):(i=i.substring(0,b-h.length1-this.Patch_Margin),h.length1+=i.length,e+=i.length,0===g?(h.length2+=i.length,f+=i.length):j=!1,h.diffs.push([g,i]),i==d.diffs[0][1]?d.diffs.shift():d.diffs[0][1]=d.diffs[0][1].substring(i.length))}g=this.diff_text2(h.diffs);g=g.substring(g.length-this.Patch_Margin);i=this.diff_text1(d.diffs).substring(0,this.Patch_Margin);""!==i&&
	(h.length1+=i.length,h.length2+=i.length,0!==h.diffs.length&&0===h.diffs[h.diffs.length-1][0]?h.diffs[h.diffs.length-1][1]+=i:h.diffs.push([0,i]));j||a.splice(++c,0,h)}}};diff_match_patch.prototype.patch_toText=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=a[c];return b.join("")};
	diff_match_patch.prototype.patch_fromText=function(a){var b=[];if(!a)return b;a=a.split("\n");for(var c=0,d=/^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;c<a.length;){var e=a[c].match(d);if(!e)throw Error("Invalid patch string: "+a[c]);var f=new diff_match_patch.patch_obj;b.push(f);f.start1=parseInt(e[1],10);""===e[2]?(f.start1--,f.length1=1):"0"==e[2]?f.length1=0:(f.start1--,f.length1=parseInt(e[2],10));f.start2=parseInt(e[3],10);""===e[4]?(f.start2--,f.length2=1):"0"==e[4]?f.length2=0:(f.start2--,f.length2=
	parseInt(e[4],10));for(c++;c<a.length;){e=a[c].charAt(0);try{var g=decodeURI(a[c].substring(1))}catch(h){throw Error("Illegal escape in patch_fromText: "+g);}if("-"==e)f.diffs.push([-1,g]);else if("+"==e)f.diffs.push([1,g]);else if(" "==e)f.diffs.push([0,g]);else if("@"==e)break;else if(""!==e)throw Error('Invalid patch mode "'+e+'" in: '+g);c++}}return b};diff_match_patch.patch_obj=function(){this.diffs=[];this.start2=this.start1=null;this.length2=this.length1=0};
	diff_match_patch.patch_obj.prototype.toString=function(){var a,b;a=0===this.length1?this.start1+",0":1==this.length1?this.start1+1:this.start1+1+","+this.length1;b=0===this.length2?this.start2+",0":1==this.length2?this.start2+1:this.start2+1+","+this.length2;a=["@@ -"+a+" +"+b+" @@\n"];var c;for(b=0;b<this.diffs.length;b++){switch(this.diffs[b][0]){case 1:c="+";break;case -1:c="-";break;case 0:c=" "}a[b+1]=c+encodeURI(this.diffs[b][1])+"\n"}return a.join("").replace(/%20/g," ")};
	this.diff_match_patch=diff_match_patch;this.DIFF_DELETE=-1;this.DIFF_INSERT=1;this.DIFF_EQUAL=0;})()


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	// code mirror plugin for jscs / ESLint

	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(1));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["./node_modules/codemirror/lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})
	(function(CodeMirror) {
		"use strict";

		function validator(text, options) {
			return options.checker(text, options);
		}

		CodeMirror.processJscsChecks = function(linter, text) {
			var jscsErrors = linter( text );

			if (!jscsErrors) return [];

			var errorList = jscsErrors.getErrorList();

	  		var hintErrors;

	  		// convert to Code mirror lint errors format
			hintErrors = errorList.map(function(error) {

				// error.message
				return {
					message: jscsErrors.explainError(error)
					 + ' \n\n(Rule: ' + error.rule + ')\n ',
					// severity: 'warning',
					from: CodeMirror.Pos(error.line - 1, error.column),
				}

			});

			return hintErrors;
		}

		CodeMirror.registerHelper("lint", "javascript", validator);

		CodeMirror.asyncValidator = function(text, updateLinting, options, cm) {
			options.requestValidation(text, function(text) {
				var lints = validator(text, options)
				updateLinting(cm, lints)
			});
		}

	});

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	window.CodeMirror = __webpack_require__(1);
	window.JscsStringChecker = __webpack_require__(19);


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var defaultEsprima = __webpack_require__(20);
	var harmonyEsprima = __webpack_require__(21);
	var Errors = __webpack_require__(22);
	var JsFile = __webpack_require__(39);
	var Configuration = __webpack_require__(42);

	var MAX_FIX_ATTEMPTS = 5;

	/**
	 * Starts Code Style checking process.
	 *
	 * @name StringChecker
	 *
	 * Following params are deprecated, should be removed in 2.0
	 * @param {Boolean|Object} options either a boolean flag representing verbosity (deprecated), or an options object
	 * @param {Boolean} options.verbose true adds the rule name to the error messages it produces, false does not
	 * @param {Boolean} options.esnext true attempts to parse the code as es6, false does not
	 * @param {Object} options.esprima if provided, will be used to parse source code instead of the built-in esprima parser
	 */
	var StringChecker = function(options) {
	    this._configuredRules = [];

	    this._errorsFound = 0;
	    this._maxErrorsExceeded = false;

	    this._configuration = this._createConfiguration();
	    this._configuration.registerDefaultPresets();

	    if (typeof options === 'boolean') {
	        this._verbose = options;
	    } else {
	        options = options || {};
	        this._verbose = options.verbose || false;
	        this._esprima = options.esprima || (options.esnext ? harmonyEsprima : defaultEsprima);
	    }
	};

	StringChecker.prototype = {
	    /**
	     * Registers single Code Style checking rule.
	     *
	     * @param {Rule} rule
	     */
	    registerRule: function(rule) {
	        this._configuration.registerRule(rule);
	    },

	    /**
	     * Registers built-in Code Style checking rules.
	     */
	    registerDefaultRules: function() {
	        this._configuration.registerDefaultRules();
	    },

	    /**
	     * Get processed config.
	     *
	     * @return {Object}
	     */
	    getProcessedConfig: function() {
	        return this._configuration.getProcessedConfig();
	    },

	    /**
	     * Loads configuration from JS Object. Activates and configures required rules.
	     *
	     * @param {Object} config
	     */
	    configure: function(config) {
	        this._configuration.load(config);

	        if (this._configuration.hasCustomEsprima()) {
	            this._esprima = this._configuration.getCustomEsprima();
	        } else if (this._configuration.isESNextEnabled()) {
	            this._esprima = harmonyEsprima;
	        }

	        if (this._verbose === false) {
	            this._verbose = this._configuration.getVerbose();
	        }

	        this._configuredRules = this._configuration.getConfiguredRules();
	        this._maxErrors = this._configuration.getMaxErrors();
	    },

	    /**
	     * Checks file provided with a string.
	     * @param {String} source
	     * @param {String} [filename='input']
	     * @returns {Errors}
	     */
	    checkString: function(source, filename) {
	        filename = filename || 'input';

	        var sourceTree;
	        var parseError;

	        try {
	            sourceTree = JsFile.parse(source, this._esprima, this._configuration.getEsprimaOptions());
	        } catch (e) {
	            parseError = e;
	        }

	        var file = this._createJsFileInstance(filename, source, sourceTree);

	        var errors = new Errors(file, this._verbose);

	        if (this._maxErrorsExceeded) {
	            return errors;
	        }

	        if (parseError) {
	            this._addParseError(errors, parseError);
	            return errors;
	        }

	        this._checkJsFile(file, errors);

	        return errors;
	    },

	    /**
	     * Checks a file specified using JsFile instance.
	     * Fills Errors instance with validation errors.
	     *
	     * @param {JsFile} file
	     * @param {Errors} errors
	     * @private
	     */
	    _checkJsFile: function(file, errors) {
	        if (this._maxErrorsExceeded) {
	            return;
	        }

	        var errorFilter = this._configuration.getErrorFilter();

	        this._configuredRules.forEach(function(rule) {
	            errors.setCurrentRule(rule.getOptionName());

	            try {
	                rule.check(file, errors);
	            } catch (e) {
	                errors.add('Error running rule ' + rule.getOptionName() + ': ' +
	                    'This is an issue with JSCS and not your codebase.\n' +
	                    'Please file an issue (with the stack trace below) at: ' +
	                    'https://github.com/jscs-dev/node-jscs/issues/new\n' +
	                    e.stack, 1, 0);
	            }
	        }, this);

	        this._configuration.getUnsupportedRuleNames().forEach(function(rulename) {
	            errors.add('Unsupported rule: ' + rulename, 1, 0);
	        });

	        // sort errors list to show errors as they appear in source
	        errors.getErrorList().sort(function(a, b) {
	            return (a.line - b.line) || (a.column - b.column);
	        });

	        if (errorFilter) {
	            errors.filter(errorFilter);
	        }

	        if (this._maxErrorsEnabled()) {
	            this._maxErrorsExceeded = this._errorsFound + errors.getErrorCount() > this._maxErrors;
	            errors.stripErrorList(Math.max(0, this._maxErrors - this._errorsFound));
	        }

	        this._errorsFound += errors.getErrorCount();
	    },

	    /**
	     * Adds parse error to the error list.
	     *
	     * @param {Errors} errors
	     * @param {Error} parseError
	     * @private
	     */
	    _addParseError: function(errors, parseError) {
	        if (this._maxErrorsExceeded) {
	            return;
	        }

	        errors.setCurrentRule('parseError');
	        errors.add(parseError.description, parseError.lineNumber, parseError.column);

	        if (this._maxErrorsEnabled()) {
	            this._errorsFound += 1;
	            this._maxErrorsExceeded = this._errorsFound >= this._maxErrors;
	        }
	    },

	    /**
	     * Creates configured JsFile instance.
	     *
	     * @param {String} filename
	     * @param {String} source
	     * @param {Object} sourceTree
	     * @private
	     */
	    _createJsFileInstance: function(filename, source, sourceTree) {
	        return new JsFile(filename, source, sourceTree, {
	            es3: this._configuration.isES3Enabled(),
	            es6: this._configuration.isESNextEnabled()
	        });
	    },

	    /**
	     * Checks file provided with a string.
	     * @param {String} source
	     * @param {String} [filename='input']
	     * @returns {{output: String, errors: Errors}}
	     */
	    fixString: function(source, filename) {
	        if (this._maxErrorsEnabled()) {
	            throw new Error('Cannot autofix when `maxError` option is enabled');
	        }

	        filename = filename || 'input';

	        var sourceTree;
	        var parseError;

	        try {
	            sourceTree = JsFile.parse(source, this._esprima, this._configuration.getEsprimaOptions());
	        } catch (e) {
	            parseError = e;
	        }

	        if (parseError) {
	            var parseErrors = new Errors(this._createJsFileInstance(filename, source, sourceTree), this._verbose);
	            this._addParseError(parseErrors, parseError);
	            return {output: source, errors: parseErrors};
	        } else {
	            var attempt = 0;
	            var errors;
	            var file;

	            do {
	                file = this._createJsFileInstance(filename, source, sourceTree);
	                errors = new Errors(file, this._verbose);

	                // Changes to current sources are made in rules through assertions.
	                this._checkJsFile(file, errors);

	                var hasFixes = errors.getErrorList().some(function(err) {
	                    return err.fixed;
	                });

	                if (!hasFixes) {
	                    break;
	                }

	                source = file.render();
	                sourceTree = JsFile.parse(source, this._esprima, this._configuration.getEsprimaOptions());

	                attempt++;
	            } while (attempt < MAX_FIX_ATTEMPTS);

	            return {output: source, errors: errors};
	        }
	    },

	    /**
	     * Returns `true` if max erros limit is enabled.
	     *
	     * @returns {Boolean}
	     */
	    _maxErrorsEnabled: function() {
	        return this._maxErrors !== null && !isNaN(this._maxErrors);
	    },

	    /**
	     * Returns `true` if error count exceeded `maxErrors` option value.
	     *
	     * @returns {Boolean}
	     */
	    maxErrorsExceeded: function() {
	        return this._maxErrorsExceeded;
	    },

	    /**
	     * Returns new configuration instance.
	     *
	     * @protected
	     * @returns {Configuration}
	     */
	    _createConfiguration: function() {
	        return new Configuration();
	    },

	    /**
	     * Returns current configuration instance.
	     *
	     * @returns {Configuration}
	     */
	    getConfiguration: function() {
	        return this._configuration;
	    }
	};

	module.exports = StringChecker;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
	  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
	  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
	  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
	  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
	  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
	  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
	  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	/*jslint bitwise:true plusplus:true */
	/*global esprima:true, define:true, exports:true, window: true,
	throwErrorTolerant: true,
	throwError: true, generateStatement: true, peek: true,
	parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
	parseFunctionDeclaration: true, parseFunctionExpression: true,
	parseFunctionSourceElements: true, parseVariableIdentifier: true,
	parseLeftHandSideExpression: true,
	parseUnaryExpression: true,
	parseStatement: true, parseSourceElement: true */

	(function (root, factory) {
	    'use strict';

	    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
	    // Rhino, and plain browser loading.

	    /* istanbul ignore next */
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== 'undefined') {
	        factory(exports);
	    } else {
	        factory((root.esprima = {}));
	    }
	}(this, function (exports) {
	    'use strict';

	    var Token,
	        TokenName,
	        FnExprTokens,
	        Syntax,
	        PropertyKind,
	        Messages,
	        Regex,
	        SyntaxTreeDelegate,
	        source,
	        strict,
	        index,
	        lineNumber,
	        lineStart,
	        length,
	        delegate,
	        lookahead,
	        state,
	        extra;

	    Token = {
	        BooleanLiteral: 1,
	        EOF: 2,
	        Identifier: 3,
	        Keyword: 4,
	        NullLiteral: 5,
	        NumericLiteral: 6,
	        Punctuator: 7,
	        StringLiteral: 8,
	        RegularExpression: 9
	    };

	    TokenName = {};
	    TokenName[Token.BooleanLiteral] = 'Boolean';
	    TokenName[Token.EOF] = '<end>';
	    TokenName[Token.Identifier] = 'Identifier';
	    TokenName[Token.Keyword] = 'Keyword';
	    TokenName[Token.NullLiteral] = 'Null';
	    TokenName[Token.NumericLiteral] = 'Numeric';
	    TokenName[Token.Punctuator] = 'Punctuator';
	    TokenName[Token.StringLiteral] = 'String';
	    TokenName[Token.RegularExpression] = 'RegularExpression';

	    // A function following one of those tokens is an expression.
	    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	                    'return', 'case', 'delete', 'throw', 'void',
	                    // assignment operators
	                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
	                    '&=', '|=', '^=', ',',
	                    // binary/unary operators
	                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	                    '<=', '<', '>', '!=', '!=='];

	    Syntax = {
	        AssignmentExpression: 'AssignmentExpression',
	        ArrayExpression: 'ArrayExpression',
	        BlockStatement: 'BlockStatement',
	        BinaryExpression: 'BinaryExpression',
	        BreakStatement: 'BreakStatement',
	        CallExpression: 'CallExpression',
	        CatchClause: 'CatchClause',
	        ConditionalExpression: 'ConditionalExpression',
	        ContinueStatement: 'ContinueStatement',
	        DoWhileStatement: 'DoWhileStatement',
	        DebuggerStatement: 'DebuggerStatement',
	        EmptyStatement: 'EmptyStatement',
	        ExpressionStatement: 'ExpressionStatement',
	        ForStatement: 'ForStatement',
	        ForInStatement: 'ForInStatement',
	        FunctionDeclaration: 'FunctionDeclaration',
	        FunctionExpression: 'FunctionExpression',
	        Identifier: 'Identifier',
	        IfStatement: 'IfStatement',
	        Literal: 'Literal',
	        LabeledStatement: 'LabeledStatement',
	        LogicalExpression: 'LogicalExpression',
	        MemberExpression: 'MemberExpression',
	        NewExpression: 'NewExpression',
	        ObjectExpression: 'ObjectExpression',
	        Program: 'Program',
	        Property: 'Property',
	        ReturnStatement: 'ReturnStatement',
	        SequenceExpression: 'SequenceExpression',
	        SwitchStatement: 'SwitchStatement',
	        SwitchCase: 'SwitchCase',
	        ThisExpression: 'ThisExpression',
	        ThrowStatement: 'ThrowStatement',
	        TryStatement: 'TryStatement',
	        UnaryExpression: 'UnaryExpression',
	        UpdateExpression: 'UpdateExpression',
	        VariableDeclaration: 'VariableDeclaration',
	        VariableDeclarator: 'VariableDeclarator',
	        WhileStatement: 'WhileStatement',
	        WithStatement: 'WithStatement'
	    };

	    PropertyKind = {
	        Data: 1,
	        Get: 2,
	        Set: 4
	    };

	    // Error messages should be identical to V8.
	    Messages = {
	        UnexpectedToken:  'Unexpected token %0',
	        UnexpectedNumber:  'Unexpected number',
	        UnexpectedString:  'Unexpected string',
	        UnexpectedIdentifier:  'Unexpected identifier',
	        UnexpectedReserved:  'Unexpected reserved word',
	        UnexpectedEOS:  'Unexpected end of input',
	        NewlineAfterThrow:  'Illegal newline after throw',
	        InvalidRegExp: 'Invalid regular expression',
	        UnterminatedRegExp:  'Invalid regular expression: missing /',
	        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
	        InvalidLHSInForIn:  'Invalid left-hand side in for-in',
	        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	        NoCatchOrFinally:  'Missing catch or finally after try',
	        UnknownLabel: 'Undefined label \'%0\'',
	        Redeclaration: '%0 \'%1\' has already been declared',
	        IllegalContinue: 'Illegal continue statement',
	        IllegalBreak: 'Illegal break statement',
	        IllegalReturn: 'Illegal return statement',
	        StrictModeWith:  'Strict mode code may not include a with statement',
	        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
	        StrictVarName:  'Variable name may not be eval or arguments in strict mode',
	        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
	        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
	        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
	        StrictDelete:  'Delete of an unqualified identifier in strict mode.',
	        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
	        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
	        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
	        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
	        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictReservedWord:  'Use of future reserved word in strict mode'
	    };

	    // See also tools/generate-unicode-regex.py.
	    Regex = {
	        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
	        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
	    };

	    // Ensure the condition is true, otherwise throw an error.
	    // This is only to have a better contract semantic, i.e. another safety net
	    // to catch a logic error. The condition shall be fulfilled in normal case.
	    // Do NOT use this to enforce a certain condition on any user input.

	    function assert(condition, message) {
	        /* istanbul ignore if */
	        if (!condition) {
	            throw new Error('ASSERT: ' + message);
	        }
	    }

	    function isDecimalDigit(ch) {
	        return (ch >= 48 && ch <= 57);   // 0..9
	    }

	    function isHexDigit(ch) {
	        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
	    }

	    function isOctalDigit(ch) {
	        return '01234567'.indexOf(ch) >= 0;
	    }


	    // 7.2 White Space

	    function isWhiteSpace(ch) {
	        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
	            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
	    }

	    // 7.3 Line Terminators

	    function isLineTerminator(ch) {
	        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
	    }

	    // 7.6 Identifier Names and Identifiers

	    function isIdentifierStart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
	    }

	    function isIdentifierPart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
	    }

	    // 7.6.1.2 Future Reserved Words

	    function isFutureReservedWord(id) {
	        switch (id) {
	        case 'class':
	        case 'enum':
	        case 'export':
	        case 'extends':
	        case 'import':
	        case 'super':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isStrictModeReservedWord(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'yield':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }

	    // 7.6.1.1 Keywords

	    function isKeyword(id) {
	        if (strict && isStrictModeReservedWord(id)) {
	            return true;
	        }

	        // 'const' is specialized as Keyword in V8.
	        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
	        // Some others are from future reserved words.

	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') ||
	                (id === 'try') || (id === 'let');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }

	    // 7.4 Comments

	    function addComment(type, value, start, end, loc) {
	        var comment, attacher;

	        assert(typeof start === 'number', 'Comment must have valid position');

	        // Because the way the actual token is scanned, often the comments
	        // (if any) are skipped twice during the lexical analysis.
	        // Thus, we need to skip adding a comment if the comment array already
	        // handled it.
	        if (state.lastCommentStart >= start) {
	            return;
	        }
	        state.lastCommentStart = start;

	        comment = {
	            type: type,
	            value: value
	        };
	        if (extra.range) {
	            comment.range = [start, end];
	        }
	        if (extra.loc) {
	            comment.loc = loc;
	        }
	        extra.comments.push(comment);
	        if (extra.attachComment) {
	            extra.leadingComments.push(comment);
	            extra.trailingComments.push(comment);
	        }
	    }

	    function skipSingleLineComment(offset) {
	        var start, loc, ch, comment;

	        start = index - offset;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart - offset
	            }
	        };

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            ++index;
	            if (isLineTerminator(ch)) {
	                if (extra.comments) {
	                    comment = source.slice(start + offset, index - 1);
	                    loc.end = {
	                        line: lineNumber,
	                        column: index - lineStart - 1
	                    };
	                    addComment('Line', comment, start, index - 1, loc);
	                }
	                if (ch === 13 && source.charCodeAt(index) === 10) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                return;
	            }
	        }

	        if (extra.comments) {
	            comment = source.slice(start + offset, index);
	            loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	            };
	            addComment('Line', comment, start, index, loc);
	        }
	    }

	    function skipMultiLineComment() {
	        var start, loc, ch, comment;

	        if (extra.comments) {
	            start = index - 2;
	            loc = {
	                start: {
	                    line: lineNumber,
	                    column: index - lineStart - 2
	                }
	            };
	        }

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (isLineTerminator(ch)) {
	                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
	                    ++index;
	                }
	                ++lineNumber;
	                ++index;
	                lineStart = index;
	                if (index >= length) {
	                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	            } else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (source.charCodeAt(index + 1) === 0x2F) {
	                    ++index;
	                    ++index;
	                    if (extra.comments) {
	                        comment = source.slice(start + 2, index - 2);
	                        loc.end = {
	                            line: lineNumber,
	                            column: index - lineStart
	                        };
	                        addComment('Block', comment, start, index, loc);
	                    }
	                    return;
	                }
	                ++index;
	            } else {
	                ++index;
	            }
	        }

	        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	    }

	    function skipComment() {
	        var ch, start;

	        start = (index === 0);
	        while (index < length) {
	            ch = source.charCodeAt(index);

	            if (isWhiteSpace(ch)) {
	                ++index;
	            } else if (isLineTerminator(ch)) {
	                ++index;
	                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                start = true;
	            } else if (ch === 0x2F) { // U+002F is '/'
	                ch = source.charCodeAt(index + 1);
	                if (ch === 0x2F) {
	                    ++index;
	                    ++index;
	                    skipSingleLineComment(2);
	                    start = true;
	                } else if (ch === 0x2A) {  // U+002A is '*'
	                    ++index;
	                    ++index;
	                    skipMultiLineComment();
	                } else {
	                    break;
	                }
	            } else if (start && ch === 0x2D) { // U+002D is '-'
	                // U+003E is '>'
	                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    index += 3;
	                    skipSingleLineComment(3);
	                } else {
	                    break;
	                }
	            } else if (ch === 0x3C) { // U+003C is '<'
	                if (source.slice(index + 1, index + 4) === '!--') {
	                    ++index; // `<`
	                    ++index; // `!`
	                    ++index; // `-`
	                    ++index; // `-`
	                    skipSingleLineComment(4);
	                } else {
	                    break;
	                }
	            } else {
	                break;
	            }
	        }
	    }

	    function scanHexEscape(prefix) {
	        var i, len, ch, code = 0;

	        len = (prefix === 'u') ? 4 : 2;
	        for (i = 0; i < len; ++i) {
	            if (index < length && isHexDigit(source[index])) {
	                ch = source[index++];
	                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	            } else {
	                return '';
	            }
	        }
	        return String.fromCharCode(code);
	    }

	    function getEscapedIdentifier() {
	        var ch, id;

	        ch = source.charCodeAt(index++);
	        id = String.fromCharCode(ch);

	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        if (ch === 0x5C) {
	            if (source.charCodeAt(index) !== 0x75) {
	                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	            ++index;
	            ch = scanHexEscape('u');
	            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
	                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	            id = ch;
	        }

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (!isIdentifierPart(ch)) {
	                break;
	            }
	            ++index;
	            id += String.fromCharCode(ch);

	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (ch === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (source.charCodeAt(index) !== 0x75) {
	                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	                ++index;
	                ch = scanHexEscape('u');
	                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
	                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	                id += ch;
	            }
	        }

	        return id;
	    }

	    function getIdentifier() {
	        var start, ch;

	        start = index++;
	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                index = start;
	                return getEscapedIdentifier();
	            }
	            if (isIdentifierPart(ch)) {
	                ++index;
	            } else {
	                break;
	            }
	        }

	        return source.slice(start, index);
	    }

	    function scanIdentifier() {
	        var start, id, type;

	        start = index;

	        // Backslash (U+005C) starts an escaped character.
	        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = Token.Identifier;
	        } else if (isKeyword(id)) {
	            type = Token.Keyword;
	        } else if (id === 'null') {
	            type = Token.NullLiteral;
	        } else if (id === 'true' || id === 'false') {
	            type = Token.BooleanLiteral;
	        } else {
	            type = Token.Identifier;
	        }

	        return {
	            type: type,
	            value: id,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }


	    // 7.7 Punctuators

	    function scanPunctuator() {
	        var start = index,
	            code = source.charCodeAt(index),
	            code2,
	            ch1 = source[index],
	            ch2,
	            ch3,
	            ch4;

	        switch (code) {

	        // Check for most common single-character punctuators.
	        case 0x2E:  // . dot
	        case 0x28:  // ( open bracket
	        case 0x29:  // ) close bracket
	        case 0x3B:  // ; semicolon
	        case 0x2C:  // , comma
	        case 0x7B:  // { open curly brace
	        case 0x7D:  // } close curly brace
	        case 0x5B:  // [
	        case 0x5D:  // ]
	        case 0x3A:  // :
	        case 0x3F:  // ?
	        case 0x7E:  // ~
	            ++index;
	            if (extra.tokenize) {
	                if (code === 0x28) {
	                    extra.openParenToken = extra.tokens.length;
	                } else if (code === 0x7B) {
	                    extra.openCurlyToken = extra.tokens.length;
	                }
	            }
	            return {
	                type: Token.Punctuator,
	                value: String.fromCharCode(code),
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };

	        default:
	            code2 = source.charCodeAt(index + 1);

	            // '=' (U+003D) marks an assignment or comparison operator.
	            if (code2 === 0x3D) {
	                switch (code) {
	                case 0x2B:  // +
	                case 0x2D:  // -
	                case 0x2F:  // /
	                case 0x3C:  // <
	                case 0x3E:  // >
	                case 0x5E:  // ^
	                case 0x7C:  // |
	                case 0x25:  // %
	                case 0x26:  // &
	                case 0x2A:  // *
	                    index += 2;
	                    return {
	                        type: Token.Punctuator,
	                        value: String.fromCharCode(code) + String.fromCharCode(code2),
	                        lineNumber: lineNumber,
	                        lineStart: lineStart,
	                        start: start,
	                        end: index
	                    };

	                case 0x21: // !
	                case 0x3D: // =
	                    index += 2;

	                    // !== and ===
	                    if (source.charCodeAt(index) === 0x3D) {
	                        ++index;
	                    }
	                    return {
	                        type: Token.Punctuator,
	                        value: source.slice(start, index),
	                        lineNumber: lineNumber,
	                        lineStart: lineStart,
	                        start: start,
	                        end: index
	                    };
	                }
	            }
	        }

	        // 4-character punctuator: >>>=

	        ch4 = source.substr(index, 4);

	        if (ch4 === '>>>=') {
	            index += 4;
	            return {
	                type: Token.Punctuator,
	                value: ch4,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }

	        // 3-character punctuators: === !== >>> <<= >>=

	        ch3 = ch4.substr(0, 3);

	        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
	            index += 3;
	            return {
	                type: Token.Punctuator,
	                value: ch3,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }

	        // Other 2-character punctuators: ++ -- << >> && ||
	        ch2 = ch3.substr(0, 2);

	        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {
	            index += 2;
	            return {
	                type: Token.Punctuator,
	                value: ch2,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }

	        // 1-character punctuators: < > = ! + - * % & | ^ /
	        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
	            ++index;
	            return {
	                type: Token.Punctuator,
	                value: ch1,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }

	        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	    }

	    // 7.8.3 Numeric Literals

	    function scanHexLiteral(start) {
	        var number = '';

	        while (index < length) {
	            if (!isHexDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }

	        if (number.length === 0) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt('0x' + number, 16),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function scanOctalLiteral(start) {
	        var number = '0' + source[index++];
	        while (index < length) {
	            if (!isOctalDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }

	        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 8),
	            octal: true,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function isImplicitOctalLiteral() {
	        var i, ch;

	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (i = index + 1; i < length; ++i) {
	            ch = source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!isOctalDigit(ch)) {
	                return true;
	            }
	        }

	        return true;
	    }

	    function scanNumericLiteral() {
	        var number, start, ch;

	        ch = source[index];
	        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
	            'Numeric literal must start with a decimal digit or a decimal point');

	        start = index;
	        number = '';
	        if (ch !== '.') {
	            number = source[index++];
	            ch = source[index];

	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            if (number === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++index;
	                    return scanHexLiteral(start);
	                }
	                if (isOctalDigit(ch)) {
	                    if (isImplicitOctalLiteral()) {
	                        return scanOctalLiteral(start);
	                    }
	                }
	            }

	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }

	        if (ch === '.') {
	            number += source[index++];
	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }

	        if (ch === 'e' || ch === 'E') {
	            number += source[index++];

	            ch = source[index];
	            if (ch === '+' || ch === '-') {
	                number += source[index++];
	            }
	            if (isDecimalDigit(source.charCodeAt(index))) {
	                while (isDecimalDigit(source.charCodeAt(index))) {
	                    number += source[index++];
	                }
	            } else {
	                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	        }

	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseFloat(number),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    // 7.8.4 String Literals

	    function scanStringLiteral() {
	        var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;

	        quote = source[index];
	        assert((quote === '\'' || quote === '"'),
	            'String literal must starts with a quote');

	        start = index;
	        ++index;

	        while (index < length) {
	            ch = source[index++];

	            if (ch === quote) {
	                quote = '';
	                break;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'u':
	                    case 'x':
	                        restore = index;
	                        unescaped = scanHexEscape(ch);
	                        if (unescaped) {
	                            str += unescaped;
	                        } else {
	                            index = restore;
	                            str += ch;
	                        }
	                        break;
	                    case 'n':
	                        str += '\n';
	                        break;
	                    case 'r':
	                        str += '\r';
	                        break;
	                    case 't':
	                        str += '\t';
	                        break;
	                    case 'b':
	                        str += '\b';
	                        break;
	                    case 'f':
	                        str += '\f';
	                        break;
	                    case 'v':
	                        str += '\x0B';
	                        break;

	                    default:
	                        if (isOctalDigit(ch)) {
	                            code = '01234567'.indexOf(ch);

	                            // \0 is not octal escape sequence
	                            if (code !== 0) {
	                                octal = true;
	                            }

	                            if (index < length && isOctalDigit(source[index])) {
	                                octal = true;
	                                code = code * 8 + '01234567'.indexOf(source[index++]);

	                                // 3 digits are only allowed when string starts
	                                // with 0, 1, 2, 3
	                                if ('0123'.indexOf(ch) >= 0 &&
	                                        index < length &&
	                                        isOctalDigit(source[index])) {
	                                    code = code * 8 + '01234567'.indexOf(source[index++]);
	                                }
	                            }
	                            str += String.fromCharCode(code);
	                        } else {
	                            str += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch ===  '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            } else {
	                str += ch;
	            }
	        }

	        if (quote !== '') {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        return {
	            type: Token.StringLiteral,
	            value: str,
	            octal: octal,
	            startLineNumber: startLineNumber,
	            startLineStart: startLineStart,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function testRegExp(pattern, flags) {
	        var value;
	        try {
	            value = new RegExp(pattern, flags);
	        } catch (e) {
	            throwError({}, Messages.InvalidRegExp);
	        }
	        return value;
	    }

	    function scanRegExpBody() {
	        var ch, str, classMarker, terminated, body;

	        ch = source[index];
	        assert(ch === '/', 'Regular expression literal must start with a slash');
	        str = source[index++];

	        classMarker = false;
	        terminated = false;
	        while (index < length) {
	            ch = source[index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = source[index++];
	                // ECMA-262 7.8.5
	                if (isLineTerminator(ch.charCodeAt(0))) {
	                    throwError({}, Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                throwError({}, Messages.UnterminatedRegExp);
	            } else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            } else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                } else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }

	        if (!terminated) {
	            throwError({}, Messages.UnterminatedRegExp);
	        }

	        // Exclude leading and trailing slash.
	        body = str.substr(1, str.length - 2);
	        return {
	            value: body,
	            literal: str
	        };
	    }

	    function scanRegExpFlags() {
	        var ch, str, flags, restore;

	        str = '';
	        flags = '';
	        while (index < length) {
	            ch = source[index];
	            if (!isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }

	            ++index;
	            if (ch === '\\' && index < length) {
	                ch = source[index];
	                if (ch === 'u') {
	                    ++index;
	                    restore = index;
	                    ch = scanHexEscape('u');
	                    if (ch) {
	                        flags += ch;
	                        for (str += '\\u'; restore < index; ++restore) {
	                            str += source[restore];
	                        }
	                    } else {
	                        index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
	                } else {
	                    str += '\\';
	                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	            } else {
	                flags += ch;
	                str += ch;
	            }
	        }

	        return {
	            value: flags,
	            literal: str
	        };
	    }

	    function scanRegExp() {
	        var start, body, flags, pattern, value;

	        lookahead = null;
	        skipComment();
	        start = index;

	        body = scanRegExpBody();
	        flags = scanRegExpFlags();
	        value = testRegExp(body.value, flags.value);

	        if (extra.tokenize) {
	            return {
	                type: Token.RegularExpression,
	                value: value,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }

	        return {
	            literal: body.literal + flags.literal,
	            value: value,
	            start: start,
	            end: index
	        };
	    }

	    function collectRegex() {
	        var pos, loc, regex, token;

	        skipComment();

	        pos = index;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };

	        regex = scanRegExp();
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };

	        /* istanbul ignore next */
	        if (!extra.tokenize) {
	            // Pop the previous token, which is likely '/' or '/='
	            if (extra.tokens.length > 0) {
	                token = extra.tokens[extra.tokens.length - 1];
	                if (token.range[0] === pos && token.type === 'Punctuator') {
	                    if (token.value === '/' || token.value === '/=') {
	                        extra.tokens.pop();
	                    }
	                }
	            }

	            extra.tokens.push({
	                type: 'RegularExpression',
	                value: regex.literal,
	                range: [pos, index],
	                loc: loc
	            });
	        }

	        return regex;
	    }

	    function isIdentifierName(token) {
	        return token.type === Token.Identifier ||
	            token.type === Token.Keyword ||
	            token.type === Token.BooleanLiteral ||
	            token.type === Token.NullLiteral;
	    }

	    function advanceSlash() {
	        var prevToken,
	            checkToken;
	        // Using the following algorithm:
	        // https://github.com/mozilla/sweet.js/wiki/design
	        prevToken = extra.tokens[extra.tokens.length - 1];
	        if (!prevToken) {
	            // Nothing before that: it cannot be a division.
	            return collectRegex();
	        }
	        if (prevToken.type === 'Punctuator') {
	            if (prevToken.value === ']') {
	                return scanPunctuator();
	            }
	            if (prevToken.value === ')') {
	                checkToken = extra.tokens[extra.openParenToken - 1];
	                if (checkToken &&
	                        checkToken.type === 'Keyword' &&
	                        (checkToken.value === 'if' ||
	                         checkToken.value === 'while' ||
	                         checkToken.value === 'for' ||
	                         checkToken.value === 'with')) {
	                    return collectRegex();
	                }
	                return scanPunctuator();
	            }
	            if (prevToken.value === '}') {
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                if (extra.tokens[extra.openCurlyToken - 3] &&
	                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
	                    // Anonymous function.
	                    checkToken = extra.tokens[extra.openCurlyToken - 4];
	                    if (!checkToken) {
	                        return scanPunctuator();
	                    }
	                } else if (extra.tokens[extra.openCurlyToken - 4] &&
	                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
	                    // Named function.
	                    checkToken = extra.tokens[extra.openCurlyToken - 5];
	                    if (!checkToken) {
	                        return collectRegex();
	                    }
	                } else {
	                    return scanPunctuator();
	                }
	                // checkToken determines whether the function is
	                // a declaration or an expression.
	                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
	                    // It is an expression.
	                    return scanPunctuator();
	                }
	                // It is a declaration.
	                return collectRegex();
	            }
	            return collectRegex();
	        }
	        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
	            return collectRegex();
	        }
	        return scanPunctuator();
	    }

	    function advance() {
	        var ch;

	        skipComment();

	        if (index >= length) {
	            return {
	                type: Token.EOF,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: index,
	                end: index
	            };
	        }

	        ch = source.charCodeAt(index);

	        if (isIdentifierStart(ch)) {
	            return scanIdentifier();
	        }

	        // Very common: ( and ) and ;
	        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
	            return scanPunctuator();
	        }

	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (ch === 0x27 || ch === 0x22) {
	            return scanStringLiteral();
	        }


	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (ch === 0x2E) {
	            if (isDecimalDigit(source.charCodeAt(index + 1))) {
	                return scanNumericLiteral();
	            }
	            return scanPunctuator();
	        }

	        if (isDecimalDigit(ch)) {
	            return scanNumericLiteral();
	        }

	        // Slash (/) U+002F can also start a regex.
	        if (extra.tokenize && ch === 0x2F) {
	            return advanceSlash();
	        }

	        return scanPunctuator();
	    }

	    function collectToken() {
	        var loc, token, range, value;

	        skipComment();
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };

	        token = advance();
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };

	        if (token.type !== Token.EOF) {
	            value = source.slice(token.start, token.end);
	            extra.tokens.push({
	                type: TokenName[token.type],
	                value: value,
	                range: [token.start, token.end],
	                loc: loc
	            });
	        }

	        return token;
	    }

	    function lex() {
	        var token;

	        token = lookahead;
	        index = token.end;
	        lineNumber = token.lineNumber;
	        lineStart = token.lineStart;

	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();

	        index = token.end;
	        lineNumber = token.lineNumber;
	        lineStart = token.lineStart;

	        return token;
	    }

	    function peek() {
	        var pos, line, start;

	        pos = index;
	        line = lineNumber;
	        start = lineStart;
	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	        index = pos;
	        lineNumber = line;
	        lineStart = start;
	    }

	    function Position(line, column) {
	        this.line = line;
	        this.column = column;
	    }

	    function SourceLocation(startLine, startColumn, line, column) {
	        this.start = new Position(startLine, startColumn);
	        this.end = new Position(line, column);
	    }

	    SyntaxTreeDelegate = {

	        name: 'SyntaxTree',

	        processComment: function (node) {
	            var lastChild, trailingComments;

	            if (node.type === Syntax.Program) {
	                if (node.body.length > 0) {
	                    return;
	                }
	            }

	            if (extra.trailingComments.length > 0) {
	                if (extra.trailingComments[0].range[0] >= node.range[1]) {
	                    trailingComments = extra.trailingComments;
	                    extra.trailingComments = [];
	                } else {
	                    extra.trailingComments.length = 0;
	                }
	            } else {
	                if (extra.bottomRightStack.length > 0 &&
	                        extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments &&
	                        extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
	                    trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
	                    delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
	                }
	            }

	            // Eating the stack.
	            while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
	                lastChild = extra.bottomRightStack.pop();
	            }

	            if (lastChild) {
	                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
	                    node.leadingComments = lastChild.leadingComments;
	                    delete lastChild.leadingComments;
	                }
	            } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
	                node.leadingComments = extra.leadingComments;
	                extra.leadingComments = [];
	            }


	            if (trailingComments) {
	                node.trailingComments = trailingComments;
	            }

	            extra.bottomRightStack.push(node);
	        },

	        markEnd: function (node, startToken) {
	            if (extra.range) {
	                node.range = [startToken.start, index];
	            }
	            if (extra.loc) {
	                node.loc = new SourceLocation(
	                    startToken.startLineNumber === undefined ?  startToken.lineNumber : startToken.startLineNumber,
	                    startToken.start - (startToken.startLineStart === undefined ?  startToken.lineStart : startToken.startLineStart),
	                    lineNumber,
	                    index - lineStart
	                );
	                this.postProcess(node);
	            }

	            if (extra.attachComment) {
	                this.processComment(node);
	            }
	            return node;
	        },

	        postProcess: function (node) {
	            if (extra.source) {
	                node.loc.source = extra.source;
	            }
	            return node;
	        },

	        createArrayExpression: function (elements) {
	            return {
	                type: Syntax.ArrayExpression,
	                elements: elements
	            };
	        },

	        createAssignmentExpression: function (operator, left, right) {
	            return {
	                type: Syntax.AssignmentExpression,
	                operator: operator,
	                left: left,
	                right: right
	            };
	        },

	        createBinaryExpression: function (operator, left, right) {
	            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :
	                        Syntax.BinaryExpression;
	            return {
	                type: type,
	                operator: operator,
	                left: left,
	                right: right
	            };
	        },

	        createBlockStatement: function (body) {
	            return {
	                type: Syntax.BlockStatement,
	                body: body
	            };
	        },

	        createBreakStatement: function (label) {
	            return {
	                type: Syntax.BreakStatement,
	                label: label
	            };
	        },

	        createCallExpression: function (callee, args) {
	            return {
	                type: Syntax.CallExpression,
	                callee: callee,
	                'arguments': args
	            };
	        },

	        createCatchClause: function (param, body) {
	            return {
	                type: Syntax.CatchClause,
	                param: param,
	                body: body
	            };
	        },

	        createConditionalExpression: function (test, consequent, alternate) {
	            return {
	                type: Syntax.ConditionalExpression,
	                test: test,
	                consequent: consequent,
	                alternate: alternate
	            };
	        },

	        createContinueStatement: function (label) {
	            return {
	                type: Syntax.ContinueStatement,
	                label: label
	            };
	        },

	        createDebuggerStatement: function () {
	            return {
	                type: Syntax.DebuggerStatement
	            };
	        },

	        createDoWhileStatement: function (body, test) {
	            return {
	                type: Syntax.DoWhileStatement,
	                body: body,
	                test: test
	            };
	        },

	        createEmptyStatement: function () {
	            return {
	                type: Syntax.EmptyStatement
	            };
	        },

	        createExpressionStatement: function (expression) {
	            return {
	                type: Syntax.ExpressionStatement,
	                expression: expression
	            };
	        },

	        createForStatement: function (init, test, update, body) {
	            return {
	                type: Syntax.ForStatement,
	                init: init,
	                test: test,
	                update: update,
	                body: body
	            };
	        },

	        createForInStatement: function (left, right, body) {
	            return {
	                type: Syntax.ForInStatement,
	                left: left,
	                right: right,
	                body: body,
	                each: false
	            };
	        },

	        createFunctionDeclaration: function (id, params, defaults, body) {
	            return {
	                type: Syntax.FunctionDeclaration,
	                id: id,
	                params: params,
	                defaults: defaults,
	                body: body,
	                rest: null,
	                generator: false,
	                expression: false
	            };
	        },

	        createFunctionExpression: function (id, params, defaults, body) {
	            return {
	                type: Syntax.FunctionExpression,
	                id: id,
	                params: params,
	                defaults: defaults,
	                body: body,
	                rest: null,
	                generator: false,
	                expression: false
	            };
	        },

	        createIdentifier: function (name) {
	            return {
	                type: Syntax.Identifier,
	                name: name
	            };
	        },

	        createIfStatement: function (test, consequent, alternate) {
	            return {
	                type: Syntax.IfStatement,
	                test: test,
	                consequent: consequent,
	                alternate: alternate
	            };
	        },

	        createLabeledStatement: function (label, body) {
	            return {
	                type: Syntax.LabeledStatement,
	                label: label,
	                body: body
	            };
	        },

	        createLiteral: function (token) {
	            return {
	                type: Syntax.Literal,
	                value: token.value,
	                raw: source.slice(token.start, token.end)
	            };
	        },

	        createMemberExpression: function (accessor, object, property) {
	            return {
	                type: Syntax.MemberExpression,
	                computed: accessor === '[',
	                object: object,
	                property: property
	            };
	        },

	        createNewExpression: function (callee, args) {
	            return {
	                type: Syntax.NewExpression,
	                callee: callee,
	                'arguments': args
	            };
	        },

	        createObjectExpression: function (properties) {
	            return {
	                type: Syntax.ObjectExpression,
	                properties: properties
	            };
	        },

	        createPostfixExpression: function (operator, argument) {
	            return {
	                type: Syntax.UpdateExpression,
	                operator: operator,
	                argument: argument,
	                prefix: false
	            };
	        },

	        createProgram: function (body) {
	            return {
	                type: Syntax.Program,
	                body: body
	            };
	        },

	        createProperty: function (kind, key, value) {
	            return {
	                type: Syntax.Property,
	                key: key,
	                value: value,
	                kind: kind
	            };
	        },

	        createReturnStatement: function (argument) {
	            return {
	                type: Syntax.ReturnStatement,
	                argument: argument
	            };
	        },

	        createSequenceExpression: function (expressions) {
	            return {
	                type: Syntax.SequenceExpression,
	                expressions: expressions
	            };
	        },

	        createSwitchCase: function (test, consequent) {
	            return {
	                type: Syntax.SwitchCase,
	                test: test,
	                consequent: consequent
	            };
	        },

	        createSwitchStatement: function (discriminant, cases) {
	            return {
	                type: Syntax.SwitchStatement,
	                discriminant: discriminant,
	                cases: cases
	            };
	        },

	        createThisExpression: function () {
	            return {
	                type: Syntax.ThisExpression
	            };
	        },

	        createThrowStatement: function (argument) {
	            return {
	                type: Syntax.ThrowStatement,
	                argument: argument
	            };
	        },

	        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
	            return {
	                type: Syntax.TryStatement,
	                block: block,
	                guardedHandlers: guardedHandlers,
	                handlers: handlers,
	                finalizer: finalizer
	            };
	        },

	        createUnaryExpression: function (operator, argument) {
	            if (operator === '++' || operator === '--') {
	                return {
	                    type: Syntax.UpdateExpression,
	                    operator: operator,
	                    argument: argument,
	                    prefix: true
	                };
	            }
	            return {
	                type: Syntax.UnaryExpression,
	                operator: operator,
	                argument: argument,
	                prefix: true
	            };
	        },

	        createVariableDeclaration: function (declarations, kind) {
	            return {
	                type: Syntax.VariableDeclaration,
	                declarations: declarations,
	                kind: kind
	            };
	        },

	        createVariableDeclarator: function (id, init) {
	            return {
	                type: Syntax.VariableDeclarator,
	                id: id,
	                init: init
	            };
	        },

	        createWhileStatement: function (test, body) {
	            return {
	                type: Syntax.WhileStatement,
	                test: test,
	                body: body
	            };
	        },

	        createWithStatement: function (object, body) {
	            return {
	                type: Syntax.WithStatement,
	                object: object,
	                body: body
	            };
	        }
	    };

	    // Return true if there is a line terminator before the next token.

	    function peekLineTerminator() {
	        var pos, line, start, found;

	        pos = index;
	        line = lineNumber;
	        start = lineStart;
	        skipComment();
	        found = lineNumber !== line;
	        index = pos;
	        lineNumber = line;
	        lineStart = start;

	        return found;
	    }

	    // Throw an exception

	    function throwError(token, messageFormat) {
	        var error,
	            args = Array.prototype.slice.call(arguments, 2),
	            msg = messageFormat.replace(
	                /%(\d)/g,
	                function (whole, index) {
	                    assert(index < args.length, 'Message reference must be in range');
	                    return args[index];
	                }
	            );

	        if (typeof token.lineNumber === 'number') {
	            error = new Error('Line ' + token.lineNumber + ': ' + msg);
	            error.index = token.start;
	            error.lineNumber = token.lineNumber;
	            error.column = token.start - lineStart + 1;
	        } else {
	            error = new Error('Line ' + lineNumber + ': ' + msg);
	            error.index = index;
	            error.lineNumber = lineNumber;
	            error.column = index - lineStart + 1;
	        }

	        error.description = msg;
	        throw error;
	    }

	    function throwErrorTolerant() {
	        try {
	            throwError.apply(null, arguments);
	        } catch (e) {
	            if (extra.errors) {
	                extra.errors.push(e);
	            } else {
	                throw e;
	            }
	        }
	    }


	    // Throw an exception because of the token.

	    function throwUnexpected(token) {
	        if (token.type === Token.EOF) {
	            throwError(token, Messages.UnexpectedEOS);
	        }

	        if (token.type === Token.NumericLiteral) {
	            throwError(token, Messages.UnexpectedNumber);
	        }

	        if (token.type === Token.StringLiteral) {
	            throwError(token, Messages.UnexpectedString);
	        }

	        if (token.type === Token.Identifier) {
	            throwError(token, Messages.UnexpectedIdentifier);
	        }

	        if (token.type === Token.Keyword) {
	            if (isFutureReservedWord(token.value)) {
	                throwError(token, Messages.UnexpectedReserved);
	            } else if (strict && isStrictModeReservedWord(token.value)) {
	                throwErrorTolerant(token, Messages.StrictReservedWord);
	                return;
	            }
	            throwError(token, Messages.UnexpectedToken, token.value);
	        }

	        // BooleanLiteral, NullLiteral, or Punctuator.
	        throwError(token, Messages.UnexpectedToken, token.value);
	    }

	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.

	    function expect(value) {
	        var token = lex();
	        if (token.type !== Token.Punctuator || token.value !== value) {
	            throwUnexpected(token);
	        }
	    }

	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.

	    function expectKeyword(keyword) {
	        var token = lex();
	        if (token.type !== Token.Keyword || token.value !== keyword) {
	            throwUnexpected(token);
	        }
	    }

	    // Return true if the next token matches the specified punctuator.

	    function match(value) {
	        return lookahead.type === Token.Punctuator && lookahead.value === value;
	    }

	    // Return true if the next token matches the specified keyword

	    function matchKeyword(keyword) {
	        return lookahead.type === Token.Keyword && lookahead.value === keyword;
	    }

	    // Return true if the next token is an assignment operator

	    function matchAssign() {
	        var op;

	        if (lookahead.type !== Token.Punctuator) {
	            return false;
	        }
	        op = lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    }

	    function consumeSemicolon() {
	        var line, oldIndex = index, oldLineNumber = lineNumber,
	            oldLineStart = lineStart, oldLookahead = lookahead;

	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(index) === 0x3B || match(';')) {
	            lex();
	            return;
	        }

	        line = lineNumber;
	        skipComment();
	        if (lineNumber !== line) {
	            index = oldIndex;
	            lineNumber = oldLineNumber;
	            lineStart = oldLineStart;
	            lookahead = oldLookahead;
	            return;
	        }

	        if (lookahead.type !== Token.EOF && !match('}')) {
	            throwUnexpected(lookahead);
	        }
	    }

	    // Return true if provided expression is LeftHandSideExpression

	    function isLeftHandSide(expr) {
	        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
	    }

	    // 11.1.4 Array Initialiser

	    function parseArrayInitialiser() {
	        var elements = [], startToken;

	        startToken = lookahead;
	        expect('[');

	        while (!match(']')) {
	            if (match(',')) {
	                lex();
	                elements.push(null);
	            } else {
	                elements.push(parseAssignmentExpression());

	                if (!match(']')) {
	                    expect(',');
	                }
	            }
	        }

	        lex();

	        return delegate.markEnd(delegate.createArrayExpression(elements), startToken);
	    }

	    // 11.1.5 Object Initialiser

	    function parsePropertyFunction(param, first) {
	        var previousStrict, body, startToken;

	        previousStrict = strict;
	        startToken = lookahead;
	        body = parseFunctionSourceElements();
	        if (first && strict && isRestrictedWord(param[0].name)) {
	            throwErrorTolerant(first, Messages.StrictParamName);
	        }
	        strict = previousStrict;
	        return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);
	    }

	    function parseObjectPropertyKey() {
	        var token, startToken;

	        startToken = lookahead;
	        token = lex();

	        // Note: This function is called only from parseObjectProperty(), where
	        // EOF and Punctuator tokens are already filtered out.

	        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
	            if (strict && token.octal) {
	                throwErrorTolerant(token, Messages.StrictOctalLiteral);
	            }
	            return delegate.markEnd(delegate.createLiteral(token), startToken);
	        }

	        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
	    }

	    function parseObjectProperty() {
	        var token, key, id, value, param, startToken;

	        token = lookahead;
	        startToken = lookahead;

	        if (token.type === Token.Identifier) {

	            id = parseObjectPropertyKey();

	            // Property Assignment: Getter and Setter.

	            if (token.value === 'get' && !match(':')) {
	                key = parseObjectPropertyKey();
	                expect('(');
	                expect(')');
	                value = parsePropertyFunction([]);
	                return delegate.markEnd(delegate.createProperty('get', key, value), startToken);
	            }
	            if (token.value === 'set' && !match(':')) {
	                key = parseObjectPropertyKey();
	                expect('(');
	                token = lookahead;
	                if (token.type !== Token.Identifier) {
	                    expect(')');
	                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
	                    value = parsePropertyFunction([]);
	                } else {
	                    param = [ parseVariableIdentifier() ];
	                    expect(')');
	                    value = parsePropertyFunction(param, token);
	                }
	                return delegate.markEnd(delegate.createProperty('set', key, value), startToken);
	            }
	            expect(':');
	            value = parseAssignmentExpression();
	            return delegate.markEnd(delegate.createProperty('init', id, value), startToken);
	        }
	        if (token.type === Token.EOF || token.type === Token.Punctuator) {
	            throwUnexpected(token);
	        } else {
	            key = parseObjectPropertyKey();
	            expect(':');
	            value = parseAssignmentExpression();
	            return delegate.markEnd(delegate.createProperty('init', key, value), startToken);
	        }
	    }

	    function parseObjectInitialiser() {
	        var properties = [], property, name, key, kind, map = {}, toString = String, startToken;

	        startToken = lookahead;

	        expect('{');

	        while (!match('}')) {
	            property = parseObjectProperty();

	            if (property.key.type === Syntax.Identifier) {
	                name = property.key.name;
	            } else {
	                name = toString(property.key.value);
	            }
	            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

	            key = '$' + name;
	            if (Object.prototype.hasOwnProperty.call(map, key)) {
	                if (map[key] === PropertyKind.Data) {
	                    if (strict && kind === PropertyKind.Data) {
	                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
	                    } else if (kind !== PropertyKind.Data) {
	                        throwErrorTolerant({}, Messages.AccessorDataProperty);
	                    }
	                } else {
	                    if (kind === PropertyKind.Data) {
	                        throwErrorTolerant({}, Messages.AccessorDataProperty);
	                    } else if (map[key] & kind) {
	                        throwErrorTolerant({}, Messages.AccessorGetSet);
	                    }
	                }
	                map[key] |= kind;
	            } else {
	                map[key] = kind;
	            }

	            properties.push(property);

	            if (!match('}')) {
	                expect(',');
	            }
	        }

	        expect('}');

	        return delegate.markEnd(delegate.createObjectExpression(properties), startToken);
	    }

	    // 11.1.6 The Grouping Operator

	    function parseGroupExpression() {
	        var expr;

	        expect('(');

	        expr = parseExpression();

	        expect(')');

	        return expr;
	    }


	    // 11.1 Primary Expressions

	    function parsePrimaryExpression() {
	        var type, token, expr, startToken;

	        if (match('(')) {
	            return parseGroupExpression();
	        }

	        if (match('[')) {
	            return parseArrayInitialiser();
	        }

	        if (match('{')) {
	            return parseObjectInitialiser();
	        }

	        type = lookahead.type;
	        startToken = lookahead;

	        if (type === Token.Identifier) {
	            expr =  delegate.createIdentifier(lex().value);
	        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
	            if (strict && lookahead.octal) {
	                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
	            }
	            expr = delegate.createLiteral(lex());
	        } else if (type === Token.Keyword) {
	            if (matchKeyword('function')) {
	                return parseFunctionExpression();
	            }
	            if (matchKeyword('this')) {
	                lex();
	                expr = delegate.createThisExpression();
	            } else {
	                throwUnexpected(lex());
	            }
	        } else if (type === Token.BooleanLiteral) {
	            token = lex();
	            token.value = (token.value === 'true');
	            expr = delegate.createLiteral(token);
	        } else if (type === Token.NullLiteral) {
	            token = lex();
	            token.value = null;
	            expr = delegate.createLiteral(token);
	        } else if (match('/') || match('/=')) {
	            if (typeof extra.tokens !== 'undefined') {
	                expr = delegate.createLiteral(collectRegex());
	            } else {
	                expr = delegate.createLiteral(scanRegExp());
	            }
	            peek();
	        } else {
	            throwUnexpected(lex());
	        }

	        return delegate.markEnd(expr, startToken);
	    }

	    // 11.2 Left-Hand-Side Expressions

	    function parseArguments() {
	        var args = [];

	        expect('(');

	        if (!match(')')) {
	            while (index < length) {
	                args.push(parseAssignmentExpression());
	                if (match(')')) {
	                    break;
	                }
	                expect(',');
	            }
	        }

	        expect(')');

	        return args;
	    }

	    function parseNonComputedProperty() {
	        var token, startToken;

	        startToken = lookahead;
	        token = lex();

	        if (!isIdentifierName(token)) {
	            throwUnexpected(token);
	        }

	        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
	    }

	    function parseNonComputedMember() {
	        expect('.');

	        return parseNonComputedProperty();
	    }

	    function parseComputedMember() {
	        var expr;

	        expect('[');

	        expr = parseExpression();

	        expect(']');

	        return expr;
	    }

	    function parseNewExpression() {
	        var callee, args, startToken;

	        startToken = lookahead;
	        expectKeyword('new');
	        callee = parseLeftHandSideExpression();
	        args = match('(') ? parseArguments() : [];

	        return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);
	    }

	    function parseLeftHandSideExpressionAllowCall() {
	        var expr, args, property, startToken, previousAllowIn = state.allowIn;

	        startToken = lookahead;
	        state.allowIn = true;
	        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

	        for (;;) {
	            if (match('.')) {
	                property = parseNonComputedMember();
	                expr = delegate.createMemberExpression('.', expr, property);
	            } else if (match('(')) {
	                args = parseArguments();
	                expr = delegate.createCallExpression(expr, args);
	            } else if (match('[')) {
	                property = parseComputedMember();
	                expr = delegate.createMemberExpression('[', expr, property);
	            } else {
	                break;
	            }
	            delegate.markEnd(expr, startToken);
	        }
	        state.allowIn = previousAllowIn;

	        return expr;
	    }

	    function parseLeftHandSideExpression() {
	        var expr, property, startToken;
	        assert(state.allowIn, 'callee of new expression always allow in keyword.');

	        startToken = lookahead;

	        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

	        while (match('.') || match('[')) {
	            if (match('[')) {
	                property = parseComputedMember();
	                expr = delegate.createMemberExpression('[', expr, property);
	            } else {
	                property = parseNonComputedMember();
	                expr = delegate.createMemberExpression('.', expr, property);
	            }
	            delegate.markEnd(expr, startToken);
	        }
	        return expr;
	    }

	    // 11.3 Postfix Expressions

	    function parsePostfixExpression() {
	        var expr, token, startToken = lookahead;

	        expr = parseLeftHandSideExpressionAllowCall();

	        if (lookahead.type === Token.Punctuator) {
	            if ((match('++') || match('--')) && !peekLineTerminator()) {
	                // 11.3.1, 11.3.2
	                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                    throwErrorTolerant({}, Messages.StrictLHSPostfix);
	                }

	                if (!isLeftHandSide(expr)) {
	                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	                }

	                token = lex();
	                expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);
	            }
	        }

	        return expr;
	    }

	    // 11.4 Unary Operators

	    function parseUnaryExpression() {
	        var token, expr, startToken;

	        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
	            expr = parsePostfixExpression();
	        } else if (match('++') || match('--')) {
	            startToken = lookahead;
	            token = lex();
	            expr = parseUnaryExpression();
	            // 11.4.4, 11.4.5
	            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                throwErrorTolerant({}, Messages.StrictLHSPrefix);
	            }

	            if (!isLeftHandSide(expr)) {
	                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	            }

	            expr = delegate.createUnaryExpression(token.value, expr);
	            expr = delegate.markEnd(expr, startToken);
	        } else if (match('+') || match('-') || match('~') || match('!')) {
	            startToken = lookahead;
	            token = lex();
	            expr = parseUnaryExpression();
	            expr = delegate.createUnaryExpression(token.value, expr);
	            expr = delegate.markEnd(expr, startToken);
	        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
	            startToken = lookahead;
	            token = lex();
	            expr = parseUnaryExpression();
	            expr = delegate.createUnaryExpression(token.value, expr);
	            expr = delegate.markEnd(expr, startToken);
	            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
	                throwErrorTolerant({}, Messages.StrictDelete);
	            }
	        } else {
	            expr = parsePostfixExpression();
	        }

	        return expr;
	    }

	    function binaryPrecedence(token, allowIn) {
	        var prec = 0;

	        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
	            return 0;
	        }

	        switch (token.value) {
	        case '||':
	            prec = 1;
	            break;

	        case '&&':
	            prec = 2;
	            break;

	        case '|':
	            prec = 3;
	            break;

	        case '^':
	            prec = 4;
	            break;

	        case '&':
	            prec = 5;
	            break;

	        case '==':
	        case '!=':
	        case '===':
	        case '!==':
	            prec = 6;
	            break;

	        case '<':
	        case '>':
	        case '<=':
	        case '>=':
	        case 'instanceof':
	            prec = 7;
	            break;

	        case 'in':
	            prec = allowIn ? 7 : 0;
	            break;

	        case '<<':
	        case '>>':
	        case '>>>':
	            prec = 8;
	            break;

	        case '+':
	        case '-':
	            prec = 9;
	            break;

	        case '*':
	        case '/':
	        case '%':
	            prec = 11;
	            break;

	        default:
	            break;
	        }

	        return prec;
	    }

	    // 11.5 Multiplicative Operators
	    // 11.6 Additive Operators
	    // 11.7 Bitwise Shift Operators
	    // 11.8 Relational Operators
	    // 11.9 Equality Operators
	    // 11.10 Binary Bitwise Operators
	    // 11.11 Binary Logical Operators

	    function parseBinaryExpression() {
	        var marker, markers, expr, token, prec, stack, right, operator, left, i;

	        marker = lookahead;
	        left = parseUnaryExpression();

	        token = lookahead;
	        prec = binaryPrecedence(token, state.allowIn);
	        if (prec === 0) {
	            return left;
	        }
	        token.prec = prec;
	        lex();

	        markers = [marker, lookahead];
	        right = parseUnaryExpression();

	        stack = [left, token, right];

	        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

	            // Reduce: make a binary expression from the three topmost entries.
	            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
	                right = stack.pop();
	                operator = stack.pop().value;
	                left = stack.pop();
	                expr = delegate.createBinaryExpression(operator, left, right);
	                markers.pop();
	                marker = markers[markers.length - 1];
	                delegate.markEnd(expr, marker);
	                stack.push(expr);
	            }

	            // Shift.
	            token = lex();
	            token.prec = prec;
	            stack.push(token);
	            markers.push(lookahead);
	            expr = parseUnaryExpression();
	            stack.push(expr);
	        }

	        // Final reduce to clean-up the stack.
	        i = stack.length - 1;
	        expr = stack[i];
	        markers.pop();
	        while (i > 1) {
	            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
	            i -= 2;
	            marker = markers.pop();
	            delegate.markEnd(expr, marker);
	        }

	        return expr;
	    }


	    // 11.12 Conditional Operator

	    function parseConditionalExpression() {
	        var expr, previousAllowIn, consequent, alternate, startToken;

	        startToken = lookahead;

	        expr = parseBinaryExpression();

	        if (match('?')) {
	            lex();
	            previousAllowIn = state.allowIn;
	            state.allowIn = true;
	            consequent = parseAssignmentExpression();
	            state.allowIn = previousAllowIn;
	            expect(':');
	            alternate = parseAssignmentExpression();

	            expr = delegate.createConditionalExpression(expr, consequent, alternate);
	            delegate.markEnd(expr, startToken);
	        }

	        return expr;
	    }

	    // 11.13 Assignment Operators

	    function parseAssignmentExpression() {
	        var token, left, right, node, startToken;

	        token = lookahead;
	        startToken = lookahead;

	        node = left = parseConditionalExpression();

	        if (matchAssign()) {
	            // LeftHandSideExpression
	            if (!isLeftHandSide(left)) {
	                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
	            }

	            // 11.13.1
	            if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {
	                throwErrorTolerant(token, Messages.StrictLHSAssignment);
	            }

	            token = lex();
	            right = parseAssignmentExpression();
	            node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);
	        }

	        return node;
	    }

	    // 11.14 Comma Operator

	    function parseExpression() {
	        var expr, startToken = lookahead;

	        expr = parseAssignmentExpression();

	        if (match(',')) {
	            expr = delegate.createSequenceExpression([ expr ]);

	            while (index < length) {
	                if (!match(',')) {
	                    break;
	                }
	                lex();
	                expr.expressions.push(parseAssignmentExpression());
	            }

	            delegate.markEnd(expr, startToken);
	        }

	        return expr;
	    }

	    // 12.1 Block

	    function parseStatementList() {
	        var list = [],
	            statement;

	        while (index < length) {
	            if (match('}')) {
	                break;
	            }
	            statement = parseSourceElement();
	            if (typeof statement === 'undefined') {
	                break;
	            }
	            list.push(statement);
	        }

	        return list;
	    }

	    function parseBlock() {
	        var block, startToken;

	        startToken = lookahead;
	        expect('{');

	        block = parseStatementList();

	        expect('}');

	        return delegate.markEnd(delegate.createBlockStatement(block), startToken);
	    }

	    // 12.2 Variable Statement

	    function parseVariableIdentifier() {
	        var token, startToken;

	        startToken = lookahead;
	        token = lex();

	        if (token.type !== Token.Identifier) {
	            throwUnexpected(token);
	        }

	        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);
	    }

	    function parseVariableDeclaration(kind) {
	        var init = null, id, startToken;

	        startToken = lookahead;
	        id = parseVariableIdentifier();

	        // 12.2.1
	        if (strict && isRestrictedWord(id.name)) {
	            throwErrorTolerant({}, Messages.StrictVarName);
	        }

	        if (kind === 'const') {
	            expect('=');
	            init = parseAssignmentExpression();
	        } else if (match('=')) {
	            lex();
	            init = parseAssignmentExpression();
	        }

	        return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);
	    }

	    function parseVariableDeclarationList(kind) {
	        var list = [];

	        do {
	            list.push(parseVariableDeclaration(kind));
	            if (!match(',')) {
	                break;
	            }
	            lex();
	        } while (index < length);

	        return list;
	    }

	    function parseVariableStatement() {
	        var declarations;

	        expectKeyword('var');

	        declarations = parseVariableDeclarationList();

	        consumeSemicolon();

	        return delegate.createVariableDeclaration(declarations, 'var');
	    }

	    // kind may be `const` or `let`
	    // Both are experimental and not in the specification yet.
	    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
	    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
	    function parseConstLetDeclaration(kind) {
	        var declarations, startToken;

	        startToken = lookahead;

	        expectKeyword(kind);

	        declarations = parseVariableDeclarationList(kind);

	        consumeSemicolon();

	        return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);
	    }

	    // 12.3 Empty Statement

	    function parseEmptyStatement() {
	        expect(';');
	        return delegate.createEmptyStatement();
	    }

	    // 12.4 Expression Statement

	    function parseExpressionStatement() {
	        var expr = parseExpression();
	        consumeSemicolon();
	        return delegate.createExpressionStatement(expr);
	    }

	    // 12.5 If statement

	    function parseIfStatement() {
	        var test, consequent, alternate;

	        expectKeyword('if');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        consequent = parseStatement();

	        if (matchKeyword('else')) {
	            lex();
	            alternate = parseStatement();
	        } else {
	            alternate = null;
	        }

	        return delegate.createIfStatement(test, consequent, alternate);
	    }

	    // 12.6 Iteration Statements

	    function parseDoWhileStatement() {
	        var body, test, oldInIteration;

	        expectKeyword('do');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        expectKeyword('while');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        if (match(';')) {
	            lex();
	        }

	        return delegate.createDoWhileStatement(body, test);
	    }

	    function parseWhileStatement() {
	        var test, body, oldInIteration;

	        expectKeyword('while');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        return delegate.createWhileStatement(test, body);
	    }

	    function parseForVariableDeclaration() {
	        var token, declarations, startToken;

	        startToken = lookahead;
	        token = lex();
	        declarations = parseVariableDeclarationList();

	        return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);
	    }

	    function parseForStatement() {
	        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;

	        init = test = update = null;

	        expectKeyword('for');

	        expect('(');

	        if (match(';')) {
	            lex();
	        } else {
	            if (matchKeyword('var') || matchKeyword('let')) {
	                state.allowIn = false;
	                init = parseForVariableDeclaration();
	                state.allowIn = previousAllowIn;

	                if (init.declarations.length === 1 && matchKeyword('in')) {
	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                }
	            } else {
	                state.allowIn = false;
	                init = parseExpression();
	                state.allowIn = previousAllowIn;

	                if (matchKeyword('in')) {
	                    // LeftHandSideExpression
	                    if (!isLeftHandSide(init)) {
	                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);
	                    }

	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                }
	            }

	            if (typeof left === 'undefined') {
	                expect(';');
	            }
	        }

	        if (typeof left === 'undefined') {

	            if (!match(';')) {
	                test = parseExpression();
	            }
	            expect(';');

	            if (!match(')')) {
	                update = parseExpression();
	            }
	        }

	        expect(')');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        return (typeof left === 'undefined') ?
	                delegate.createForStatement(init, test, update, body) :
	                delegate.createForInStatement(left, right, body);
	    }

	    // 12.7 The continue statement

	    function parseContinueStatement() {
	        var label = null, key;

	        expectKeyword('continue');

	        // Optimize the most common form: 'continue;'.
	        if (source.charCodeAt(index) === 0x3B) {
	            lex();

	            if (!state.inIteration) {
	                throwError({}, Messages.IllegalContinue);
	            }

	            return delegate.createContinueStatement(null);
	        }

	        if (peekLineTerminator()) {
	            if (!state.inIteration) {
	                throwError({}, Messages.IllegalContinue);
	            }

	            return delegate.createContinueStatement(null);
	        }

	        if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();

	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError({}, Messages.UnknownLabel, label.name);
	            }
	        }

	        consumeSemicolon();

	        if (label === null && !state.inIteration) {
	            throwError({}, Messages.IllegalContinue);
	        }

	        return delegate.createContinueStatement(label);
	    }

	    // 12.8 The break statement

	    function parseBreakStatement() {
	        var label = null, key;

	        expectKeyword('break');

	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(index) === 0x3B) {
	            lex();

	            if (!(state.inIteration || state.inSwitch)) {
	                throwError({}, Messages.IllegalBreak);
	            }

	            return delegate.createBreakStatement(null);
	        }

	        if (peekLineTerminator()) {
	            if (!(state.inIteration || state.inSwitch)) {
	                throwError({}, Messages.IllegalBreak);
	            }

	            return delegate.createBreakStatement(null);
	        }

	        if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();

	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError({}, Messages.UnknownLabel, label.name);
	            }
	        }

	        consumeSemicolon();

	        if (label === null && !(state.inIteration || state.inSwitch)) {
	            throwError({}, Messages.IllegalBreak);
	        }

	        return delegate.createBreakStatement(label);
	    }

	    // 12.9 The return statement

	    function parseReturnStatement() {
	        var argument = null;

	        expectKeyword('return');

	        if (!state.inFunctionBody) {
	            throwErrorTolerant({}, Messages.IllegalReturn);
	        }

	        // 'return' followed by a space and an identifier is very common.
	        if (source.charCodeAt(index) === 0x20) {
	            if (isIdentifierStart(source.charCodeAt(index + 1))) {
	                argument = parseExpression();
	                consumeSemicolon();
	                return delegate.createReturnStatement(argument);
	            }
	        }

	        if (peekLineTerminator()) {
	            return delegate.createReturnStatement(null);
	        }

	        if (!match(';')) {
	            if (!match('}') && lookahead.type !== Token.EOF) {
	                argument = parseExpression();
	            }
	        }

	        consumeSemicolon();

	        return delegate.createReturnStatement(argument);
	    }

	    // 12.10 The with statement

	    function parseWithStatement() {
	        var object, body;

	        if (strict) {
	            // TODO(ikarienator): Should we update the test cases instead?
	            skipComment();
	            throwErrorTolerant({}, Messages.StrictModeWith);
	        }

	        expectKeyword('with');

	        expect('(');

	        object = parseExpression();

	        expect(')');

	        body = parseStatement();

	        return delegate.createWithStatement(object, body);
	    }

	    // 12.10 The swith statement

	    function parseSwitchCase() {
	        var test, consequent = [], statement, startToken;

	        startToken = lookahead;
	        if (matchKeyword('default')) {
	            lex();
	            test = null;
	        } else {
	            expectKeyword('case');
	            test = parseExpression();
	        }
	        expect(':');

	        while (index < length) {
	            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
	                break;
	            }
	            statement = parseStatement();
	            consequent.push(statement);
	        }

	        return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);
	    }

	    function parseSwitchStatement() {
	        var discriminant, cases, clause, oldInSwitch, defaultFound;

	        expectKeyword('switch');

	        expect('(');

	        discriminant = parseExpression();

	        expect(')');

	        expect('{');

	        cases = [];

	        if (match('}')) {
	            lex();
	            return delegate.createSwitchStatement(discriminant, cases);
	        }

	        oldInSwitch = state.inSwitch;
	        state.inSwitch = true;
	        defaultFound = false;

	        while (index < length) {
	            if (match('}')) {
	                break;
	            }
	            clause = parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    throwError({}, Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }

	        state.inSwitch = oldInSwitch;

	        expect('}');

	        return delegate.createSwitchStatement(discriminant, cases);
	    }

	    // 12.13 The throw statement

	    function parseThrowStatement() {
	        var argument;

	        expectKeyword('throw');

	        if (peekLineTerminator()) {
	            throwError({}, Messages.NewlineAfterThrow);
	        }

	        argument = parseExpression();

	        consumeSemicolon();

	        return delegate.createThrowStatement(argument);
	    }

	    // 12.14 The try statement

	    function parseCatchClause() {
	        var param, body, startToken;

	        startToken = lookahead;
	        expectKeyword('catch');

	        expect('(');
	        if (match(')')) {
	            throwUnexpected(lookahead);
	        }

	        param = parseVariableIdentifier();
	        // 12.14.1
	        if (strict && isRestrictedWord(param.name)) {
	            throwErrorTolerant({}, Messages.StrictCatchVariable);
	        }

	        expect(')');
	        body = parseBlock();
	        return delegate.markEnd(delegate.createCatchClause(param, body), startToken);
	    }

	    function parseTryStatement() {
	        var block, handlers = [], finalizer = null;

	        expectKeyword('try');

	        block = parseBlock();

	        if (matchKeyword('catch')) {
	            handlers.push(parseCatchClause());
	        }

	        if (matchKeyword('finally')) {
	            lex();
	            finalizer = parseBlock();
	        }

	        if (handlers.length === 0 && !finalizer) {
	            throwError({}, Messages.NoCatchOrFinally);
	        }

	        return delegate.createTryStatement(block, [], handlers, finalizer);
	    }

	    // 12.15 The debugger statement

	    function parseDebuggerStatement() {
	        expectKeyword('debugger');

	        consumeSemicolon();

	        return delegate.createDebuggerStatement();
	    }

	    // 12 Statements

	    function parseStatement() {
	        var type = lookahead.type,
	            expr,
	            labeledBody,
	            key,
	            startToken;

	        if (type === Token.EOF) {
	            throwUnexpected(lookahead);
	        }

	        if (type === Token.Punctuator && lookahead.value === '{') {
	            return parseBlock();
	        }

	        startToken = lookahead;

	        if (type === Token.Punctuator) {
	            switch (lookahead.value) {
	            case ';':
	                return delegate.markEnd(parseEmptyStatement(), startToken);
	            case '(':
	                return delegate.markEnd(parseExpressionStatement(), startToken);
	            default:
	                break;
	            }
	        }

	        if (type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'break':
	                return delegate.markEnd(parseBreakStatement(), startToken);
	            case 'continue':
	                return delegate.markEnd(parseContinueStatement(), startToken);
	            case 'debugger':
	                return delegate.markEnd(parseDebuggerStatement(), startToken);
	            case 'do':
	                return delegate.markEnd(parseDoWhileStatement(), startToken);
	            case 'for':
	                return delegate.markEnd(parseForStatement(), startToken);
	            case 'function':
	                return delegate.markEnd(parseFunctionDeclaration(), startToken);
	            case 'if':
	                return delegate.markEnd(parseIfStatement(), startToken);
	            case 'return':
	                return delegate.markEnd(parseReturnStatement(), startToken);
	            case 'switch':
	                return delegate.markEnd(parseSwitchStatement(), startToken);
	            case 'throw':
	                return delegate.markEnd(parseThrowStatement(), startToken);
	            case 'try':
	                return delegate.markEnd(parseTryStatement(), startToken);
	            case 'var':
	                return delegate.markEnd(parseVariableStatement(), startToken);
	            case 'while':
	                return delegate.markEnd(parseWhileStatement(), startToken);
	            case 'with':
	                return delegate.markEnd(parseWithStatement(), startToken);
	            default:
	                break;
	            }
	        }

	        expr = parseExpression();

	        // 12.12 Labelled Statements
	        if ((expr.type === Syntax.Identifier) && match(':')) {
	            lex();

	            key = '$' + expr.name;
	            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError({}, Messages.Redeclaration, 'Label', expr.name);
	            }

	            state.labelSet[key] = true;
	            labeledBody = parseStatement();
	            delete state.labelSet[key];
	            return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);
	        }

	        consumeSemicolon();

	        return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);
	    }

	    // 13 Function Definition

	    function parseFunctionSourceElements() {
	        var sourceElement, sourceElements = [], token, directive, firstRestricted,
	            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, startToken;

	        startToken = lookahead;
	        expect('{');

	        while (index < length) {
	            if (lookahead.type !== Token.StringLiteral) {
	                break;
	            }
	            token = lookahead;

	            sourceElement = parseSourceElement();
	            sourceElements.push(sourceElement);
	            if (sourceElement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }

	        oldLabelSet = state.labelSet;
	        oldInIteration = state.inIteration;
	        oldInSwitch = state.inSwitch;
	        oldInFunctionBody = state.inFunctionBody;

	        state.labelSet = {};
	        state.inIteration = false;
	        state.inSwitch = false;
	        state.inFunctionBody = true;

	        while (index < length) {
	            if (match('}')) {
	                break;
	            }
	            sourceElement = parseSourceElement();
	            if (typeof sourceElement === 'undefined') {
	                break;
	            }
	            sourceElements.push(sourceElement);
	        }

	        expect('}');

	        state.labelSet = oldLabelSet;
	        state.inIteration = oldInIteration;
	        state.inSwitch = oldInSwitch;
	        state.inFunctionBody = oldInFunctionBody;

	        return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);
	    }

	    function parseParams(firstRestricted) {
	        var param, params = [], token, stricted, paramSet, key, message;
	        expect('(');

	        if (!match(')')) {
	            paramSet = {};
	            while (index < length) {
	                token = lookahead;
	                param = parseVariableIdentifier();
	                key = '$' + token.value;
	                if (strict) {
	                    if (isRestrictedWord(token.value)) {
	                        stricted = token;
	                        message = Messages.StrictParamName;
	                    }
	                    if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
	                        stricted = token;
	                        message = Messages.StrictParamDupe;
	                    }
	                } else if (!firstRestricted) {
	                    if (isRestrictedWord(token.value)) {
	                        firstRestricted = token;
	                        message = Messages.StrictParamName;
	                    } else if (isStrictModeReservedWord(token.value)) {
	                        firstRestricted = token;
	                        message = Messages.StrictReservedWord;
	                    } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
	                        firstRestricted = token;
	                        message = Messages.StrictParamDupe;
	                    }
	                }
	                params.push(param);
	                paramSet[key] = true;
	                if (match(')')) {
	                    break;
	                }
	                expect(',');
	            }
	        }

	        expect(')');

	        return {
	            params: params,
	            stricted: stricted,
	            firstRestricted: firstRestricted,
	            message: message
	        };
	    }

	    function parseFunctionDeclaration() {
	        var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, startToken;

	        startToken = lookahead;

	        expectKeyword('function');
	        token = lookahead;
	        id = parseVariableIdentifier();
	        if (strict) {
	            if (isRestrictedWord(token.value)) {
	                throwErrorTolerant(token, Messages.StrictFunctionName);
	            }
	        } else {
	            if (isRestrictedWord(token.value)) {
	                firstRestricted = token;
	                message = Messages.StrictFunctionName;
	            } else if (isStrictModeReservedWord(token.value)) {
	                firstRestricted = token;
	                message = Messages.StrictReservedWord;
	            }
	        }

	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }

	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwError(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            throwErrorTolerant(stricted, message);
	        }
	        strict = previousStrict;

	        return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);
	    }

	    function parseFunctionExpression() {
	        var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict, startToken;

	        startToken = lookahead;
	        expectKeyword('function');

	        if (!match('(')) {
	            token = lookahead;
	            id = parseVariableIdentifier();
	            if (strict) {
	                if (isRestrictedWord(token.value)) {
	                    throwErrorTolerant(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }

	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }

	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwError(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            throwErrorTolerant(stricted, message);
	        }
	        strict = previousStrict;

	        return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);
	    }

	    // 14 Program

	    function parseSourceElement() {
	        if (lookahead.type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'const':
	            case 'let':
	                return parseConstLetDeclaration(lookahead.value);
	            case 'function':
	                return parseFunctionDeclaration();
	            default:
	                return parseStatement();
	            }
	        }

	        if (lookahead.type !== Token.EOF) {
	            return parseStatement();
	        }
	    }

	    function parseSourceElements() {
	        var sourceElement, sourceElements = [], token, directive, firstRestricted;

	        while (index < length) {
	            token = lookahead;
	            if (token.type !== Token.StringLiteral) {
	                break;
	            }

	            sourceElement = parseSourceElement();
	            sourceElements.push(sourceElement);
	            if (sourceElement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }

	        while (index < length) {
	            sourceElement = parseSourceElement();
	            /* istanbul ignore if */
	            if (typeof sourceElement === 'undefined') {
	                break;
	            }
	            sourceElements.push(sourceElement);
	        }
	        return sourceElements;
	    }

	    function parseProgram() {
	        var body, startToken;

	        skipComment();
	        peek();
	        startToken = lookahead;
	        strict = false;

	        body = parseSourceElements();
	        return delegate.markEnd(delegate.createProgram(body), startToken);
	    }

	    function filterTokenLocation() {
	        var i, entry, token, tokens = [];

	        for (i = 0; i < extra.tokens.length; ++i) {
	            entry = extra.tokens[i];
	            token = {
	                type: entry.type,
	                value: entry.value
	            };
	            if (extra.range) {
	                token.range = entry.range;
	            }
	            if (extra.loc) {
	                token.loc = entry.loc;
	            }
	            tokens.push(token);
	        }

	        extra.tokens = tokens;
	    }

	    function tokenize(code, options) {
	        var toString,
	            token,
	            tokens;

	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }

	        delegate = SyntaxTreeDelegate;
	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1
	        };

	        extra = {};

	        // Options matching.
	        options = options || {};

	        // Of course we collect tokens here.
	        options.tokens = true;
	        extra.tokens = [];
	        extra.tokenize = true;
	        // The following two fields are necessary to compute the Regex tokens.
	        extra.openParenToken = -1;
	        extra.openCurlyToken = -1;

	        extra.range = (typeof options.range === 'boolean') && options.range;
	        extra.loc = (typeof options.loc === 'boolean') && options.loc;

	        if (typeof options.comment === 'boolean' && options.comment) {
	            extra.comments = [];
	        }
	        if (typeof options.tolerant === 'boolean' && options.tolerant) {
	            extra.errors = [];
	        }

	        try {
	            peek();
	            if (lookahead.type === Token.EOF) {
	                return extra.tokens;
	            }

	            token = lex();
	            while (lookahead.type !== Token.EOF) {
	                try {
	                    token = lex();
	                } catch (lexError) {
	                    token = lookahead;
	                    if (extra.errors) {
	                        extra.errors.push(lexError);
	                        // We have to break on the first error
	                        // to avoid infinite loops.
	                        break;
	                    } else {
	                        throw lexError;
	                    }
	                }
	            }

	            filterTokenLocation();
	            tokens = extra.tokens;
	            if (typeof extra.comments !== 'undefined') {
	                tokens.comments = extra.comments;
	            }
	            if (typeof extra.errors !== 'undefined') {
	                tokens.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }
	        return tokens;
	    }

	    function parse(code, options) {
	        var program, toString;

	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }

	        delegate = SyntaxTreeDelegate;
	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1
	        };

	        extra = {};
	        if (typeof options !== 'undefined') {
	            extra.range = (typeof options.range === 'boolean') && options.range;
	            extra.loc = (typeof options.loc === 'boolean') && options.loc;
	            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

	            if (extra.loc && options.source !== null && options.source !== undefined) {
	                extra.source = toString(options.source);
	            }

	            if (typeof options.tokens === 'boolean' && options.tokens) {
	                extra.tokens = [];
	            }
	            if (typeof options.comment === 'boolean' && options.comment) {
	                extra.comments = [];
	            }
	            if (typeof options.tolerant === 'boolean' && options.tolerant) {
	                extra.errors = [];
	            }
	            if (extra.attachComment) {
	                extra.range = true;
	                extra.comments = [];
	                extra.bottomRightStack = [];
	                extra.trailingComments = [];
	                extra.leadingComments = [];
	            }
	        }

	        try {
	            program = parseProgram();
	            if (typeof extra.comments !== 'undefined') {
	                program.comments = extra.comments;
	            }
	            if (typeof extra.tokens !== 'undefined') {
	                filterTokenLocation();
	                program.tokens = extra.tokens;
	            }
	            if (typeof extra.errors !== 'undefined') {
	                program.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }

	        return program;
	    }

	    // Sync with *.json manifests.
	    exports.version = '1.2.5';

	    exports.tokenize = tokenize;

	    exports.parse = parse;

	    // Deep copy.
	   /* istanbul ignore next */
	    exports.Syntax = (function () {
	        var name, types = {};

	        if (typeof Object.create === 'function') {
	            types = Object.create(null);
	        }

	        for (name in Syntax) {
	            if (Syntax.hasOwnProperty(name)) {
	                types[name] = Syntax[name];
	            }
	        }

	        if (typeof Object.freeze === 'function') {
	            Object.freeze(types);
	        }

	        return types;
	    }());

	}));
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
	  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
	  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
	  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
	  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
	  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
	  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (root, factory) {
	    'use strict';

	    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
	    // Rhino, and plain browser loading.

	    /* istanbul ignore next */
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== 'undefined') {
	        factory(exports);
	    } else {
	        factory((root.esprima = {}));
	    }
	}(this, function (exports) {
	    'use strict';

	    var Token,
	        TokenName,
	        FnExprTokens,
	        Syntax,
	        PropertyKind,
	        Messages,
	        Regex,
	        SyntaxTreeDelegate,
	        ClassPropertyType,
	        source,
	        strict,
	        index,
	        lineNumber,
	        lineStart,
	        length,
	        delegate,
	        lookahead,
	        state,
	        extra;

	    Token = {
	        BooleanLiteral: 1,
	        EOF: 2,
	        Identifier: 3,
	        Keyword: 4,
	        NullLiteral: 5,
	        NumericLiteral: 6,
	        Punctuator: 7,
	        StringLiteral: 8,
	        RegularExpression: 9,
	        Template: 10
	    };

	    TokenName = {};
	    TokenName[Token.BooleanLiteral] = 'Boolean';
	    TokenName[Token.EOF] = '<end>';
	    TokenName[Token.Identifier] = 'Identifier';
	    TokenName[Token.Keyword] = 'Keyword';
	    TokenName[Token.NullLiteral] = 'Null';
	    TokenName[Token.NumericLiteral] = 'Numeric';
	    TokenName[Token.Punctuator] = 'Punctuator';
	    TokenName[Token.StringLiteral] = 'String';
	    TokenName[Token.RegularExpression] = 'RegularExpression';
	    TokenName[Token.Template] = 'Template';

	    // A function following one of those tokens is an expression.
	    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	                    'return', 'case', 'delete', 'throw', 'void',
	                    // assignment operators
	                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
	                    '&=', '|=', '^=', ',',
	                    // binary/unary operators
	                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	                    '<=', '<', '>', '!=', '!=='];

	    Syntax = {
	        ArrayExpression: 'ArrayExpression',
	        ArrayPattern: 'ArrayPattern',
	        ArrowFunctionExpression: 'ArrowFunctionExpression',
	        AssignmentExpression: 'AssignmentExpression',
	        BinaryExpression: 'BinaryExpression',
	        BlockStatement: 'BlockStatement',
	        BreakStatement: 'BreakStatement',
	        CallExpression: 'CallExpression',
	        CatchClause: 'CatchClause',
	        ClassBody: 'ClassBody',
	        ClassDeclaration: 'ClassDeclaration',
	        ClassExpression: 'ClassExpression',
	        ComprehensionBlock: 'ComprehensionBlock',
	        ComprehensionExpression: 'ComprehensionExpression',
	        ConditionalExpression: 'ConditionalExpression',
	        ContinueStatement: 'ContinueStatement',
	        DebuggerStatement: 'DebuggerStatement',
	        DoWhileStatement: 'DoWhileStatement',
	        EmptyStatement: 'EmptyStatement',
	        ExportDeclaration: 'ExportDeclaration',
	        ExportBatchSpecifier: 'ExportBatchSpecifier',
	        ExportSpecifier: 'ExportSpecifier',
	        ExpressionStatement: 'ExpressionStatement',
	        ForInStatement: 'ForInStatement',
	        ForOfStatement: 'ForOfStatement',
	        ForStatement: 'ForStatement',
	        FunctionDeclaration: 'FunctionDeclaration',
	        FunctionExpression: 'FunctionExpression',
	        Identifier: 'Identifier',
	        IfStatement: 'IfStatement',
	        ImportDeclaration: 'ImportDeclaration',
	        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	        ImportSpecifier: 'ImportSpecifier',
	        LabeledStatement: 'LabeledStatement',
	        Literal: 'Literal',
	        LogicalExpression: 'LogicalExpression',
	        MemberExpression: 'MemberExpression',
	        MethodDefinition: 'MethodDefinition',
	        NewExpression: 'NewExpression',
	        ObjectExpression: 'ObjectExpression',
	        ObjectPattern: 'ObjectPattern',
	        Program: 'Program',
	        Property: 'Property',
	        ReturnStatement: 'ReturnStatement',
	        SequenceExpression: 'SequenceExpression',
	        SpreadElement: 'SpreadElement',
	        SwitchCase: 'SwitchCase',
	        SwitchStatement: 'SwitchStatement',
	        TaggedTemplateExpression: 'TaggedTemplateExpression',
	        TemplateElement: 'TemplateElement',
	        TemplateLiteral: 'TemplateLiteral',
	        ThisExpression: 'ThisExpression',
	        ThrowStatement: 'ThrowStatement',
	        TryStatement: 'TryStatement',
	        UnaryExpression: 'UnaryExpression',
	        UpdateExpression: 'UpdateExpression',
	        VariableDeclaration: 'VariableDeclaration',
	        VariableDeclarator: 'VariableDeclarator',
	        WhileStatement: 'WhileStatement',
	        WithStatement: 'WithStatement',
	        YieldExpression: 'YieldExpression'
	    };

	    PropertyKind = {
	        Data: 1,
	        Get: 2,
	        Set: 4
	    };

	    ClassPropertyType = {
	        'static': 'static',
	        prototype: 'prototype'
	    };

	    // Error messages should be identical to V8.
	    Messages = {
	        UnexpectedToken: 'Unexpected token %0',
	        UnexpectedNumber: 'Unexpected number',
	        UnexpectedString: 'Unexpected string',
	        UnexpectedIdentifier: 'Unexpected identifier',
	        UnexpectedReserved: 'Unexpected reserved word',
	        UnexpectedTemplate: 'Unexpected quasi %0',
	        UnexpectedEOS: 'Unexpected end of input',
	        NewlineAfterThrow: 'Illegal newline after throw',
	        InvalidRegExp: 'Invalid regular expression',
	        UnterminatedRegExp: 'Invalid regular expression: missing /',
	        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	        InvalidLHSInFormalsList: 'Invalid left-hand side in formals list',
	        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	        NoCatchOrFinally: 'Missing catch or finally after try',
	        UnknownLabel: 'Undefined label \'%0\'',
	        Redeclaration: '%0 \'%1\' has already been declared',
	        IllegalContinue: 'Illegal continue statement',
	        IllegalBreak: 'Illegal break statement',
	        IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition',
	        IllegalClassConstructorProperty: 'Illegal constructor property in class definition',
	        IllegalReturn: 'Illegal return statement',
	        IllegalYield: 'Illegal yield expression',
	        IllegalSpread: 'Illegal spread element',
	        StrictModeWith: 'Strict mode code may not include a with statement',
	        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	        ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list',
	        DefaultRestParameter: 'Rest parameter can not have a default value',
	        ElementAfterSpreadElement: 'Spread must be the final element of an element list',
	        ObjectPatternAsRestParameter: 'Invalid rest parameter',
	        ObjectPatternAsSpread: 'Invalid spread argument',
	        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
	        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
	        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
	        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictReservedWord: 'Use of future reserved word in strict mode',
	        MissingFromClause: 'Missing from clause',
	        NoAsAfterImportNamespace: 'Missing as after import *',
	        InvalidModuleSpecifier: 'Invalid module specifier',
	        IllegalImportDeclaration: 'Illegal import declaration',
	        IllegalExportDeclaration: 'Illegal export declaration',
	        NoUninitializedConst: 'Const must be initialized',
	        ComprehensionRequiresBlock: 'Comprehension must have at least one block',
	        ComprehensionError: 'Comprehension Error',
	        EachNotAllowed: 'Each is not supported'
	    };

	    // See also tools/generate-unicode-regex.py.
	    Regex = {
	        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
	        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')
	    };

	    // Ensure the condition is true, otherwise throw an error.
	    // This is only to have a better contract semantic, i.e. another safety net
	    // to catch a logic error. The condition shall be fulfilled in normal case.
	    // Do NOT use this to enforce a certain condition on any user input.

	    function assert(condition, message) {
	        /* istanbul ignore if */
	        if (!condition) {
	            throw new Error('ASSERT: ' + message);
	        }
	    }

	    function StringMap() {
	        this.$data = {};
	    }

	    StringMap.prototype.get = function (key) {
	        key = '$' + key;
	        return this.$data[key];
	    };

	    StringMap.prototype.set = function (key, value) {
	        key = '$' + key;
	        this.$data[key] = value;
	        return this;
	    };

	    StringMap.prototype.has = function (key) {
	        key = '$' + key;
	        return Object.prototype.hasOwnProperty.call(this.$data, key);
	    };

	    StringMap.prototype.delete = function (key) {
	        key = '$' + key;
	        return delete this.$data[key];
	    };

	    function isDecimalDigit(ch) {
	        return (ch >= 48 && ch <= 57);   // 0..9
	    }

	    function isHexDigit(ch) {
	        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
	    }

	    function isOctalDigit(ch) {
	        return '01234567'.indexOf(ch) >= 0;
	    }


	    // 7.2 White Space

	    function isWhiteSpace(ch) {
	        return (ch === 32) ||  // space
	            (ch === 9) ||      // tab
	            (ch === 0xB) ||
	            (ch === 0xC) ||
	            (ch === 0xA0) ||
	            (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);
	    }

	    // 7.3 Line Terminators

	    function isLineTerminator(ch) {
	        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);
	    }

	    // 7.6 Identifier Names and Identifiers

	    function isIdentifierStart(ch) {
	        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
	            (ch >= 65 && ch <= 90) ||         // A..Z
	            (ch >= 97 && ch <= 122) ||        // a..z
	            (ch === 92) ||                    // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
	    }

	    function isIdentifierPart(ch) {
	        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
	            (ch >= 65 && ch <= 90) ||         // A..Z
	            (ch >= 97 && ch <= 122) ||        // a..z
	            (ch >= 48 && ch <= 57) ||         // 0..9
	            (ch === 92) ||                    // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
	    }

	    // 7.6.1.2 Future Reserved Words

	    function isFutureReservedWord(id) {
	        switch (id) {
	        case 'class':
	        case 'enum':
	        case 'export':
	        case 'extends':
	        case 'import':
	        case 'super':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isStrictModeReservedWord(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'yield':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }

	    // 7.6.1.1 Keywords

	    function isKeyword(id) {
	        if (strict && isStrictModeReservedWord(id)) {
	            return true;
	        }

	        // 'const' is specialized as Keyword in V8.
	        // 'yield' is only treated as a keyword in strict mode.
	        // 'let' is for compatiblity with SpiderMonkey and ES.next.
	        // Some others are from future reserved words.

	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') ||
	                (id === 'try') || (id === 'let');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }

	    // 7.4 Comments

	    function addComment(type, value, start, end, loc) {
	        var comment;
	        assert(typeof start === 'number', 'Comment must have valid position');

	        // Because the way the actual token is scanned, often the comments
	        // (if any) are skipped twice during the lexical analysis.
	        // Thus, we need to skip adding a comment if the comment array already
	        // handled it.
	        if (state.lastCommentStart >= start) {
	            return;
	        }
	        state.lastCommentStart = start;

	        comment = {
	            type: type,
	            value: value
	        };
	        if (extra.range) {
	            comment.range = [start, end];
	        }
	        if (extra.loc) {
	            comment.loc = loc;
	        }
	        extra.comments.push(comment);
	        if (extra.attachComment) {
	            extra.leadingComments.push(comment);
	            extra.trailingComments.push(comment);
	        }
	    }

	    function skipSingleLineComment() {
	        var start, loc, ch, comment;

	        start = index - 2;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart - 2
	            }
	        };

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            ++index;
	            if (isLineTerminator(ch)) {
	                if (extra.comments) {
	                    comment = source.slice(start + 2, index - 1);
	                    loc.end = {
	                        line: lineNumber,
	                        column: index - lineStart - 1
	                    };
	                    addComment('Line', comment, start, index - 1, loc);
	                }
	                if (ch === 13 && source.charCodeAt(index) === 10) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                return;
	            }
	        }

	        if (extra.comments) {
	            comment = source.slice(start + 2, index);
	            loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	            };
	            addComment('Line', comment, start, index, loc);
	        }
	    }

	    function skipMultiLineComment() {
	        var start, loc, ch, comment;

	        if (extra.comments) {
	            start = index - 2;
	            loc = {
	                start: {
	                    line: lineNumber,
	                    column: index - lineStart - 2
	                }
	            };
	        }

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (isLineTerminator(ch)) {
	                if (ch === 13 && source.charCodeAt(index + 1) === 10) {
	                    ++index;
	                }
	                ++lineNumber;
	                ++index;
	                lineStart = index;
	                if (index >= length) {
	                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	            } else if (ch === 42) {
	                // Block comment ends with '*/' (char #42, char #47).
	                if (source.charCodeAt(index + 1) === 47) {
	                    ++index;
	                    ++index;
	                    if (extra.comments) {
	                        comment = source.slice(start + 2, index - 2);
	                        loc.end = {
	                            line: lineNumber,
	                            column: index - lineStart
	                        };
	                        addComment('Block', comment, start, index, loc);
	                    }
	                    return;
	                }
	                ++index;
	            } else {
	                ++index;
	            }
	        }

	        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	    }

	    function skipComment() {
	        var ch;

	        while (index < length) {
	            ch = source.charCodeAt(index);

	            if (isWhiteSpace(ch)) {
	                ++index;
	            } else if (isLineTerminator(ch)) {
	                ++index;
	                if (ch === 13 && source.charCodeAt(index) === 10) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	            } else if (ch === 47) { // 47 is '/'
	                ch = source.charCodeAt(index + 1);
	                if (ch === 47) {
	                    ++index;
	                    ++index;
	                    skipSingleLineComment();
	                } else if (ch === 42) {  // 42 is '*'
	                    ++index;
	                    ++index;
	                    skipMultiLineComment();
	                } else {
	                    break;
	                }
	            } else {
	                break;
	            }
	        }
	    }

	    function scanHexEscape(prefix) {
	        var i, len, ch, code = 0;

	        len = (prefix === 'u') ? 4 : 2;
	        for (i = 0; i < len; ++i) {
	            if (index < length && isHexDigit(source[index])) {
	                ch = source[index++];
	                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	            } else {
	                return '';
	            }
	        }
	        return String.fromCharCode(code);
	    }

	    function scanUnicodeCodePointEscape() {
	        var ch, code, cu1, cu2;

	        ch = source[index];
	        code = 0;

	        // At least, one hex digit is required.
	        if (ch === '}') {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        while (index < length) {
	            ch = source[index++];
	            if (!isHexDigit(ch)) {
	                break;
	            }
	            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	        }

	        if (code > 0x10FFFF || ch !== '}') {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        // UTF-16 Encoding
	        if (code <= 0xFFFF) {
	            return String.fromCharCode(code);
	        }
	        cu1 = ((code - 0x10000) >> 10) + 0xD800;
	        cu2 = ((code - 0x10000) & 1023) + 0xDC00;
	        return String.fromCharCode(cu1, cu2);
	    }

	    function getEscapedIdentifier() {
	        var ch, id;

	        ch = source.charCodeAt(index++);
	        id = String.fromCharCode(ch);

	        // '\u' (char #92, char #117) denotes an escaped character.
	        if (ch === 92) {
	            if (source.charCodeAt(index) !== 117) {
	                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	            ++index;
	            ch = scanHexEscape('u');
	            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
	                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	            id = ch;
	        }

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (!isIdentifierPart(ch)) {
	                break;
	            }
	            ++index;
	            id += String.fromCharCode(ch);

	            // '\u' (char #92, char #117) denotes an escaped character.
	            if (ch === 92) {
	                id = id.substr(0, id.length - 1);
	                if (source.charCodeAt(index) !== 117) {
	                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	                ++index;
	                ch = scanHexEscape('u');
	                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
	                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	                id += ch;
	            }
	        }

	        return id;
	    }

	    function getIdentifier() {
	        var start, ch;

	        start = index++;
	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (ch === 92) {
	                // Blackslash (char #92) marks Unicode escape sequence.
	                index = start;
	                return getEscapedIdentifier();
	            }
	            if (isIdentifierPart(ch)) {
	                ++index;
	            } else {
	                break;
	            }
	        }

	        return source.slice(start, index);
	    }

	    function scanIdentifier() {
	        var start, id, type;

	        start = index;

	        // Backslash (char #92) starts an escaped character.
	        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();

	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = Token.Identifier;
	        } else if (isKeyword(id)) {
	            type = Token.Keyword;
	        } else if (id === 'null') {
	            type = Token.NullLiteral;
	        } else if (id === 'true' || id === 'false') {
	            type = Token.BooleanLiteral;
	        } else {
	            type = Token.Identifier;
	        }

	        return {
	            type: type,
	            value: id,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }


	    // 7.7 Punctuators

	    function scanPunctuator() {
	        var start = index,
	            code = source.charCodeAt(index),
	            code2,
	            ch1 = source[index],
	            ch2,
	            ch3,
	            ch4;

	        switch (code) {
	        // Check for most common single-character punctuators.
	        case 40:   // ( open bracket
	        case 41:   // ) close bracket
	        case 59:   // ; semicolon
	        case 44:   // , comma
	        case 91:   // [
	        case 93:   // ]
	        case 58:   // :
	        case 63:   // ?
	        case 126:  // ~
	            ++index;
	            if (extra.tokenize && code === 40) {
	                extra.openParenToken = extra.tokens.length;
	            }

	            return {
	                type: Token.Punctuator,
	                value: String.fromCharCode(code),
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };

	        case 123:  // { open curly brace
	        case 125:  // } close curly brace
	            ++index;
	            if (extra.tokenize && code === 123) {
	                extra.openCurlyToken = extra.tokens.length;
	            }

	            // lookahead2 function can cause tokens to be scanned twice and in doing so
	            // would wreck the curly stack by pushing the same token onto the stack twice.
	            // curlyLastIndex ensures each token is pushed or popped exactly once
	            if (index > state.curlyLastIndex) {
	                state.curlyLastIndex = index;
	                if (code === 123) {
	                    state.curlyStack.push('{');
	                } else {
	                    state.curlyStack.pop();
	                }
	            }

	            return {
	                type: Token.Punctuator,
	                value: String.fromCharCode(code),
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };

	        default:
	            code2 = source.charCodeAt(index + 1);

	            // '=' (char #61) marks an assignment or comparison operator.
	            if (code2 === 61) {
	                switch (code) {
	                case 37:  // %
	                case 38:  // &
	                case 42:  // *:
	                case 43:  // +
	                case 45:  // -
	                case 47:  // /
	                case 60:  // <
	                case 62:  // >
	                case 94:  // ^
	                case 124: // |
	                    index += 2;
	                    return {
	                        type: Token.Punctuator,
	                        value: String.fromCharCode(code) + String.fromCharCode(code2),
	                        lineNumber: lineNumber,
	                        lineStart: lineStart,
	                        range: [start, index]
	                    };

	                case 33: // !
	                case 61: // =
	                    index += 2;

	                    // !== and ===
	                    if (source.charCodeAt(index) === 61) {
	                        ++index;
	                    }
	                    return {
	                        type: Token.Punctuator,
	                        value: source.slice(start, index),
	                        lineNumber: lineNumber,
	                        lineStart: lineStart,
	                        range: [start, index]
	                    };
	                default:
	                    break;
	                }
	            }
	            break;
	        }

	        // Peek more characters.

	        ch2 = source[index + 1];
	        ch3 = source[index + 2];
	        ch4 = source[index + 3];

	        // 4-character punctuator: >>>=

	        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
	            if (ch4 === '=') {
	                index += 4;
	                return {
	                    type: Token.Punctuator,
	                    value: '>>>=',
	                    lineNumber: lineNumber,
	                    lineStart: lineStart,
	                    range: [start, index]
	                };
	            }
	        }

	        // 3-character punctuators: === !== >>> <<= >>=

	        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
	            index += 3;
	            return {
	                type: Token.Punctuator,
	                value: '>>>',
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };
	        }

	        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
	            index += 3;
	            return {
	                type: Token.Punctuator,
	                value: '<<=',
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };
	        }

	        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
	            index += 3;
	            return {
	                type: Token.Punctuator,
	                value: '>>=',
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };
	        }

	        if (ch1 === '.' && ch2 === '.' && ch3 === '.') {
	            index += 3;
	            return {
	                type: Token.Punctuator,
	                value: '...',
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };
	        }

	        // Other 2-character punctuators: ++ -- << >> && ||

	        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {
	            index += 2;
	            return {
	                type: Token.Punctuator,
	                value: ch1 + ch2,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };
	        }

	        if (ch1 === '=' && ch2 === '>') {
	            index += 2;
	            return {
	                type: Token.Punctuator,
	                value: '=>',
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };
	        }

	        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
	            ++index;
	            return {
	                type: Token.Punctuator,
	                value: ch1,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };
	        }

	        if (ch1 === '.') {
	            ++index;
	            return {
	                type: Token.Punctuator,
	                value: ch1,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };
	        }

	        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	    }

	    // 7.8.3 Numeric Literals

	    function scanHexLiteral(start) {
	        var number = '';

	        while (index < length) {
	            if (!isHexDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }

	        if (number.length === 0) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt('0x' + number, 16),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }

	    function scanBinaryLiteral(start) {
	        var ch, number;

	        number = '';

	        while (index < length) {
	            ch = source[index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            number += source[index++];
	        }

	        if (number.length === 0) {
	            // only 0b or 0B
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        if (index < length) {
	            ch = source.charCodeAt(index);
	            /* istanbul ignore else */
	            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
	                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 2),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }

	    function scanOctalLiteral(prefix, start) {
	        var number, octal;

	        if (isOctalDigit(prefix)) {
	            octal = true;
	            number = '0' + source[index++];
	        } else {
	            octal = false;
	            ++index;
	            number = '';
	        }

	        while (index < length) {
	            if (!isOctalDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }

	        if (!octal && number.length === 0) {
	            // only 0o or 0O
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 8),
	            octal: octal,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }

	    function scanNumericLiteral() {
	        var number, start, ch;

	        ch = source[index];
	        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
	            'Numeric literal must start with a decimal digit or a decimal point');

	        start = index;
	        number = '';
	        if (ch !== '.') {
	            number = source[index++];
	            ch = source[index];

	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (number === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++index;
	                    return scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++index;
	                    return scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {
	                    return scanOctalLiteral(ch, start);
	                }
	                // decimal number starts with '0' such as '09' is illegal.
	                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
	                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	            }

	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }

	        if (ch === '.') {
	            number += source[index++];
	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }

	        if (ch === 'e' || ch === 'E') {
	            number += source[index++];

	            ch = source[index];
	            if (ch === '+' || ch === '-') {
	                number += source[index++];
	            }
	            if (isDecimalDigit(source.charCodeAt(index))) {
	                while (isDecimalDigit(source.charCodeAt(index))) {
	                    number += source[index++];
	                }
	            } else {
	                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	            }
	        }

	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseFloat(number),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }

	    // 7.8.4 String Literals

	    function scanStringLiteral() {
	        var str = '', quote, start, ch, code, unescaped, restore, octal = false;

	        quote = source[index];
	        assert((quote === '\'' || quote === '"'),
	            'String literal must starts with a quote');

	        start = index;
	        ++index;

	        while (index < length) {
	            ch = source[index++];

	            if (ch === quote) {
	                quote = '';
	                break;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'n':
	                        str += '\n';
	                        break;
	                    case 'r':
	                        str += '\r';
	                        break;
	                    case 't':
	                        str += '\t';
	                        break;
	                    case 'u':
	                    case 'x':
	                        if (source[index] === '{') {
	                            ++index;
	                            str += scanUnicodeCodePointEscape();
	                        } else {
	                            restore = index;
	                            unescaped = scanHexEscape(ch);
	                            if (unescaped) {
	                                str += unescaped;
	                            } else {
	                                index = restore;
	                                str += ch;
	                            }
	                        }
	                        break;
	                    case 'b':
	                        str += '\b';
	                        break;
	                    case 'f':
	                        str += '\f';
	                        break;
	                    case 'v':
	                        str += '\x0B';
	                        break;

	                    default:
	                        if (isOctalDigit(ch)) {
	                            code = '01234567'.indexOf(ch);

	                            // \0 is not octal escape sequence
	                            if (code !== 0) {
	                                octal = true;
	                            }

	                            /* istanbul ignore else */
	                            if (index < length && isOctalDigit(source[index])) {
	                                octal = true;
	                                code = code * 8 + '01234567'.indexOf(source[index++]);

	                                // 3 digits are only allowed when string starts
	                                // with 0, 1, 2, 3
	                                if ('0123'.indexOf(ch) >= 0 &&
	                                        index < length &&
	                                        isOctalDigit(source[index])) {
	                                    code = code * 8 + '01234567'.indexOf(source[index++]);
	                                }
	                            }
	                            str += String.fromCharCode(code);
	                        } else {
	                            str += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch === '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            } else {
	                str += ch;
	            }
	        }

	        if (quote !== '') {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        return {
	            type: Token.StringLiteral,
	            value: str,
	            octal: octal,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }

	    function scanTemplate() {
	        var cooked = '', ch, start, terminated, head, tail, restore, unescaped, code, octal;

	        terminated = false;
	        tail = false;
	        start = index;
	        head = (source[index] === '`');

	        ++index;

	        while (index < length) {
	            ch = source[index++];
	            if (ch === '`') {
	                tail = true;
	                terminated = true;
	                break;
	            } else if (ch === '$') {
	                if (source[index] === '{') {
	                    ++index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'n':
	                        cooked += '\n';
	                        break;
	                    case 'r':
	                        cooked += '\r';
	                        break;
	                    case 't':
	                        cooked += '\t';
	                        break;
	                    case 'u':
	                    case 'x':
	                        if (source[index] === '{') {
	                            ++index;
	                            cooked += scanUnicodeCodePointEscape();
	                        } else {
	                            restore = index;
	                            unescaped = scanHexEscape(ch);
	                            if (unescaped) {
	                                cooked += unescaped;
	                            } else {
	                                index = restore;
	                                cooked += ch;
	                            }
	                        }
	                        break;
	                    case 'b':
	                        cooked += '\b';
	                        break;
	                    case 'f':
	                        cooked += '\f';
	                        break;
	                    case 'v':
	                        cooked += '\v';
	                        break;

	                    default:
	                        if (isOctalDigit(ch)) {
	                            code = '01234567'.indexOf(ch);

	                            // \0 is not octal escape sequence
	                            if (code !== 0) {
	                                octal = true;
	                            }

	                            /* istanbul ignore else */
	                            if (index < length && isOctalDigit(source[index])) {
	                                octal = true;
	                                code = code * 8 + '01234567'.indexOf(source[index++]);

	                                // 3 digits are only allowed when string starts
	                                // with 0, 1, 2, 3
	                                if ('0123'.indexOf(ch) >= 0 &&
	                                        index < length &&
	                                        isOctalDigit(source[index])) {
	                                    code = code * 8 + '01234567'.indexOf(source[index++]);
	                                }
	                            }
	                            cooked += String.fromCharCode(code);
	                        } else {
	                            cooked += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch === '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                ++lineNumber;
	                if (ch === '\r' && source[index] === '\n') {
	                    ++index;
	                }
	                lineStart = index;
	                cooked += '\n';
	            } else {
	                cooked += ch;
	            }
	        }

	        if (!terminated) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        if (index > state.curlyLastIndex) {
	            state.curlyLastIndex = index;
	            if (!tail) {
	                state.curlyStack.push('template');
	            }

	            if (!head) {
	                state.curlyStack.pop();
	            }
	        }

	        return {
	            type: Token.Template,
	            value: {
	                cooked: cooked,
	                raw: source.slice(start + 1, index - ((tail) ? 1 : 2))
	            },
	            head: head,
	            tail: tail,
	            octal: octal,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            range: [start, index]
	        };
	    }

	    function testRegExp(pattern, flags) {
	        var tmp = pattern,
	            value;

	        if (flags.indexOf('u') >= 0) {
	            // Replace each astral symbol and every Unicode code point
	            // escape sequence with a single ASCII symbol to avoid throwing on
	            // regular expressions that are only valid in combination with the
	            // `/u` flag.
	            // Note: replacing with the ASCII symbol `x` might cause false
	            // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
	            // perfectly valid pattern that is equivalent to `[a-b]`, but it
	            // would be replaced by `[x-b]` which throws an error.
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
	                    if (parseInt($1, 16) <= 0x10FFFF) {
	                        return 'x';
	                    }
	                    throwError({}, Messages.InvalidRegExp);
	                })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
	        }

	        // First, detect invalid regular expressions.
	        try {
	            value = new RegExp(tmp);
	        } catch (e) {
	            throwError({}, Messages.InvalidRegExp);
	        }

	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        } catch (exception) {
	            return null;
	        }
	    }

	    function scanRegExpBody() {
	        var ch, str, classMarker, terminated, body;

	        ch = source[index];
	        assert(ch === '/', 'Regular expression literal must start with a slash');
	        str = source[index++];

	        classMarker = false;
	        terminated = false;
	        while (index < length) {
	            ch = source[index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = source[index++];
	                // ECMA-262 7.8.5
	                if (isLineTerminator(ch.charCodeAt(0))) {
	                    throwError({}, Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                throwError({}, Messages.UnterminatedRegExp);
	            } else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            } else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                } else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }

	        if (!terminated) {
	            throwError({}, Messages.UnterminatedRegExp);
	        }

	        // Exclude leading and trailing slash.
	        body = str.substr(1, str.length - 2);
	        return {
	            value: body,
	            literal: str
	        };
	    }

	    function scanRegExpFlags() {
	        var ch, str, flags, restore;

	        str = '';
	        flags = '';
	        while (index < length) {
	            ch = source[index];
	            if (!isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }

	            ++index;
	            if (ch === '\\' && index < length) {
	                ch = source[index];
	                if (ch === 'u') {
	                    ++index;
	                    restore = index;
	                    ch = scanHexEscape('u');
	                    if (ch) {
	                        flags += ch;
	                        for (str += '\\u'; restore < index; ++restore) {
	                            str += source[restore];
	                        }
	                    } else {
	                        index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
	                } else {
	                    str += '\\';
	                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
	                }
	            } else {
	                flags += ch;
	                str += ch;
	            }
	        }

	        return {
	            value: flags,
	            literal: str
	        };
	    }

	    function scanRegExp() {
	        var start, body, flags, value;

	        lookahead = null;
	        skipComment();
	        start = index;

	        body = scanRegExpBody();
	        flags = scanRegExpFlags();
	        value = testRegExp(body.value, flags.value);

	        if (extra.tokenize) {
	            return {
	                type: Token.RegularExpression,
	                value: value,
	                regex: {
	                    pattern: body.value,
	                    flags: flags.value
	                },
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [start, index]
	            };
	        }

	        return {
	            literal: body.literal + flags.literal,
	            value: value,
	            regex: {
	                pattern: body.value,
	                flags: flags.value
	            },
	            range: [start, index]
	        };
	    }

	    function isIdentifierName(token) {
	        return token.type === Token.Identifier ||
	            token.type === Token.Keyword ||
	            token.type === Token.BooleanLiteral ||
	            token.type === Token.NullLiteral;
	    }

	    function advanceSlash() {
	        var prevToken,
	            checkToken;
	        // Using the following algorithm:
	        // https://github.com/mozilla/sweet.js/wiki/design
	        prevToken = extra.tokens[extra.tokens.length - 1];
	        if (!prevToken) {
	            // Nothing before that: it cannot be a division.
	            return scanRegExp();
	        }
	        if (prevToken.type === 'Punctuator') {
	            if (prevToken.value === ')') {
	                checkToken = extra.tokens[extra.openParenToken - 1];
	                if (checkToken &&
	                        checkToken.type === 'Keyword' &&
	                        (checkToken.value === 'if' ||
	                         checkToken.value === 'while' ||
	                         checkToken.value === 'for' ||
	                         checkToken.value === 'with')) {
	                    return scanRegExp();
	                }
	                return scanPunctuator();
	            }
	            if (prevToken.value === '}') {
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                if (extra.tokens[extra.openCurlyToken - 3] &&
	                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
	                    // Anonymous function.
	                    checkToken = extra.tokens[extra.openCurlyToken - 4];
	                    if (!checkToken) {
	                        return scanPunctuator();
	                    }
	                } else if (extra.tokens[extra.openCurlyToken - 4] &&
	                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
	                    // Named function.
	                    checkToken = extra.tokens[extra.openCurlyToken - 5];
	                    if (!checkToken) {
	                        return scanRegExp();
	                    }
	                } else {
	                    return scanPunctuator();
	                }
	                // checkToken determines whether the function is
	                // a declaration or an expression.
	                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
	                    // It is an expression.
	                    return scanPunctuator();
	                }
	                // It is a declaration.
	                return scanRegExp();
	            }
	            return scanRegExp();
	        }
	        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
	            return scanRegExp();
	        }
	        return scanPunctuator();
	    }

	    function advance() {
	        var ch;

	        skipComment();

	        if (index >= length) {
	            return {
	                type: Token.EOF,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                range: [index, index]
	            };
	        }

	        ch = source.charCodeAt(index);

	        // Very common: ( and ) and ;
	        if (ch === 40 || ch === 41 || ch === 58) {
	            return scanPunctuator();
	        }

	        // String literal starts with single quote (#39) or double quote (#34).
	        if (ch === 39 || ch === 34) {
	            return scanStringLiteral();
	        }

	        // Template literals start with backtick (#96) for template head
	        // or close curly (#125) for template middle or template tail.
	        if (ch === 96 || (ch === 125 && state.curlyStack[state.curlyStack.length - 1] === 'template')) {
	            return scanTemplate();
	        }
	        if (isIdentifierStart(ch)) {
	            return scanIdentifier();
	        }

	        // Dot (.) char #46 can also start a floating-point number, hence the need
	        // to check the next character.
	        if (ch === 46) {
	            if (isDecimalDigit(source.charCodeAt(index + 1))) {
	                return scanNumericLiteral();
	            }
	            return scanPunctuator();
	        }

	        if (isDecimalDigit(ch)) {
	            return scanNumericLiteral();
	        }

	        // Slash (/) char #47 can also start a regex.
	        if (extra.tokenize && ch === 47) {
	            return advanceSlash();
	        }

	        return scanPunctuator();
	    }

	    function lex() {
	        var token;

	        token = lookahead;
	        index = token.range[1];
	        lineNumber = token.lineNumber;
	        lineStart = token.lineStart;

	        lookahead = advance();

	        index = token.range[1];
	        lineNumber = token.lineNumber;
	        lineStart = token.lineStart;

	        return token;
	    }

	    function peek() {
	        var pos, line, start;

	        pos = index;
	        line = lineNumber;
	        start = lineStart;
	        lookahead = advance();
	        index = pos;
	        lineNumber = line;
	        lineStart = start;
	    }

	    function lookahead2() {
	        var adv, pos, line, start, result;

	        // If we are collecting the tokens, don't grab the next one yet.
	        /* istanbul ignore next */
	        adv = (typeof extra.advance === 'function') ? extra.advance : advance;

	        pos = index;
	        line = lineNumber;
	        start = lineStart;

	        // Scan for the next immediate token.
	        /* istanbul ignore if */
	        if (lookahead === null) {
	            lookahead = adv();
	        }
	        index = lookahead.range[1];
	        lineNumber = lookahead.lineNumber;
	        lineStart = lookahead.lineStart;

	        // Grab the token right after.
	        result = adv();
	        index = pos;
	        lineNumber = line;
	        lineStart = start;

	        return result;
	    }

	    function markerCreate() {
	        if (!extra.loc && !extra.range) {
	            return undefined;
	        }
	        skipComment();
	        return {offset: index, line: lineNumber, col: index - lineStart};
	    }

	    function processComment(node) {
	        var lastChild,
	            trailingComments,
	            bottomRight = extra.bottomRightStack,
	            last = bottomRight[bottomRight.length - 1];

	        if (node.type === Syntax.Program) {
	            /* istanbul ignore else */
	            if (node.body.length > 0) {
	                return;
	            }
	        }

	        if (extra.trailingComments.length > 0) {
	            if (extra.trailingComments[0].range[0] >= node.range[1]) {
	                trailingComments = extra.trailingComments;
	                extra.trailingComments = [];
	            } else {
	                extra.trailingComments.length = 0;
	            }
	        } else {
	            if (last && last.trailingComments && last.trailingComments[0].range[0] >= node.range[1]) {
	                trailingComments = last.trailingComments;
	                delete last.trailingComments;
	            }
	        }

	        // Eating the stack.
	        if (last) {
	            while (last && last.range[0] >= node.range[0]) {
	                lastChild = last;
	                last = bottomRight.pop();
	            }
	        }

	        if (lastChild) {
	            if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
	                node.leadingComments = lastChild.leadingComments;
	                delete lastChild.leadingComments;
	            }
	        } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
	            node.leadingComments = extra.leadingComments;
	            extra.leadingComments = [];
	        }

	        if (trailingComments) {
	            node.trailingComments = trailingComments;
	        }

	        bottomRight.push(node);
	    }

	    function markerApply(marker, node) {
	        if (extra.range) {
	            node.range = [marker.offset, index];
	        }
	        if (extra.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.col
	                },
	                end: {
	                    line: lineNumber,
	                    column: index - lineStart
	                }
	            };
	            node = delegate.postProcess(node);
	        }
	        if (extra.attachComment) {
	            processComment(node);
	        }
	        return node;
	    }

	    SyntaxTreeDelegate = {

	        name: 'SyntaxTree',

	        postProcess: function (node) {
	            return node;
	        },

	        createArrayExpression: function (elements) {
	            return {
	                type: Syntax.ArrayExpression,
	                elements: elements
	            };
	        },

	        createAssignmentExpression: function (operator, left, right) {
	            return {
	                type: Syntax.AssignmentExpression,
	                operator: operator,
	                left: left,
	                right: right
	            };
	        },

	        createBinaryExpression: function (operator, left, right) {
	            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :
	                        Syntax.BinaryExpression;
	            return {
	                type: type,
	                operator: operator,
	                left: left,
	                right: right
	            };
	        },

	        createBlockStatement: function (body) {
	            return {
	                type: Syntax.BlockStatement,
	                body: body
	            };
	        },

	        createBreakStatement: function (label) {
	            return {
	                type: Syntax.BreakStatement,
	                label: label
	            };
	        },

	        createCallExpression: function (callee, args) {
	            return {
	                type: Syntax.CallExpression,
	                callee: callee,
	                'arguments': args
	            };
	        },

	        createCatchClause: function (param, body) {
	            return {
	                type: Syntax.CatchClause,
	                param: param,
	                body: body
	            };
	        },

	        createConditionalExpression: function (test, consequent, alternate) {
	            return {
	                type: Syntax.ConditionalExpression,
	                test: test,
	                consequent: consequent,
	                alternate: alternate
	            };
	        },

	        createContinueStatement: function (label) {
	            return {
	                type: Syntax.ContinueStatement,
	                label: label
	            };
	        },

	        createDebuggerStatement: function () {
	            return {
	                type: Syntax.DebuggerStatement
	            };
	        },

	        createDoWhileStatement: function (body, test) {
	            return {
	                type: Syntax.DoWhileStatement,
	                body: body,
	                test: test
	            };
	        },

	        createEmptyStatement: function () {
	            return {
	                type: Syntax.EmptyStatement
	            };
	        },

	        createExpressionStatement: function (expression) {
	            return {
	                type: Syntax.ExpressionStatement,
	                expression: expression
	            };
	        },

	        createForStatement: function (init, test, update, body) {
	            return {
	                type: Syntax.ForStatement,
	                init: init,
	                test: test,
	                update: update,
	                body: body
	            };
	        },

	        createForInStatement: function (left, right, body) {
	            return {
	                type: Syntax.ForInStatement,
	                left: left,
	                right: right,
	                body: body,
	                each: false
	            };
	        },

	        createForOfStatement: function (left, right, body) {
	            return {
	                type: Syntax.ForOfStatement,
	                left: left,
	                right: right,
	                body: body
	            };
	        },

	        createFunctionDeclaration: function (id, params, defaults, body, rest, generator, expression) {
	            return {
	                type: Syntax.FunctionDeclaration,
	                id: id,
	                params: params,
	                defaults: defaults,
	                body: body,
	                rest: rest,
	                generator: generator,
	                expression: expression
	            };
	        },

	        createFunctionExpression: function (id, params, defaults, body, rest, generator, expression) {
	            return {
	                type: Syntax.FunctionExpression,
	                id: id,
	                params: params,
	                defaults: defaults,
	                body: body,
	                rest: rest,
	                generator: generator,
	                expression: expression
	            };
	        },

	        createIdentifier: function (name) {
	            return {
	                type: Syntax.Identifier,
	                name: name
	            };
	        },

	        createIfStatement: function (test, consequent, alternate) {
	            return {
	                type: Syntax.IfStatement,
	                test: test,
	                consequent: consequent,
	                alternate: alternate
	            };
	        },

	        createLabeledStatement: function (label, body) {
	            return {
	                type: Syntax.LabeledStatement,
	                label: label,
	                body: body
	            };
	        },

	        createLiteral: function (token) {
	            var object = {
	                type: Syntax.Literal,
	                value: token.value,
	                raw: source.slice(token.range[0], token.range[1])
	            };
	            if (token.regex) {
	                object.regex = token.regex;
	            }
	            return object;
	        },

	        createMemberExpression: function (accessor, object, property) {
	            return {
	                type: Syntax.MemberExpression,
	                computed: accessor === '[',
	                object: object,
	                property: property
	            };
	        },

	        createNewExpression: function (callee, args) {
	            return {
	                type: Syntax.NewExpression,
	                callee: callee,
	                'arguments': args
	            };
	        },

	        createObjectExpression: function (properties) {
	            return {
	                type: Syntax.ObjectExpression,
	                properties: properties
	            };
	        },

	        createPostfixExpression: function (operator, argument) {
	            return {
	                type: Syntax.UpdateExpression,
	                operator: operator,
	                argument: argument,
	                prefix: false
	            };
	        },

	        createProgram: function (body) {
	            return {
	                type: Syntax.Program,
	                body: body
	            };
	        },

	        createProperty: function (kind, key, value, method, shorthand, computed) {
	            return {
	                type: Syntax.Property,
	                key: key,
	                value: value,
	                kind: kind,
	                method: method,
	                shorthand: shorthand,
	                computed: computed
	            };
	        },

	        createReturnStatement: function (argument) {
	            return {
	                type: Syntax.ReturnStatement,
	                argument: argument
	            };
	        },

	        createSequenceExpression: function (expressions) {
	            return {
	                type: Syntax.SequenceExpression,
	                expressions: expressions
	            };
	        },

	        createSwitchCase: function (test, consequent) {
	            return {
	                type: Syntax.SwitchCase,
	                test: test,
	                consequent: consequent
	            };
	        },

	        createSwitchStatement: function (discriminant, cases) {
	            return {
	                type: Syntax.SwitchStatement,
	                discriminant: discriminant,
	                cases: cases
	            };
	        },

	        createThisExpression: function () {
	            return {
	                type: Syntax.ThisExpression
	            };
	        },

	        createThrowStatement: function (argument) {
	            return {
	                type: Syntax.ThrowStatement,
	                argument: argument
	            };
	        },

	        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
	            return {
	                type: Syntax.TryStatement,
	                block: block,
	                guardedHandlers: guardedHandlers,
	                handlers: handlers,
	                finalizer: finalizer
	            };
	        },

	        createUnaryExpression: function (operator, argument) {
	            if (operator === '++' || operator === '--') {
	                return {
	                    type: Syntax.UpdateExpression,
	                    operator: operator,
	                    argument: argument,
	                    prefix: true
	                };
	            }
	            return {
	                type: Syntax.UnaryExpression,
	                operator: operator,
	                argument: argument,
	                prefix: true
	            };
	        },

	        createVariableDeclaration: function (declarations, kind) {
	            return {
	                type: Syntax.VariableDeclaration,
	                declarations: declarations,
	                kind: kind
	            };
	        },

	        createVariableDeclarator: function (id, init) {
	            return {
	                type: Syntax.VariableDeclarator,
	                id: id,
	                init: init
	            };
	        },

	        createWhileStatement: function (test, body) {
	            return {
	                type: Syntax.WhileStatement,
	                test: test,
	                body: body
	            };
	        },

	        createWithStatement: function (object, body) {
	            return {
	                type: Syntax.WithStatement,
	                object: object,
	                body: body
	            };
	        },

	        createTemplateElement: function (value, tail) {
	            return {
	                type: Syntax.TemplateElement,
	                value: value,
	                tail: tail
	            };
	        },

	        createTemplateLiteral: function (quasis, expressions) {
	            return {
	                type: Syntax.TemplateLiteral,
	                quasis: quasis,
	                expressions: expressions
	            };
	        },

	        createSpreadElement: function (argument) {
	            return {
	                type: Syntax.SpreadElement,
	                argument: argument
	            };
	        },

	        createTaggedTemplateExpression: function (tag, quasi) {
	            return {
	                type: Syntax.TaggedTemplateExpression,
	                tag: tag,
	                quasi: quasi
	            };
	        },

	        createArrowFunctionExpression: function (params, defaults, body, rest, expression) {
	            return {
	                type: Syntax.ArrowFunctionExpression,
	                id: null,
	                params: params,
	                defaults: defaults,
	                body: body,
	                rest: rest,
	                generator: false,
	                expression: expression
	            };
	        },

	        createMethodDefinition: function (propertyType, kind, key, value, computed) {
	            return {
	                type: Syntax.MethodDefinition,
	                key: key,
	                value: value,
	                kind: kind,
	                'static': propertyType === ClassPropertyType.static,
	                computed: computed
	            };
	        },

	        createClassBody: function (body) {
	            return {
	                type: Syntax.ClassBody,
	                body: body
	            };
	        },

	        createClassExpression: function (id, superClass, body) {
	            return {
	                type: Syntax.ClassExpression,
	                id: id,
	                superClass: superClass,
	                body: body
	            };
	        },

	        createClassDeclaration: function (id, superClass, body) {
	            return {
	                type: Syntax.ClassDeclaration,
	                id: id,
	                superClass: superClass,
	                body: body
	            };
	        },

	        createExportSpecifier: function (id, name) {
	            return {
	                type: Syntax.ExportSpecifier,
	                id: id,
	                name: name
	            };
	        },

	        createExportBatchSpecifier: function () {
	            return {
	                type: Syntax.ExportBatchSpecifier
	            };
	        },

	        createImportDefaultSpecifier: function (id) {
	            return {
	                type: Syntax.ImportDefaultSpecifier,
	                id: id
	            };
	        },

	        createImportNamespaceSpecifier: function (id) {
	            return {
	                type: Syntax.ImportNamespaceSpecifier,
	                id: id
	            };
	        },

	        createExportDeclaration: function (isDefault, declaration, specifiers, src) {
	            return {
	                type: Syntax.ExportDeclaration,
	                'default': !!isDefault,
	                declaration: declaration,
	                specifiers: specifiers,
	                source: src
	            };
	        },

	        createImportSpecifier: function (id, name) {
	            return {
	                type: Syntax.ImportSpecifier,
	                id: id,
	                name: name
	            };
	        },

	        createImportDeclaration: function (specifiers, src) {
	            return {
	                type: Syntax.ImportDeclaration,
	                specifiers: specifiers,
	                source: src
	            };
	        },

	        createYieldExpression: function (argument, dlg) {
	            return {
	                type: Syntax.YieldExpression,
	                argument: argument,
	                delegate: dlg
	            };
	        },

	        createComprehensionExpression: function (filter, blocks, body) {
	            return {
	                type: Syntax.ComprehensionExpression,
	                filter: filter,
	                blocks: blocks,
	                body: body
	            };
	        }

	    };

	    // Return true if there is a line terminator before the next token.

	    function peekLineTerminator() {
	        var pos, line, start, found;

	        pos = index;
	        line = lineNumber;
	        start = lineStart;
	        skipComment();
	        found = lineNumber !== line;
	        index = pos;
	        lineNumber = line;
	        lineStart = start;

	        return found;
	    }

	    // Throw an exception

	    function throwError(token, messageFormat) {
	        var error,
	            args = Array.prototype.slice.call(arguments, 2),
	            msg = messageFormat.replace(
	                /%(\d)/g,
	                function (whole, idx) {
	                    assert(idx < args.length, 'Message reference must be in range');
	                    return args[idx];
	                }
	            );

	        if (typeof token.lineNumber === 'number') {
	            error = new Error('Line ' + token.lineNumber + ': ' + msg);
	            error.index = token.range[0];
	            error.lineNumber = token.lineNumber;
	            error.column = token.range[0] - lineStart + 1;
	        } else {
	            error = new Error('Line ' + lineNumber + ': ' + msg);
	            error.index = index;
	            error.lineNumber = lineNumber;
	            error.column = index - lineStart + 1;
	        }

	        error.description = msg;
	        throw error;
	    }

	    function throwErrorTolerant() {
	        try {
	            throwError.apply(null, arguments);
	        } catch (e) {
	            if (extra.errors) {
	                extra.errors.push(e);
	            } else {
	                throw e;
	            }
	        }
	    }


	    // Throw an exception because of the token.

	    function throwUnexpected(token) {
	        if (token.type === Token.EOF) {
	            throwError(token, Messages.UnexpectedEOS);
	        }

	        if (token.type === Token.NumericLiteral) {
	            throwError(token, Messages.UnexpectedNumber);
	        }

	        if (token.type === Token.StringLiteral) {
	            throwError(token, Messages.UnexpectedString);
	        }

	        if (token.type === Token.Identifier) {
	            throwError(token, Messages.UnexpectedIdentifier);
	        }

	        if (token.type === Token.Keyword) {
	            if (isFutureReservedWord(token.value)) {
	                throwError(token, Messages.UnexpectedReserved);
	            } else if (strict && isStrictModeReservedWord(token.value)) {
	                throwErrorTolerant(token, Messages.StrictReservedWord);
	                return;
	            }
	            throwError(token, Messages.UnexpectedToken, token.value);
	        }

	        if (token.type === Token.Template) {
	            throwError(token, Messages.UnexpectedTemplate, token.value.raw);
	        }

	        // BooleanLiteral, NullLiteral, or Punctuator.
	        throwError(token, Messages.UnexpectedToken, token.value);
	    }

	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.

	    function expect(value) {
	        var token = lex();
	        if (token.type !== Token.Punctuator || token.value !== value) {
	            throwUnexpected(token);
	        }
	    }

	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.

	    function expectKeyword(keyword) {
	        var token = lex();
	        if (token.type !== Token.Keyword || token.value !== keyword) {
	            throwUnexpected(token);
	        }
	    }

	    // Return true if the next token matches the specified punctuator.

	    function match(value) {
	        return lookahead.type === Token.Punctuator && lookahead.value === value;
	    }

	    // Return true if the next token matches the specified keyword

	    function matchKeyword(keyword) {
	        return lookahead.type === Token.Keyword && lookahead.value === keyword;
	    }


	    // Return true if the next token matches the specified contextual keyword

	    function matchContextualKeyword(keyword) {
	        return lookahead.type === Token.Identifier && lookahead.value === keyword;
	    }

	    // Return true if the next token is an assignment operator

	    function matchAssign() {
	        var op;

	        if (lookahead.type !== Token.Punctuator) {
	            return false;
	        }
	        op = lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    }

	    function consumeSemicolon() {
	        var line, oldIndex = index, oldLineNumber = lineNumber,
	            oldLineStart = lineStart, oldLookahead = lookahead;

	        // Catch the very common case first: immediately a semicolon (char #59).
	        if (source.charCodeAt(index) === 59) {
	            lex();
	            return;
	        }

	        line = lineNumber;
	        skipComment();
	        if (lineNumber !== line) {
	            index = oldIndex;
	            lineNumber = oldLineNumber;
	            lineStart = oldLineStart;
	            lookahead = oldLookahead;
	            return;
	        }

	        if (match(';')) {
	            lex();
	            return;
	        }

	        if (lookahead.type !== Token.EOF && !match('}')) {
	            throwUnexpected(lookahead);
	        }
	    }

	    // Return true if provided expression is LeftHandSideExpression

	    function isLeftHandSide(expr) {
	        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
	    }

	    function isAssignableLeftHandSide(expr) {
	        return isLeftHandSide(expr) || expr.type === Syntax.ObjectPattern || expr.type === Syntax.ArrayPattern;
	    }

	    // 11.1.4 Array Initialiser

	    function parseArrayInitialiser() {
	        var elements = [], blocks = [], filter = null, tmp, possiblecomprehension = true,
	            marker = markerCreate();

	        expect('[');
	        while (!match(']')) {
	            if (lookahead.value === 'for' &&
	                    lookahead.type === Token.Keyword) {
	                if (!possiblecomprehension) {
	                    throwError({}, Messages.ComprehensionError);
	                }
	                matchKeyword('for');
	                tmp = parseForStatement({ignoreBody: true});
	                tmp.of = tmp.type === Syntax.ForOfStatement;
	                tmp.type = Syntax.ComprehensionBlock;
	                if (tmp.left.kind) { // can't be let or const
	                    throwError({}, Messages.ComprehensionError);
	                }
	                blocks.push(tmp);
	            } else if (lookahead.value === 'if' &&
	                           lookahead.type === Token.Keyword) {
	                if (!possiblecomprehension) {
	                    throwError({}, Messages.ComprehensionError);
	                }
	                expectKeyword('if');
	                expect('(');
	                filter = parseExpression();
	                expect(')');
	            } else if (lookahead.value === ',' &&
	                           lookahead.type === Token.Punctuator) {
	                possiblecomprehension = false; // no longer allowed.
	                lex();
	                elements.push(null);
	            } else {
	                tmp = parseSpreadOrAssignmentExpression();
	                elements.push(tmp);
	                if (tmp && tmp.type === Syntax.SpreadElement) {
	                    if (!match(']')) {
	                        throwError({}, Messages.ElementAfterSpreadElement);
	                    }
	                } else if (!(match(']') || matchKeyword('for') || matchKeyword('if'))) {
	                    expect(','); // this lexes.
	                    possiblecomprehension = false;
	                }
	            }
	        }

	        expect(']');

	        if (filter && !blocks.length) {
	            throwError({}, Messages.ComprehensionRequiresBlock);
	        }

	        if (blocks.length) {
	            if (elements.length !== 1) {
	                throwError({}, Messages.ComprehensionError);
	            }
	            return markerApply(marker, delegate.createComprehensionExpression(filter, blocks, elements[0]));
	        }
	        return markerApply(marker, delegate.createArrayExpression(elements));
	    }

	    // 11.1.5 Object Initialiser

	    function parsePropertyFunction(options) {
	        var previousStrict, previousYieldAllowed, params, defaults, body,
	            marker = markerCreate();

	        previousStrict = strict;
	        previousYieldAllowed = state.yieldAllowed;
	        state.yieldAllowed = options.generator;
	        params = options.params || [];
	        defaults = options.defaults || [];

	        body = parseConciseBody();
	        if (options.name && strict && isRestrictedWord(params[0].name)) {
	            throwErrorTolerant(options.name, Messages.StrictParamName);
	        }
	        strict = previousStrict;
	        state.yieldAllowed = previousYieldAllowed;

	        return markerApply(marker, delegate.createFunctionExpression(
	            null,
	            params,
	            defaults,
	            body,
	            options.rest || null,
	            options.generator,
	            body.type !== Syntax.BlockStatement
	        ));
	    }


	    function parsePropertyMethodFunction(options) {
	        var previousStrict, tmp, method;

	        previousStrict = strict;
	        strict = true;

	        tmp = parseParams();

	        if (tmp.stricted) {
	            throwErrorTolerant(tmp.stricted, tmp.message);
	        }


	        method = parsePropertyFunction({
	            params: tmp.params,
	            defaults: tmp.defaults,
	            rest: tmp.rest,
	            generator: options.generator
	        });

	        strict = previousStrict;

	        return method;
	    }


	    function parseObjectPropertyKey() {
	        var marker = markerCreate(),
	            token = lex(),
	            propertyKey,
	            result;

	        // Note: This function is called only from parseObjectProperty(), where
	        // EOF and Punctuator tokens are already filtered out.

	        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
	            if (strict && token.octal) {
	                throwErrorTolerant(token, Messages.StrictOctalLiteral);
	            }
	            return markerApply(marker, delegate.createLiteral(token));
	        }

	        if (token.type === Token.Punctuator && token.value === '[') {
	            // For computed properties we should skip the [ and ], and
	            // capture in marker only the assignment expression itself.
	            marker = markerCreate();
	            propertyKey = parseAssignmentExpression();
	            result = markerApply(marker, propertyKey);
	            expect(']');
	            return result;
	        }

	        return markerApply(marker, delegate.createIdentifier(token.value));
	    }

	    function parseObjectProperty() {
	        var token, key, id, param, computed,
	            marker = markerCreate();

	        token = lookahead;
	        computed = (token.value === '[' && token.type === Token.Punctuator);

	        if (token.type === Token.Identifier || computed) {

	            id = parseObjectPropertyKey();

	            // Property Assignment: Getter and Setter.

	            if (token.value === 'get' && !(match(':') || match('('))) {
	                computed = (lookahead.value === '[');
	                key = parseObjectPropertyKey();
	                expect('(');
	                expect(')');
	                return markerApply(marker, delegate.createProperty('get', key, parsePropertyFunction({ generator: false }), false, false, computed));
	            }
	            if (token.value === 'set' && !(match(':') || match('('))) {
	                computed = (lookahead.value === '[');
	                key = parseObjectPropertyKey();
	                expect('(');
	                token = lookahead;
	                param = [ parseVariableIdentifier() ];
	                expect(')');
	                return markerApply(marker, delegate.createProperty('set', key, parsePropertyFunction({ params: param, generator: false, name: token }), false, false, computed));
	            }
	            if (match(':')) {
	                lex();
	                return markerApply(marker, delegate.createProperty('init', id, parseAssignmentExpression(), false, false, computed));
	            }
	            if (match('(')) {
	                return markerApply(marker, delegate.createProperty('init', id, parsePropertyMethodFunction({ generator: false }), true, false, computed));
	            }
	            if (computed) {
	                // Computed properties can only be used with full notation.
	                throwUnexpected(lookahead);
	            }
	            return markerApply(marker, delegate.createProperty('init', id, id, false, true, false));
	        }
	        if (token.type === Token.EOF || token.type === Token.Punctuator) {
	            if (!match('*')) {
	                throwUnexpected(token);
	            }
	            lex();

	            computed = (lookahead.type === Token.Punctuator && lookahead.value === '[');

	            id = parseObjectPropertyKey();

	            if (!match('(')) {
	                throwUnexpected(lex());
	            }

	            return markerApply(marker, delegate.createProperty('init', id, parsePropertyMethodFunction({ generator: true }), true, false, computed));
	        }
	        key = parseObjectPropertyKey();
	        if (match(':')) {
	            lex();
	            return markerApply(marker, delegate.createProperty('init', key, parseAssignmentExpression(), false, false, false));
	        }
	        if (match('(')) {
	            return markerApply(marker, delegate.createProperty('init', key, parsePropertyMethodFunction({ generator: false }), true, false, false));
	        }
	        throwUnexpected(lex());
	    }

	    function getFieldName(key) {
	        var toString = String;
	        if (key.type === Syntax.Identifier) {
	            return key.name;
	        }
	        return toString(key.value);
	    }

	    function parseObjectInitialiser() {
	        var properties = [], property, name, kind, storedKind, map = new StringMap(),
	            marker = markerCreate();

	        expect('{');

	        while (!match('}')) {
	            property = parseObjectProperty();

	            if (!property.computed) {
	                name = getFieldName(property.key);
	                kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

	                if (map.has(name)) {
	                    storedKind = map.get(name);
	                    if (storedKind === PropertyKind.Data) {
	                        if (strict && kind === PropertyKind.Data) {
	                            throwErrorTolerant({}, Messages.StrictDuplicateProperty);
	                        } else if (kind !== PropertyKind.Data) {
	                            throwErrorTolerant({}, Messages.AccessorDataProperty);
	                        }
	                    } else {
	                        if (kind === PropertyKind.Data) {
	                            throwErrorTolerant({}, Messages.AccessorDataProperty);
	                        } else if (storedKind & kind) {
	                            throwErrorTolerant({}, Messages.AccessorGetSet);
	                        }
	                    }
	                    map.set(name, storedKind | kind);
	                } else {
	                    map.set(name, kind);
	                }
	            }

	            properties.push(property);

	            if (!match('}')) {
	                expect(',');
	            }
	        }

	        expect('}');

	        return markerApply(marker, delegate.createObjectExpression(properties));
	    }

	    function parseTemplateElement(option) {
	        var marker, token;

	        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
	            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	        }

	        marker = markerCreate();
	        token = lex();

	        if (strict && token.octal) {
	            throwError(token, Messages.StrictOctalLiteral);
	        }
	        return markerApply(marker, delegate.createTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail));
	    }

	    function parseTemplateLiteral() {
	        var quasi, quasis, expressions, marker = markerCreate();

	        quasi = parseTemplateElement({ head: true });
	        quasis = [ quasi ];
	        expressions = [];

	        while (!quasi.tail) {
	            expressions.push(parseExpression());
	            quasi = parseTemplateElement({ head: false });
	            quasis.push(quasi);
	        }

	        return markerApply(marker, delegate.createTemplateLiteral(quasis, expressions));
	    }

	    // 11.1.6 The Grouping Operator

	    function parseGroupExpression() {
	        var expr;

	        expect('(');

	        ++state.parenthesizedCount;

	        expr = parseExpression();

	        expect(')');

	        return expr;
	    }


	    // 11.1 Primary Expressions

	    function parsePrimaryExpression() {
	        var marker, type, token, expr;

	        type = lookahead.type;

	        if (type === Token.Identifier) {
	            marker = markerCreate();
	            return markerApply(marker, delegate.createIdentifier(lex().value));
	        }

	        if (type === Token.StringLiteral || type === Token.NumericLiteral) {
	            if (strict && lookahead.octal) {
	                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
	            }
	            marker = markerCreate();
	            return markerApply(marker, delegate.createLiteral(lex()));
	        }

	        if (type === Token.Keyword) {
	            if (matchKeyword('this')) {
	                marker = markerCreate();
	                lex();
	                return markerApply(marker, delegate.createThisExpression());
	            }

	            if (matchKeyword('function')) {
	                return parseFunctionExpression();
	            }

	            if (matchKeyword('class')) {
	                return parseClassExpression();
	            }

	            if (matchKeyword('super')) {
	                marker = markerCreate();
	                lex();
	                return markerApply(marker, delegate.createIdentifier('super'));
	            }
	        }

	        if (type === Token.BooleanLiteral) {
	            marker = markerCreate();
	            token = lex();
	            token.value = (token.value === 'true');
	            return markerApply(marker, delegate.createLiteral(token));
	        }

	        if (type === Token.NullLiteral) {
	            marker = markerCreate();
	            token = lex();
	            token.value = null;
	            return markerApply(marker, delegate.createLiteral(token));
	        }

	        if (match('[')) {
	            return parseArrayInitialiser();
	        }

	        if (match('{')) {
	            return parseObjectInitialiser();
	        }

	        if (match('(')) {
	            return parseGroupExpression();
	        }

	        if (match('/') || match('/=')) {
	            marker = markerCreate();
	            expr = delegate.createLiteral(scanRegExp());
	            peek();
	            return markerApply(marker, expr);
	        }

	        if (type === Token.Template) {
	            return parseTemplateLiteral();
	        }

	        throwUnexpected(lex());
	    }

	    // 11.2 Left-Hand-Side Expressions

	    function parseArguments() {
	        var args = [], arg;

	        expect('(');

	        if (!match(')')) {
	            while (index < length) {
	                arg = parseSpreadOrAssignmentExpression();
	                args.push(arg);

	                if (match(')')) {
	                    break;
	                } else if (arg.type === Syntax.SpreadElement) {
	                    throwError({}, Messages.ElementAfterSpreadElement);
	                }

	                expect(',');
	            }
	        }

	        expect(')');

	        return args;
	    }

	    function parseSpreadOrAssignmentExpression() {
	        if (match('...')) {
	            var marker = markerCreate();
	            lex();
	            return markerApply(marker, delegate.createSpreadElement(parseAssignmentExpression()));
	        }
	        return parseAssignmentExpression();
	    }

	    function parseNonComputedProperty() {
	        var marker = markerCreate(),
	            token = lex();

	        if (!isIdentifierName(token)) {
	            throwUnexpected(token);
	        }

	        return markerApply(marker, delegate.createIdentifier(token.value));
	    }

	    function parseNonComputedMember() {
	        expect('.');

	        return parseNonComputedProperty();
	    }

	    function parseComputedMember() {
	        var expr;

	        expect('[');

	        expr = parseExpression();

	        expect(']');

	        return expr;
	    }

	    function parseNewExpression() {
	        var callee, args, marker = markerCreate();

	        expectKeyword('new');
	        callee = parseLeftHandSideExpression();
	        args = match('(') ? parseArguments() : [];

	        return markerApply(marker, delegate.createNewExpression(callee, args));
	    }

	    function parseLeftHandSideExpressionAllowCall() {
	        var expr, args, marker = markerCreate();

	        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

	        while (match('.') || match('[') || match('(') || (lookahead.type === Token.Template && lookahead.head)) {
	            if (match('(')) {
	                args = parseArguments();
	                expr = markerApply(marker, delegate.createCallExpression(expr, args));
	            } else if (match('[')) {
	                expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));
	            } else if (match('.')) {
	                expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));
	            } else {
	                expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));
	            }
	        }

	        return expr;
	    }

	    function parseLeftHandSideExpression() {
	        var expr, marker = markerCreate();

	        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

	        while (match('.') || match('[') || (lookahead.type === Token.Template && lookahead.head)) {
	            if (match('[')) {
	                expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));
	            } else if (match('.')) {
	                expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));
	            } else {
	                expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));
	            }
	        }

	        return expr;
	    }

	    // 11.3 Postfix Expressions

	    function parsePostfixExpression() {
	        var marker = markerCreate(),
	            expr = parseLeftHandSideExpressionAllowCall(),
	            token;

	        if (lookahead.type !== Token.Punctuator) {
	            return expr;
	        }

	        if ((match('++') || match('--')) && !peekLineTerminator()) {
	            // 11.3.1, 11.3.2
	            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                throwErrorTolerant({}, Messages.StrictLHSPostfix);
	            }

	            if (!isLeftHandSide(expr)) {
	                throwError({}, Messages.InvalidLHSInAssignment);
	            }

	            token = lex();
	            expr = markerApply(marker, delegate.createPostfixExpression(token.value, expr));
	        }

	        return expr;
	    }

	    // 11.4 Unary Operators

	    function parseUnaryExpression() {
	        var marker, token, expr;

	        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
	            return parsePostfixExpression();
	        }

	        if (match('++') || match('--')) {
	            marker = markerCreate();
	            token = lex();
	            expr = parseUnaryExpression();
	            // 11.4.4, 11.4.5
	            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                throwErrorTolerant({}, Messages.StrictLHSPrefix);
	            }

	            if (!isLeftHandSide(expr)) {
	                throwError({}, Messages.InvalidLHSInAssignment);
	            }

	            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));
	        }

	        if (match('+') || match('-') || match('~') || match('!')) {
	            marker = markerCreate();
	            token = lex();
	            expr = parseUnaryExpression();
	            return markerApply(marker, delegate.createUnaryExpression(token.value, expr));
	        }

	        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
	            marker = markerCreate();
	            token = lex();
	            expr = parseUnaryExpression();
	            expr = markerApply(marker, delegate.createUnaryExpression(token.value, expr));
	            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
	                throwErrorTolerant({}, Messages.StrictDelete);
	            }
	            return expr;
	        }

	        return parsePostfixExpression();
	    }

	    function binaryPrecedence(token, allowIn) {
	        var prec = 0;

	        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
	            return 0;
	        }

	        switch (token.value) {
	        case '||':
	            prec = 1;
	            break;

	        case '&&':
	            prec = 2;
	            break;

	        case '|':
	            prec = 3;
	            break;

	        case '^':
	            prec = 4;
	            break;

	        case '&':
	            prec = 5;
	            break;

	        case '==':
	        case '!=':
	        case '===':
	        case '!==':
	            prec = 6;
	            break;

	        case '<':
	        case '>':
	        case '<=':
	        case '>=':
	        case 'instanceof':
	            prec = 7;
	            break;

	        case 'in':
	            prec = allowIn ? 7 : 0;
	            break;

	        case '<<':
	        case '>>':
	        case '>>>':
	            prec = 8;
	            break;

	        case '+':
	        case '-':
	            prec = 9;
	            break;

	        case '*':
	        case '/':
	        case '%':
	            prec = 11;
	            break;

	        default:
	            break;
	        }

	        return prec;
	    }

	    // 11.5 Multiplicative Operators
	    // 11.6 Additive Operators
	    // 11.7 Bitwise Shift Operators
	    // 11.8 Relational Operators
	    // 11.9 Equality Operators
	    // 11.10 Binary Bitwise Operators
	    // 11.11 Binary Logical Operators

	    function parseBinaryExpression() {
	        var expr, token, prec, previousAllowIn, stack, right, operator, left, i,
	            marker, markers;

	        previousAllowIn = state.allowIn;
	        state.allowIn = true;

	        marker = markerCreate();
	        left = parseUnaryExpression();

	        token = lookahead;
	        prec = binaryPrecedence(token, previousAllowIn);
	        if (prec === 0) {
	            return left;
	        }
	        token.prec = prec;
	        lex();

	        markers = [marker, markerCreate()];
	        right = parseUnaryExpression();

	        stack = [left, token, right];

	        while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {

	            // Reduce: make a binary expression from the three topmost entries.
	            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
	                right = stack.pop();
	                operator = stack.pop().value;
	                left = stack.pop();
	                expr = delegate.createBinaryExpression(operator, left, right);
	                markers.pop();
	                marker = markers.pop();
	                markerApply(marker, expr);
	                stack.push(expr);
	                markers.push(marker);
	            }

	            // Shift.
	            token = lex();
	            token.prec = prec;
	            stack.push(token);
	            markers.push(markerCreate());
	            expr = parseUnaryExpression();
	            stack.push(expr);
	        }

	        state.allowIn = previousAllowIn;

	        // Final reduce to clean-up the stack.
	        i = stack.length - 1;
	        expr = stack[i];
	        markers.pop();
	        while (i > 1) {
	            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
	            i -= 2;
	            marker = markers.pop();
	            markerApply(marker, expr);
	        }

	        return expr;
	    }


	    // 11.12 Conditional Operator

	    function parseConditionalExpression() {
	        var expr, previousAllowIn, consequent, alternate, marker = markerCreate();
	        expr = parseBinaryExpression();

	        if (match('?')) {
	            lex();
	            previousAllowIn = state.allowIn;
	            state.allowIn = true;
	            consequent = parseAssignmentExpression();
	            state.allowIn = previousAllowIn;
	            expect(':');
	            alternate = parseAssignmentExpression();

	            expr = markerApply(marker, delegate.createConditionalExpression(expr, consequent, alternate));
	        }

	        return expr;
	    }

	    // 11.13 Assignment Operators

	    // 12.14.5 AssignmentPattern

	    function reinterpretAsAssignmentBindingPattern(expr) {
	        var i, len, property, element;

	        if (expr.type === Syntax.ObjectExpression) {
	            expr.type = Syntax.ObjectPattern;
	            for (i = 0, len = expr.properties.length; i < len; i += 1) {
	                property = expr.properties[i];
	                if (property.kind !== 'init') {
	                    throwError({}, Messages.InvalidLHSInAssignment);
	                }
	                reinterpretAsAssignmentBindingPattern(property.value);
	            }
	        } else if (expr.type === Syntax.ArrayExpression) {
	            expr.type = Syntax.ArrayPattern;
	            for (i = 0, len = expr.elements.length; i < len; i += 1) {
	                element = expr.elements[i];
	                /* istanbul ignore else */
	                if (element) {
	                    reinterpretAsAssignmentBindingPattern(element);
	                }
	            }
	        } else if (expr.type === Syntax.Identifier) {
	            if (isRestrictedWord(expr.name)) {
	                throwError({}, Messages.InvalidLHSInAssignment);
	            }
	        } else if (expr.type === Syntax.SpreadElement) {
	            reinterpretAsAssignmentBindingPattern(expr.argument);
	            if (expr.argument.type === Syntax.ObjectPattern) {
	                throwError({}, Messages.ObjectPatternAsSpread);
	            }
	        } else {
	            /* istanbul ignore else */
	            if (expr.type !== Syntax.MemberExpression && expr.type !== Syntax.CallExpression && expr.type !== Syntax.NewExpression) {
	                throwError({}, Messages.InvalidLHSInAssignment);
	            }
	        }
	    }

	    // 13.2.3 BindingPattern

	    function reinterpretAsDestructuredParameter(options, expr) {
	        var i, len, property, element;

	        if (expr.type === Syntax.ObjectExpression) {
	            expr.type = Syntax.ObjectPattern;
	            for (i = 0, len = expr.properties.length; i < len; i += 1) {
	                property = expr.properties[i];
	                if (property.kind !== 'init') {
	                    throwError({}, Messages.InvalidLHSInFormalsList);
	                }
	                reinterpretAsDestructuredParameter(options, property.value);
	            }
	        } else if (expr.type === Syntax.ArrayExpression) {
	            expr.type = Syntax.ArrayPattern;
	            for (i = 0, len = expr.elements.length; i < len; i += 1) {
	                element = expr.elements[i];
	                if (element) {
	                    reinterpretAsDestructuredParameter(options, element);
	                }
	            }
	        } else if (expr.type === Syntax.Identifier) {
	            validateParam(options, expr, expr.name);
	        } else if (expr.type === Syntax.SpreadElement) {
	            // BindingRestElement only allows BindingIdentifier
	            if (expr.argument.type !== Syntax.Identifier) {
	                throwError({}, Messages.InvalidLHSInFormalsList);
	            }
	            validateParam(options, expr.argument, expr.argument.name);
	        } else {
	            throwError({}, Messages.InvalidLHSInFormalsList);
	        }
	    }

	    function reinterpretAsCoverFormalsList(expressions) {
	        var i, len, param, params, defaults, defaultCount, options, rest;

	        params = [];
	        defaults = [];
	        defaultCount = 0;
	        rest = null;
	        options = {
	            paramSet: new StringMap()
	        };

	        for (i = 0, len = expressions.length; i < len; i += 1) {
	            param = expressions[i];
	            if (param.type === Syntax.Identifier) {
	                params.push(param);
	                defaults.push(null);
	                validateParam(options, param, param.name);
	            } else if (param.type === Syntax.ObjectExpression || param.type === Syntax.ArrayExpression) {
	                reinterpretAsDestructuredParameter(options, param);
	                params.push(param);
	                defaults.push(null);
	            } else if (param.type === Syntax.SpreadElement) {
	                assert(i === len - 1, 'It is guaranteed that SpreadElement is last element by parseExpression');
	                if (param.argument.type !== Syntax.Identifier) {
	                    throwError({}, Messages.InvalidLHSInFormalsList);
	                }
	                reinterpretAsDestructuredParameter(options, param.argument);
	                rest = param.argument;
	            } else if (param.type === Syntax.AssignmentExpression) {
	                params.push(param.left);
	                defaults.push(param.right);
	                ++defaultCount;
	                validateParam(options, param.left, param.left.name);
	            } else {
	                return null;
	            }
	        }

	        if (options.message === Messages.StrictParamDupe) {
	            throwError(
	                strict ? options.stricted : options.firstRestricted,
	                options.message
	            );
	        }

	        if (defaultCount === 0) {
	            defaults = [];
	        }

	        return {
	            params: params,
	            defaults: defaults,
	            rest: rest,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    }

	    function parseArrowFunctionExpression(options, marker) {
	        var previousStrict, previousYieldAllowed, body;

	        expect('=>');

	        previousStrict = strict;
	        previousYieldAllowed = state.yieldAllowed;
	        state.yieldAllowed = false;
	        body = parseConciseBody();

	        if (strict && options.firstRestricted) {
	            throwError(options.firstRestricted, options.message);
	        }
	        if (strict && options.stricted) {
	            throwErrorTolerant(options.stricted, options.message);
	        }

	        strict = previousStrict;
	        state.yieldAllowed = previousYieldAllowed;

	        return markerApply(marker, delegate.createArrowFunctionExpression(
	            options.params,
	            options.defaults,
	            body,
	            options.rest,
	            body.type !== Syntax.BlockStatement
	        ));
	    }

	    function parseAssignmentExpression() {
	        var marker, expr, token, params, oldParenthesizedCount,
	            startsWithParen = false;

	        // Note that 'yield' is treated as a keyword in strict mode, but a
	        // contextual keyword (identifier) in non-strict mode, so we need
	        // to use matchKeyword and matchContextualKeyword appropriately.
	        if ((state.yieldAllowed && matchContextualKeyword('yield')) || (strict && matchKeyword('yield'))) {
	            return parseYieldExpression();
	        }

	        oldParenthesizedCount = state.parenthesizedCount;

	        marker = markerCreate();

	        if (match('(')) {
	            token = lookahead2();
	            if ((token.type === Token.Punctuator && token.value === ')') || token.value === '...') {
	                params = parseParams();
	                if (!match('=>')) {
	                    throwUnexpected(lex());
	                }
	                return parseArrowFunctionExpression(params, marker);
	            }
	            startsWithParen = true;
	        }

	        token = lookahead;
	        expr = parseConditionalExpression();

	        if (match('=>') &&
	                (state.parenthesizedCount === oldParenthesizedCount ||
	                state.parenthesizedCount === (oldParenthesizedCount + 1))) {
	            if (expr.type === Syntax.Identifier) {
	                params = reinterpretAsCoverFormalsList([ expr ]);
	            } else if (expr.type === Syntax.AssignmentExpression ||
	                    expr.type === Syntax.ArrayExpression ||
	                    expr.type === Syntax.ObjectExpression) {
	                if (!startsWithParen) {
	                    throwUnexpected(lex());
	                }
	                params = reinterpretAsCoverFormalsList([ expr ]);
	            } else if (expr.type === Syntax.SequenceExpression) {
	                params = reinterpretAsCoverFormalsList(expr.expressions);
	            }
	            if (params) {
	                return parseArrowFunctionExpression(params, marker);
	            }
	        }

	        if (matchAssign()) {
	            // 11.13.1
	            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                throwErrorTolerant(token, Messages.StrictLHSAssignment);
	            }

	            // ES.next draf 11.13 Runtime Semantics step 1
	            if (match('=') && (expr.type === Syntax.ObjectExpression || expr.type === Syntax.ArrayExpression)) {
	                reinterpretAsAssignmentBindingPattern(expr);
	            } else if (!isLeftHandSide(expr)) {
	                throwError({}, Messages.InvalidLHSInAssignment);
	            }

	            expr = markerApply(marker, delegate.createAssignmentExpression(lex().value, expr, parseAssignmentExpression()));
	        }

	        return expr;
	    }

	    // 11.14 Comma Operator

	    function parseExpression() {
	        var marker, expr, expressions, sequence, spreadFound;

	        marker = markerCreate();
	        expr = parseAssignmentExpression();
	        expressions = [ expr ];

	        if (match(',')) {
	            while (index < length) {
	                if (!match(',')) {
	                    break;
	                }

	                lex();
	                expr = parseSpreadOrAssignmentExpression();
	                expressions.push(expr);

	                if (expr.type === Syntax.SpreadElement) {
	                    spreadFound = true;
	                    if (!match(')')) {
	                        throwError({}, Messages.ElementAfterSpreadElement);
	                    }
	                    break;
	                }
	            }

	            sequence = markerApply(marker, delegate.createSequenceExpression(expressions));
	        }

	        if (spreadFound && lookahead2().value !== '=>') {
	            throwError({}, Messages.IllegalSpread);
	        }

	        return sequence || expr;
	    }

	    // 12.1 Block

	    function parseStatementList() {
	        var list = [],
	            statement;

	        while (index < length) {
	            if (match('}')) {
	                break;
	            }
	            statement = parseSourceElement();
	            if (typeof statement === 'undefined') {
	                break;
	            }
	            list.push(statement);
	        }

	        return list;
	    }

	    function parseBlock() {
	        var block, marker = markerCreate();

	        expect('{');

	        block = parseStatementList();

	        expect('}');

	        return markerApply(marker, delegate.createBlockStatement(block));
	    }

	    // 12.2 Variable Statement

	    function parseVariableIdentifier() {
	        var marker = markerCreate(),
	            token = lex();

	        if (token.type !== Token.Identifier) {
	            throwUnexpected(token);
	        }

	        return markerApply(marker, delegate.createIdentifier(token.value));
	    }

	    function parseVariableDeclaration(kind) {
	        var id,
	            marker = markerCreate(),
	            init = null;
	        if (match('{')) {
	            id = parseObjectInitialiser();
	            reinterpretAsAssignmentBindingPattern(id);
	        } else if (match('[')) {
	            id = parseArrayInitialiser();
	            reinterpretAsAssignmentBindingPattern(id);
	        } else {
	            /* istanbul ignore next */
	            id = state.allowKeyword ? parseNonComputedProperty() : parseVariableIdentifier();
	            // 12.2.1
	            if (strict && isRestrictedWord(id.name)) {
	                throwErrorTolerant({}, Messages.StrictVarName);
	            }
	        }

	        if (kind === 'const') {
	            if (!match('=')) {
	                throwError({}, Messages.NoUninitializedConst);
	            }
	            expect('=');
	            init = parseAssignmentExpression();
	        } else if (match('=')) {
	            lex();
	            init = parseAssignmentExpression();
	        }

	        return markerApply(marker, delegate.createVariableDeclarator(id, init));
	    }

	    function parseVariableDeclarationList(kind) {
	        var list = [];

	        do {
	            list.push(parseVariableDeclaration(kind));
	            if (!match(',')) {
	                break;
	            }
	            lex();
	        } while (index < length);

	        return list;
	    }

	    function parseVariableStatement() {
	        var declarations, marker = markerCreate();

	        expectKeyword('var');

	        declarations = parseVariableDeclarationList();

	        consumeSemicolon();

	        return markerApply(marker, delegate.createVariableDeclaration(declarations, 'var'));
	    }

	    // kind may be `const` or `let`
	    // Both are experimental and not in the specification yet.
	    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
	    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
	    function parseConstLetDeclaration(kind) {
	        var declarations, marker = markerCreate();

	        expectKeyword(kind);

	        declarations = parseVariableDeclarationList(kind);

	        consumeSemicolon();

	        return markerApply(marker, delegate.createVariableDeclaration(declarations, kind));
	    }

	    // people.mozilla.org/~jorendorff/es6-draft.html

	    function parseModuleSpecifier() {
	        var marker = markerCreate(),
	            specifier;

	        if (lookahead.type !== Token.StringLiteral) {
	            throwError({}, Messages.InvalidModuleSpecifier);
	        }
	        specifier = delegate.createLiteral(lex());
	        return markerApply(marker, specifier);
	    }

	    function parseExportBatchSpecifier() {
	        var marker = markerCreate();
	        expect('*');
	        return markerApply(marker, delegate.createExportBatchSpecifier());
	    }

	    function parseExportSpecifier() {
	        var id, name = null, marker = markerCreate();
	        if (matchKeyword('default')) {
	            lex();
	            id = markerApply(marker, delegate.createIdentifier('default'));
	            // export {default} from "something";
	        } else {
	            id = parseVariableIdentifier();
	        }
	        if (matchContextualKeyword('as')) {
	            lex();
	            name = parseNonComputedProperty();
	        }

	        return markerApply(marker, delegate.createExportSpecifier(id, name));
	    }

	    function parseExportDeclaration() {
	        var declaration = null,
	            possibleIdentifierToken, sourceElement,
	            isExportFromIdentifier,
	            src = null, specifiers = [],
	            marker = markerCreate();

	        expectKeyword('export');

	        if (matchKeyword('default')) {
	            // covers:
	            // export default ...
	            lex();
	            if (matchKeyword('function') || matchKeyword('class')) {
	                possibleIdentifierToken = lookahead2();
	                if (isIdentifierName(possibleIdentifierToken)) {
	                    // covers:
	                    // export default function foo () {}
	                    // export default class foo {}
	                    sourceElement = parseSourceElement();
	                    return markerApply(marker, delegate.createExportDeclaration(true, sourceElement, [sourceElement.id], null));
	                }
	                // covers:
	                // export default function () {}
	                // export default class {}
	                switch (lookahead.value) {
	                case 'class':
	                    return markerApply(marker, delegate.createExportDeclaration(true, parseClassExpression(), [], null));
	                case 'function':
	                    return markerApply(marker, delegate.createExportDeclaration(true, parseFunctionExpression(), [], null));
	                }
	            }

	            if (matchContextualKeyword('from')) {
	                throwError({}, Messages.UnexpectedToken, lookahead.value);
	            }

	            // covers:
	            // export default {};
	            // export default [];
	            if (match('{')) {
	                declaration = parseObjectInitialiser();
	            } else if (match('[')) {
	                declaration = parseArrayInitialiser();
	            } else {
	                declaration = parseAssignmentExpression();
	            }
	            consumeSemicolon();
	            return markerApply(marker, delegate.createExportDeclaration(true, declaration, [], null));
	        }

	        // non-default export
	        if (lookahead.type === Token.Keyword) {
	            // covers:
	            // export var f = 1;
	            switch (lookahead.value) {
	            case 'let':
	            case 'const':
	            case 'var':
	            case 'class':
	            case 'function':
	                return markerApply(marker, delegate.createExportDeclaration(false, parseSourceElement(), specifiers, null));
	            }
	        }

	        if (match('*')) {
	            // covers:
	            // export * from "foo";
	            specifiers.push(parseExportBatchSpecifier());

	            if (!matchContextualKeyword('from')) {
	                throwError({}, lookahead.value ?
	                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	            }
	            lex();
	            src = parseModuleSpecifier();
	            consumeSemicolon();

	            return markerApply(marker, delegate.createExportDeclaration(false, null, specifiers, src));
	        }

	        expect('{');
	        if (!match('}')) {
	            do {
	                isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
	                specifiers.push(parseExportSpecifier());
	            } while (match(',') && lex());
	        }
	        expect('}');

	        if (matchContextualKeyword('from')) {
	            // covering:
	            // export {default} from "foo";
	            // export {foo} from "foo";
	            lex();
	            src = parseModuleSpecifier();
	            consumeSemicolon();
	        } else if (isExportFromIdentifier) {
	            // covering:
	            // export {default}; // missing fromClause
	            throwError({}, lookahead.value ?
	                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	        } else {
	            // cover
	            // export {foo};
	            consumeSemicolon();
	        }
	        return markerApply(marker, delegate.createExportDeclaration(false, declaration, specifiers, src));
	    }


	    function parseImportSpecifier() {
	        // import {<foo as bar>} ...;
	        var id, name = null, marker = markerCreate();

	        id = parseNonComputedProperty();
	        if (matchContextualKeyword('as')) {
	            lex();
	            name = parseVariableIdentifier();
	        }

	        return markerApply(marker, delegate.createImportSpecifier(id, name));
	    }

	    function parseNamedImports() {
	        var specifiers = [];
	        // {foo, bar as bas}
	        expect('{');
	        if (!match('}')) {
	            do {
	                specifiers.push(parseImportSpecifier());
	            } while (match(',') && lex());
	        }
	        expect('}');
	        return specifiers;
	    }

	    function parseImportDefaultSpecifier() {
	        // import <foo> ...;
	        var id, marker = markerCreate();

	        id = parseNonComputedProperty();

	        return markerApply(marker, delegate.createImportDefaultSpecifier(id));
	    }

	    function parseImportNamespaceSpecifier() {
	        // import <* as foo> ...;
	        var id, marker = markerCreate();

	        expect('*');
	        if (!matchContextualKeyword('as')) {
	            throwError({}, Messages.NoAsAfterImportNamespace);
	        }
	        lex();
	        id = parseNonComputedProperty();

	        return markerApply(marker, delegate.createImportNamespaceSpecifier(id));
	    }

	    function parseImportDeclaration() {
	        var specifiers, src, marker = markerCreate();

	        expectKeyword('import');
	        specifiers = [];

	        if (lookahead.type === Token.StringLiteral) {
	            // covers:
	            // import "foo";
	            src = parseModuleSpecifier();
	            consumeSemicolon();
	            return markerApply(marker, delegate.createImportDeclaration(specifiers, src));
	        }

	        if (!matchKeyword('default') && isIdentifierName(lookahead)) {
	            // covers:
	            // import foo
	            // import foo, ...
	            specifiers.push(parseImportDefaultSpecifier());
	            if (match(',')) {
	                lex();
	            }
	        }
	        if (match('*')) {
	            // covers:
	            // import foo, * as foo
	            // import * as foo
	            specifiers.push(parseImportNamespaceSpecifier());
	        } else if (match('{')) {
	            // covers:
	            // import foo, {bar}
	            // import {bar}
	            specifiers = specifiers.concat(parseNamedImports());
	        }

	        if (!matchContextualKeyword('from')) {
	            throwError({}, lookahead.value ?
	                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	        }
	        lex();
	        src = parseModuleSpecifier();
	        consumeSemicolon();

	        return markerApply(marker, delegate.createImportDeclaration(specifiers, src));
	    }

	    // 12.3 Empty Statement

	    function parseEmptyStatement() {
	        var marker = markerCreate();
	        expect(';');
	        return markerApply(marker, delegate.createEmptyStatement());
	    }

	    // 12.4 Expression Statement

	    function parseExpressionStatement() {
	        var marker = markerCreate(), expr = parseExpression();
	        consumeSemicolon();
	        return markerApply(marker, delegate.createExpressionStatement(expr));
	    }

	    // 12.5 If statement

	    function parseIfStatement() {
	        var test, consequent, alternate, marker = markerCreate();

	        expectKeyword('if');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        consequent = parseStatement();

	        if (matchKeyword('else')) {
	            lex();
	            alternate = parseStatement();
	        } else {
	            alternate = null;
	        }

	        return markerApply(marker, delegate.createIfStatement(test, consequent, alternate));
	    }

	    // 12.6 Iteration Statements

	    function parseDoWhileStatement() {
	        var body, test, oldInIteration, marker = markerCreate();

	        expectKeyword('do');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        expectKeyword('while');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        if (match(';')) {
	            lex();
	        }

	        return markerApply(marker, delegate.createDoWhileStatement(body, test));
	    }

	    function parseWhileStatement() {
	        var test, body, oldInIteration, marker = markerCreate();

	        expectKeyword('while');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        return markerApply(marker, delegate.createWhileStatement(test, body));
	    }

	    function parseForVariableDeclaration() {
	        var marker = markerCreate(),
	            token = lex(),
	            declarations = parseVariableDeclarationList();

	        return markerApply(marker, delegate.createVariableDeclaration(declarations, token.value));
	    }

	    function parseForStatement(opts) {
	        var init, test, update, left, right, body, operator, oldInIteration,
	            marker = markerCreate();
	        init = test = update = null;
	        expectKeyword('for');

	        // http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators&s=each
	        if (matchContextualKeyword('each')) {
	            throwError({}, Messages.EachNotAllowed);
	        }

	        expect('(');

	        if (match(';')) {
	            lex();
	        } else {
	            if (matchKeyword('var') || matchKeyword('let') || matchKeyword('const')) {
	                state.allowIn = false;
	                init = parseForVariableDeclaration();
	                state.allowIn = true;

	                if (init.declarations.length === 1) {
	                    if (matchKeyword('in') || matchContextualKeyword('of')) {
	                        operator = lookahead;
	                        if (!((operator.value === 'in' || init.kind !== 'var') && init.declarations[0].init)) {
	                            lex();
	                            left = init;
	                            right = parseExpression();
	                            init = null;
	                        }
	                    }
	                }
	            } else {
	                state.allowIn = false;
	                init = parseExpression();
	                state.allowIn = true;

	                if (matchContextualKeyword('of')) {
	                    operator = lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else if (matchKeyword('in')) {
	                    // LeftHandSideExpression
	                    if (!isAssignableLeftHandSide(init)) {
	                        throwError({}, Messages.InvalidLHSInForIn);
	                    }
	                    operator = lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                }
	            }

	            if (typeof left === 'undefined') {
	                expect(';');
	            }
	        }

	        if (typeof left === 'undefined') {

	            if (!match(';')) {
	                test = parseExpression();
	            }
	            expect(';');

	            if (!match(')')) {
	                update = parseExpression();
	            }
	        }

	        expect(')');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        if (!(opts !== undefined && opts.ignoreBody)) {
	            body = parseStatement();
	        }

	        state.inIteration = oldInIteration;

	        if (typeof left === 'undefined') {
	            return markerApply(marker, delegate.createForStatement(init, test, update, body));
	        }

	        if (operator.value === 'in') {
	            return markerApply(marker, delegate.createForInStatement(left, right, body));
	        }
	        return markerApply(marker, delegate.createForOfStatement(left, right, body));
	    }

	    // 12.7 The continue statement

	    function parseContinueStatement() {
	        var label = null, marker = markerCreate();

	        expectKeyword('continue');

	        // Optimize the most common form: 'continue;'.
	        if (source.charCodeAt(index) === 59) {
	            lex();

	            if (!state.inIteration) {
	                throwError({}, Messages.IllegalContinue);
	            }

	            return markerApply(marker, delegate.createContinueStatement(null));
	        }

	        if (peekLineTerminator()) {
	            if (!state.inIteration) {
	                throwError({}, Messages.IllegalContinue);
	            }

	            return markerApply(marker, delegate.createContinueStatement(null));
	        }

	        if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();

	            if (!state.labelSet.has(label.name)) {
	                throwError({}, Messages.UnknownLabel, label.name);
	            }
	        }

	        consumeSemicolon();

	        if (label === null && !state.inIteration) {
	            throwError({}, Messages.IllegalContinue);
	        }

	        return markerApply(marker, delegate.createContinueStatement(label));
	    }

	    // 12.8 The break statement

	    function parseBreakStatement() {
	        var label = null, marker = markerCreate();

	        expectKeyword('break');

	        // Catch the very common case first: immediately a semicolon (char #59).
	        if (source.charCodeAt(index) === 59) {
	            lex();

	            if (!(state.inIteration || state.inSwitch)) {
	                throwError({}, Messages.IllegalBreak);
	            }

	            return markerApply(marker, delegate.createBreakStatement(null));
	        }

	        if (peekLineTerminator()) {
	            if (!(state.inIteration || state.inSwitch)) {
	                throwError({}, Messages.IllegalBreak);
	            }

	            return markerApply(marker, delegate.createBreakStatement(null));
	        }

	        if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();

	            if (!state.labelSet.has(label.name)) {
	                throwError({}, Messages.UnknownLabel, label.name);
	            }
	        }

	        consumeSemicolon();

	        if (label === null && !(state.inIteration || state.inSwitch)) {
	            throwError({}, Messages.IllegalBreak);
	        }

	        return markerApply(marker, delegate.createBreakStatement(label));
	    }

	    // 12.9 The return statement

	    function parseReturnStatement() {
	        var argument = null, marker = markerCreate();

	        expectKeyword('return');

	        if (!state.inFunctionBody) {
	            throwErrorTolerant({}, Messages.IllegalReturn);
	        }

	        // 'return' followed by a space and an identifier is very common.
	        if (source.charCodeAt(index) === 32) {
	            if (isIdentifierStart(source.charCodeAt(index + 1))) {
	                argument = parseExpression();
	                consumeSemicolon();
	                return markerApply(marker, delegate.createReturnStatement(argument));
	            }
	        }

	        if (peekLineTerminator()) {
	            return markerApply(marker, delegate.createReturnStatement(null));
	        }

	        if (!match(';')) {
	            if (!match('}') && lookahead.type !== Token.EOF) {
	                argument = parseExpression();
	            }
	        }

	        consumeSemicolon();

	        return markerApply(marker, delegate.createReturnStatement(argument));
	    }

	    // 12.10 The with statement

	    function parseWithStatement() {
	        var object, body, marker = markerCreate();

	        if (strict) {
	            throwErrorTolerant({}, Messages.StrictModeWith);
	        }

	        expectKeyword('with');

	        expect('(');

	        object = parseExpression();

	        expect(')');

	        body = parseStatement();

	        return markerApply(marker, delegate.createWithStatement(object, body));
	    }

	    // 12.10 The swith statement

	    function parseSwitchCase() {
	        var test,
	            consequent = [],
	            sourceElement,
	            marker = markerCreate();

	        if (matchKeyword('default')) {
	            lex();
	            test = null;
	        } else {
	            expectKeyword('case');
	            test = parseExpression();
	        }
	        expect(':');

	        while (index < length) {
	            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
	                break;
	            }
	            sourceElement = parseSourceElement();
	            if (typeof sourceElement === 'undefined') {
	                break;
	            }
	            consequent.push(sourceElement);
	        }

	        return markerApply(marker, delegate.createSwitchCase(test, consequent));
	    }

	    function parseSwitchStatement() {
	        var discriminant, cases, clause, oldInSwitch, defaultFound, marker = markerCreate();

	        expectKeyword('switch');

	        expect('(');

	        discriminant = parseExpression();

	        expect(')');

	        expect('{');

	        cases = [];

	        if (match('}')) {
	            lex();
	            return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));
	        }

	        oldInSwitch = state.inSwitch;
	        state.inSwitch = true;
	        defaultFound = false;

	        while (index < length) {
	            if (match('}')) {
	                break;
	            }
	            clause = parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    throwError({}, Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }

	        state.inSwitch = oldInSwitch;

	        expect('}');

	        return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));
	    }

	    // 12.13 The throw statement

	    function parseThrowStatement() {
	        var argument, marker = markerCreate();

	        expectKeyword('throw');

	        if (peekLineTerminator()) {
	            throwError({}, Messages.NewlineAfterThrow);
	        }

	        argument = parseExpression();

	        consumeSemicolon();

	        return markerApply(marker, delegate.createThrowStatement(argument));
	    }

	    // 12.14 The try statement

	    function parseCatchClause() {
	        var param, body, marker = markerCreate();

	        expectKeyword('catch');

	        expect('(');
	        if (match(')')) {
	            throwUnexpected(lookahead);
	        }

	        param = parseExpression();
	        // 12.14.1
	        if (strict && param.type === Syntax.Identifier && isRestrictedWord(param.name)) {
	            throwErrorTolerant({}, Messages.StrictCatchVariable);
	        }

	        expect(')');
	        body = parseBlock();
	        return markerApply(marker, delegate.createCatchClause(param, body));
	    }

	    function parseTryStatement() {
	        var block, handlers = [], finalizer = null, marker = markerCreate();

	        expectKeyword('try');

	        block = parseBlock();

	        if (matchKeyword('catch')) {
	            handlers.push(parseCatchClause());
	        }

	        if (matchKeyword('finally')) {
	            lex();
	            finalizer = parseBlock();
	        }

	        if (handlers.length === 0 && !finalizer) {
	            throwError({}, Messages.NoCatchOrFinally);
	        }

	        return markerApply(marker, delegate.createTryStatement(block, [], handlers, finalizer));
	    }

	    // 12.15 The debugger statement

	    function parseDebuggerStatement() {
	        var marker = markerCreate();
	        expectKeyword('debugger');

	        consumeSemicolon();

	        return markerApply(marker, delegate.createDebuggerStatement());
	    }

	    // 12 Statements

	    function parseStatement() {
	        var type = lookahead.type,
	            marker,
	            expr,
	            labeledBody;

	        if (type === Token.EOF) {
	            throwUnexpected(lookahead);
	        }

	        if (type === Token.Punctuator) {
	            switch (lookahead.value) {
	            case ';':
	                return parseEmptyStatement();
	            case '{':
	                return parseBlock();
	            case '(':
	                return parseExpressionStatement();
	            default:
	                break;
	            }
	        }

	        if (type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'break':
	                return parseBreakStatement();
	            case 'continue':
	                return parseContinueStatement();
	            case 'debugger':
	                return parseDebuggerStatement();
	            case 'do':
	                return parseDoWhileStatement();
	            case 'for':
	                return parseForStatement();
	            case 'function':
	                return parseFunctionDeclaration();
	            case 'class':
	                return parseClassDeclaration();
	            case 'if':
	                return parseIfStatement();
	            case 'return':
	                return parseReturnStatement();
	            case 'switch':
	                return parseSwitchStatement();
	            case 'throw':
	                return parseThrowStatement();
	            case 'try':
	                return parseTryStatement();
	            case 'var':
	                return parseVariableStatement();
	            case 'while':
	                return parseWhileStatement();
	            case 'with':
	                return parseWithStatement();
	            default:
	                break;
	            }
	        }

	        marker = markerCreate();
	        expr = parseExpression();

	        // 12.12 Labelled Statements
	        if ((expr.type === Syntax.Identifier) && match(':')) {
	            lex();

	            if (state.labelSet.has(expr.name)) {
	                throwError({}, Messages.Redeclaration, 'Label', expr.name);
	            }

	            state.labelSet.set(expr.name, true);
	            labeledBody = parseStatement();
	            state.labelSet.delete(expr.name);
	            return markerApply(marker, delegate.createLabeledStatement(expr, labeledBody));
	        }

	        consumeSemicolon();

	        return markerApply(marker, delegate.createExpressionStatement(expr));
	    }

	    // 13 Function Definition

	    function parseConciseBody() {
	        if (match('{')) {
	            return parseFunctionSourceElements();
	        }
	        return parseAssignmentExpression();
	    }

	    function parseFunctionSourceElements() {
	        var sourceElement, sourceElements = [], token, directive, firstRestricted,
	            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesizedCount,
	            marker = markerCreate();

	        expect('{');

	        while (index < length) {
	            if (lookahead.type !== Token.StringLiteral) {
	                break;
	            }
	            token = lookahead;

	            sourceElement = parseSourceElement();
	            sourceElements.push(sourceElement);
	            if (sourceElement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.range[0] + 1, token.range[1] - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }

	        oldLabelSet = state.labelSet;
	        oldInIteration = state.inIteration;
	        oldInSwitch = state.inSwitch;
	        oldInFunctionBody = state.inFunctionBody;
	        oldParenthesizedCount = state.parenthesizedCount;

	        state.labelSet = new StringMap();
	        state.inIteration = false;
	        state.inSwitch = false;
	        state.inFunctionBody = true;
	        state.parenthesizedCount = 0;

	        while (index < length) {
	            if (match('}')) {
	                break;
	            }
	            sourceElement = parseSourceElement();
	            if (typeof sourceElement === 'undefined') {
	                break;
	            }
	            sourceElements.push(sourceElement);
	        }

	        expect('}');

	        state.labelSet = oldLabelSet;
	        state.inIteration = oldInIteration;
	        state.inSwitch = oldInSwitch;
	        state.inFunctionBody = oldInFunctionBody;
	        state.parenthesizedCount = oldParenthesizedCount;

	        return markerApply(marker, delegate.createBlockStatement(sourceElements));
	    }

	    function validateParam(options, param, name) {
	        if (strict) {
	            if (isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamName;
	            }
	            if (options.paramSet.has(name)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamDupe;
	            }
	        } else if (!options.firstRestricted) {
	            if (isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictParamName;
	            } else if (isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictReservedWord;
	            } else if (options.paramSet.has(name)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictParamDupe;
	            }
	        }
	        options.paramSet.set(name, true);
	    }

	    function parseParam(options) {
	        var token, rest, param, def;

	        token = lookahead;
	        if (token.value === '...') {
	            token = lex();
	            rest = true;
	        }

	        if (match('[')) {
	            param = parseArrayInitialiser();
	            reinterpretAsDestructuredParameter(options, param);
	        } else if (match('{')) {
	            if (rest) {
	                throwError({}, Messages.ObjectPatternAsRestParameter);
	            }
	            param = parseObjectInitialiser();
	            reinterpretAsDestructuredParameter(options, param);
	        } else {
	            param = parseVariableIdentifier();
	            validateParam(options, token, token.value);
	        }

	        if (match('=')) {
	            if (rest) {
	                throwErrorTolerant(lookahead, Messages.DefaultRestParameter);
	            }
	            lex();
	            def = parseAssignmentExpression();
	            ++options.defaultCount;
	        }

	        if (rest) {
	            if (!match(')')) {
	                throwError({}, Messages.ParameterAfterRestParameter);
	            }
	            options.rest = param;
	            return false;
	        }

	        options.params.push(param);
	        options.defaults.push(def);
	        return !match(')');
	    }

	    function parseParams(firstRestricted) {
	        var options, marker = markerCreate();

	        options = {
	            params: [],
	            defaultCount: 0,
	            defaults: [],
	            rest: null,
	            firstRestricted: firstRestricted
	        };

	        expect('(');

	        if (!match(')')) {
	            options.paramSet = new StringMap();
	            while (index < length) {
	                if (!parseParam(options)) {
	                    break;
	                }
	                expect(',');
	            }
	        }

	        expect(')');

	        if (options.defaultCount === 0) {
	            options.defaults = [];
	        }

	        return markerApply(marker, options);
	    }

	    function parseFunctionDeclaration() {
	        var id, body, token, tmp, firstRestricted, message, previousStrict, previousYieldAllowed, generator,
	            marker = markerCreate();

	        expectKeyword('function');

	        generator = false;
	        if (match('*')) {
	            lex();
	            generator = true;
	        }

	        token = lookahead;

	        id = parseVariableIdentifier();

	        if (strict) {
	            if (isRestrictedWord(token.value)) {
	                throwErrorTolerant(token, Messages.StrictFunctionName);
	            }
	        } else {
	            if (isRestrictedWord(token.value)) {
	                firstRestricted = token;
	                message = Messages.StrictFunctionName;
	            } else if (isStrictModeReservedWord(token.value)) {
	                firstRestricted = token;
	                message = Messages.StrictReservedWord;
	            }
	        }

	        tmp = parseParams(firstRestricted);
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }

	        previousStrict = strict;
	        previousYieldAllowed = state.yieldAllowed;
	        state.yieldAllowed = generator;

	        body = parseFunctionSourceElements();

	        if (strict && firstRestricted) {
	            throwError(firstRestricted, message);
	        }
	        if (strict && tmp.stricted) {
	            throwErrorTolerant(tmp.stricted, message);
	        }
	        strict = previousStrict;
	        state.yieldAllowed = previousYieldAllowed;

	        return markerApply(marker, delegate.createFunctionDeclaration(id, tmp.params, tmp.defaults, body, tmp.rest, generator, false));
	    }

	    function parseFunctionExpression() {
	        var token, id = null, firstRestricted, message, tmp, body, previousStrict, previousYieldAllowed, generator,
	            marker = markerCreate();

	        expectKeyword('function');

	        generator = false;

	        if (match('*')) {
	            lex();
	            generator = true;
	        }

	        if (!match('(')) {
	            token = lookahead;
	            id = parseVariableIdentifier();
	            if (strict) {
	                if (isRestrictedWord(token.value)) {
	                    throwErrorTolerant(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }

	        tmp = parseParams(firstRestricted);
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }

	        previousStrict = strict;
	        previousYieldAllowed = state.yieldAllowed;
	        state.yieldAllowed = generator;

	        body = parseFunctionSourceElements();

	        if (strict && firstRestricted) {
	            throwError(firstRestricted, message);
	        }
	        if (strict && tmp.stricted) {
	            throwErrorTolerant(tmp.stricted, message);
	        }
	        strict = previousStrict;
	        state.yieldAllowed = previousYieldAllowed;

	        return markerApply(marker, delegate.createFunctionExpression(id, tmp.params, tmp.defaults, body, tmp.rest, generator, false));
	    }

	    function parseYieldExpression() {
	        var yieldToken, delegateFlag, expr, marker = markerCreate();

	        yieldToken = lex();
	        assert(yieldToken.value === 'yield', 'Called parseYieldExpression with non-yield lookahead.');

	        if (!state.yieldAllowed) {
	            throwErrorTolerant({}, Messages.IllegalYield);
	        }

	        delegateFlag = false;
	        if (match('*')) {
	            lex();
	            delegateFlag = true;
	        }

	        expr = parseAssignmentExpression();

	        return markerApply(marker, delegate.createYieldExpression(expr, delegateFlag));
	    }

	    // 14 Functions and classes

	    // 14.1 Functions is defined above (13 in ES5)
	    // 14.2 Arrow Functions Definitions is defined in (7.3 assignments)

	    // 14.3 Method Definitions
	    // 14.3.7
	    function specialMethod(methodDefinition) {
	        return methodDefinition.kind === 'get' ||
	            methodDefinition.kind === 'set' ||
	            methodDefinition.value.generator;
	    }

	    function parseMethodDefinition() {
	        var token, key, param, propType, computed,
	            marker = markerCreate();

	        if (lookahead.value === 'static') {
	            propType = ClassPropertyType.static;
	            lex();
	        } else {
	            propType = ClassPropertyType.prototype;
	        }

	        if (match('*')) {
	            lex();
	            computed = (lookahead.value === '[');
	            return markerApply(marker, delegate.createMethodDefinition(
	                propType,
	                '',
	                parseObjectPropertyKey(),
	                parsePropertyMethodFunction({ generator: true }),
	                computed
	            ));
	        }

	        token = lookahead;
	        key = parseObjectPropertyKey();

	        if (token.value === 'get' && !match('(')) {
	            computed = (lookahead.value === '[');
	            key = parseObjectPropertyKey();

	            expect('(');
	            expect(')');
	            return markerApply(marker, delegate.createMethodDefinition(
	                propType,
	                'get',
	                key,
	                parsePropertyFunction({ generator: false }),
	                computed
	            ));
	        }
	        if (token.value === 'set' && !match('(')) {
	            computed = (lookahead.value === '[');
	            key = parseObjectPropertyKey();

	            expect('(');
	            token = lookahead;
	            param = [ parseVariableIdentifier() ];
	            expect(')');
	            return markerApply(marker, delegate.createMethodDefinition(
	                propType,
	                'set',
	                key,
	                parsePropertyFunction({ params: param, generator: false, name: token }),
	                computed
	            ));
	        }

	        computed = (token.value === '[');

	        return markerApply(marker, delegate.createMethodDefinition(
	            propType,
	            '',
	            key,
	            parsePropertyMethodFunction({ generator: false }),
	            computed
	        ));
	    }

	    // 14.5 Class Definitions

	    function parseClassElement() {
	        if (match(';')) {
	            lex();
	        } else {
	            return parseMethodDefinition();
	        }
	    }

	    function parseClassBody() {
	        var classElement, classElements = [], existingProps = {},
	            marker = markerCreate(), propName, propType;

	        existingProps[ClassPropertyType.static] = new StringMap();
	        existingProps[ClassPropertyType.prototype] = new StringMap();

	        expect('{');

	        while (index < length) {
	            if (match('}')) {
	                break;
	            }
	            classElement = parseClassElement(existingProps);

	            if (typeof classElement !== 'undefined') {
	                classElements.push(classElement);

	                propName = !classElement.computed && getFieldName(classElement.key);
	                if (propName !== false) {
	                    propType = classElement.static ?
	                                ClassPropertyType.static :
	                                ClassPropertyType.prototype;

	                    if (propName === 'constructor' && !classElement.static) {
	                        if (specialMethod(classElement)) {
	                            throwError(classElement, Messages.IllegalClassConstructorProperty);
	                        }
	                        if (existingProps[ClassPropertyType.prototype].has('constructor')) {
	                            throwError(classElement.key, Messages.IllegalDuplicateClassProperty);
	                        }
	                    }
	                    existingProps[propType].set(propName, true);
	                }
	            }
	        }

	        expect('}');

	        return markerApply(marker, delegate.createClassBody(classElements));
	    }

	    function parseClassExpression() {
	        var id, previousYieldAllowed, superClass = null, marker = markerCreate();

	        expectKeyword('class');

	        if (!matchKeyword('extends') && !match('{')) {
	            id = parseVariableIdentifier();
	        }

	        if (matchKeyword('extends')) {
	            expectKeyword('extends');
	            previousYieldAllowed = state.yieldAllowed;
	            state.yieldAllowed = false;
	            superClass = parseAssignmentExpression();
	            state.yieldAllowed = previousYieldAllowed;
	        }

	        return markerApply(marker, delegate.createClassExpression(id, superClass, parseClassBody()));
	    }

	    function parseClassDeclaration() {
	        var id, previousYieldAllowed, superClass = null, marker = markerCreate();

	        expectKeyword('class');

	        id = parseVariableIdentifier();

	        if (matchKeyword('extends')) {
	            expectKeyword('extends');
	            previousYieldAllowed = state.yieldAllowed;
	            state.yieldAllowed = false;
	            superClass = parseAssignmentExpression();
	            state.yieldAllowed = previousYieldAllowed;
	        }

	        return markerApply(marker, delegate.createClassDeclaration(id, superClass, parseClassBody()));
	    }

	    // 15 Program

	    function parseSourceElement() {
	        if (lookahead.type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'const':
	            case 'let':
	                return parseConstLetDeclaration(lookahead.value);
	            case 'function':
	                return parseFunctionDeclaration();
	            case 'export':
	                throwErrorTolerant({}, Messages.IllegalExportDeclaration);
	                return parseExportDeclaration();
	            case 'import':
	                throwErrorTolerant({}, Messages.IllegalImportDeclaration);
	                return parseImportDeclaration();
	            default:
	                return parseStatement();
	            }
	        }

	        if (lookahead.type !== Token.EOF) {
	            return parseStatement();
	        }
	    }

	    function parseProgramElement() {
	        if (extra.isModule && lookahead.type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'export':
	                return parseExportDeclaration();
	            case 'import':
	                return parseImportDeclaration();
	            }
	        }

	        return parseSourceElement();
	    }

	    function parseProgramElements() {
	        var sourceElement, sourceElements = [], token, directive, firstRestricted;

	        while (index < length) {
	            token = lookahead;
	            if (token.type !== Token.StringLiteral) {
	                break;
	            }

	            sourceElement = parseProgramElement();
	            sourceElements.push(sourceElement);
	            if (sourceElement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.range[0] + 1, token.range[1] - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }

	        while (index < length) {
	            sourceElement = parseProgramElement();
	            if (typeof sourceElement === 'undefined') {
	                break;
	            }
	            sourceElements.push(sourceElement);
	        }
	        return sourceElements;
	    }

	    function parseProgram() {
	        var body, marker = markerCreate();
	        strict = !!extra.isModule;
	        peek();
	        body = parseProgramElements();
	        return markerApply(marker, delegate.createProgram(body));
	    }

	    function collectToken() {
	        var loc, token, range, value, entry;

	        skipComment();
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };

	        token = extra.advance();
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };

	        if (token.type !== Token.EOF) {
	            range = [token.range[0], token.range[1]];
	            value = source.slice(token.range[0], token.range[1]);
	            entry = {
	                type: TokenName[token.type],
	                value: value,
	                range: range,
	                loc: loc
	            };
	            if (token.regex) {
	                entry.regex = {
	                    pattern: token.regex.pattern,
	                    flags: token.regex.flags
	                };
	            }
	            extra.tokens.push(entry);
	        }

	        return token;
	    }

	    function collectRegex() {
	        var pos, loc, regex, token;

	        skipComment();

	        pos = index;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };

	        regex = extra.scanRegExp();
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };

	        if (!extra.tokenize) {
	            /* istanbul ignore next */
	            // Pop the previous token, which is likely '/' or '/='
	            if (extra.tokens.length > 0) {
	                token = extra.tokens[extra.tokens.length - 1];
	                if (token.range[0] === pos && token.type === 'Punctuator') {
	                    if (token.value === '/' || token.value === '/=') {
	                        extra.tokens.pop();
	                    }
	                }
	            }

	            extra.tokens.push({
	                type: 'RegularExpression',
	                value: regex.literal,
	                regex: regex.regex,
	                range: [pos, index],
	                loc: loc
	            });
	        }

	        return regex;
	    }

	    function filterTokenLocation() {
	        var i, entry, token, tokens = [];

	        for (i = 0; i < extra.tokens.length; ++i) {
	            entry = extra.tokens[i];
	            token = {
	                type: entry.type,
	                value: entry.value
	            };
	            if (entry.regex) {
	                token.regex = {
	                    pattern: entry.regex.pattern,
	                    flags: entry.regex.flags
	                };
	            }
	            if (extra.range) {
	                token.range = entry.range;
	            }
	            if (extra.loc) {
	                token.loc = entry.loc;
	            }
	            tokens.push(token);
	        }

	        extra.tokens = tokens;
	    }

	    function patch() {
	        if (typeof extra.tokens !== 'undefined') {
	            extra.advance = advance;
	            extra.scanRegExp = scanRegExp;

	            advance = collectToken;
	            scanRegExp = collectRegex;
	        }
	    }

	    function unpatch() {
	        if (typeof extra.scanRegExp === 'function') {
	            advance = extra.advance;
	            scanRegExp = extra.scanRegExp;
	        }
	    }

	    // This is used to modify the delegate.

	    function extend(object, properties) {
	        var entry, result = {};

	        for (entry in object) {
	            /* istanbul ignore else */
	            if (object.hasOwnProperty(entry)) {
	                result[entry] = object[entry];
	            }
	        }

	        for (entry in properties) {
	            /* istanbul ignore else */
	            if (properties.hasOwnProperty(entry)) {
	                result[entry] = properties[entry];
	            }
	        }

	        return result;
	    }

	    function tokenize(code, options) {
	        var toString,
	            token,
	            tokens;

	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }

	        delegate = SyntaxTreeDelegate;
	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowKeyword: true,
	            allowIn: true,
	            labelSet: new StringMap(),
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1,
	            curlyStack: [],
	            curlyLastIndex: 0
	        };

	        extra = {};

	        // Options matching.
	        options = options || {};

	        // Of course we collect tokens here.
	        options.tokens = true;
	        extra.tokens = [];
	        extra.tokenize = true;
	        // The following two fields are necessary to compute the Regex tokens.
	        extra.openParenToken = -1;
	        extra.openCurlyToken = -1;

	        extra.range = (typeof options.range === 'boolean') && options.range;
	        extra.loc = (typeof options.loc === 'boolean') && options.loc;

	        if (typeof options.comment === 'boolean' && options.comment) {
	            extra.comments = [];
	        }
	        if (typeof options.tolerant === 'boolean' && options.tolerant) {
	            extra.errors = [];
	        }

	        patch();

	        try {
	            peek();
	            if (lookahead.type === Token.EOF) {
	                return extra.tokens;
	            }

	            token = lex();
	            while (lookahead.type !== Token.EOF) {
	                try {
	                    token = lex();
	                } catch (lexError) {
	                    token = lookahead;
	                    if (extra.errors) {
	                        extra.errors.push(lexError);
	                        // We have to break on the first error
	                        // to avoid infinite loops.
	                        break;
	                    } else {
	                        throw lexError;
	                    }
	                }
	            }

	            filterTokenLocation();
	            tokens = extra.tokens;
	            if (typeof extra.comments !== 'undefined') {
	                tokens.comments = extra.comments;
	            }
	            if (typeof extra.errors !== 'undefined') {
	                tokens.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            unpatch();
	            extra = {};
	        }
	        return tokens;
	    }

	    function parse(code, options) {
	        var program, toString;

	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }

	        delegate = SyntaxTreeDelegate;
	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowKeyword: false,
	            allowIn: true,
	            labelSet: new StringMap(),
	            parenthesizedCount: 0,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1,
	            yieldAllowed: false,
	            curlyPosition: 0,
	            curlyStack: [],
	            curlyLastIndex: 0
	        };

	        extra = {};
	        if (typeof options !== 'undefined') {
	            extra.range = (typeof options.range === 'boolean') && options.range;
	            extra.loc = (typeof options.loc === 'boolean') && options.loc;
	            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

	            if (extra.loc && options.source !== null && options.source !== undefined) {
	                delegate = extend(delegate, {
	                    'postProcess': function (node) {
	                        node.loc.source = toString(options.source);
	                        return node;
	                    }
	                });
	            }

	            if (options.sourceType === 'module') {
	                extra.isModule = true;
	            }
	            if (typeof options.tokens === 'boolean' && options.tokens) {
	                extra.tokens = [];
	            }
	            if (typeof options.comment === 'boolean' && options.comment) {
	                extra.comments = [];
	            }
	            if (typeof options.tolerant === 'boolean' && options.tolerant) {
	                extra.errors = [];
	            }
	            if (extra.attachComment) {
	                extra.range = true;
	                extra.comments = [];
	                extra.bottomRightStack = [];
	                extra.trailingComments = [];
	                extra.leadingComments = [];
	            }
	        }

	        patch();
	        try {
	            program = parseProgram();
	            if (typeof extra.comments !== 'undefined') {
	                program.comments = extra.comments;
	            }
	            if (typeof extra.tokens !== 'undefined') {
	                filterTokenLocation();
	                program.tokens = extra.tokens;
	            }
	            if (typeof extra.errors !== 'undefined') {
	                program.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            unpatch();
	            extra = {};
	        }

	        return program;
	    }

	    // Sync with *.json manifests.
	    exports.version = '1.1.0-bin';

	    exports.tokenize = tokenize;

	    exports.parse = parse;

	    // Deep copy.
	   /* istanbul ignore next */
	    exports.Syntax = (function () {
	        var name, types = {};

	        if (typeof Object.create === 'function') {
	            types = Object.create(null);
	        }

	        for (name in Syntax) {
	            if (Syntax.hasOwnProperty(name)) {
	                types[name] = Syntax[name];
	            }
	        }

	        if (typeof Object.freeze === 'function') {
	            Object.freeze(types);
	        }

	        return types;
	    }());

	}));
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(23);
	var chalk = __webpack_require__(28);
	var TokenAssert = __webpack_require__(37);

	/**
	 * Set of errors for specified file.
	 *
	 * @name Errors
	 * @param {JsFile} file
	 * @param {Boolean} verbose
	 */
	var Errors = function(file, verbose) {
	    this._errorList = [];
	    this._file = file;
	    this._currentRule = '';
	    this._verbose = verbose || false;

	    /**
	     * @type {TokenAssert}
	     * @public
	     */
	    this.assert = new TokenAssert(file);
	    this.assert.on('error', this._addError.bind(this));
	};

	Errors.prototype = {
	    /**
	     * Adds style error to the list
	     *
	     * @param {String} message
	     * @param {Number|Object} line
	     * @param {Number} [column] optional if line is an object
	     */
	    add: function(message, line, column) {
	        if (typeof line === 'object') {
	            column = line.column;
	            line = line.line;
	        }

	        // line and column numbers should be explicit
	        assert(typeof line === 'number' && line > 0,
	            'Unable to add an error, `line` should be a number greater than 0 but ' + line + ' given');
	        assert(typeof column === 'number' && column >= 0,
	            'Unable to add an error, `column` should be a positive number but ' + column + ' given');

	        this._addError({
	            message: message,
	            line: line,
	            column: column
	        });
	    },

	    /**
	     * Adds error to error list.
	     *
	     * @param {Object} errorInfo
	     * @private
	     */
	    _addError: function(errorInfo) {
	        if (!this._file.isEnabledRule(this._currentRule, errorInfo.line)) {
	            return;
	        }

	        this._errorList.push({
	            filename: this._file.getFilename(),
	            rule: this._currentRule,
	            message: this._prepareMessage(errorInfo),
	            line: errorInfo.line,
	            column: errorInfo.column,
	            fixed: errorInfo.fixed
	        });
	    },

	    /**
	     * Prepare error message.
	     *
	     * @param {Object} errorInfo
	     * @private
	     */
	    _prepareMessage: function(errorInfo) {
	        if (this._verbose && this._currentRule) {
	            return this._currentRule + ': ' + errorInfo.message;
	        }

	        return errorInfo.message;
	    },

	    /**
	     * Returns style error list.
	     *
	     * @returns {Object[]}
	     */
	    getErrorList: function() {
	        return this._errorList;
	    },

	    /**
	     * Returns filename of file this error list is for.
	     *
	     * @returns {String}
	     */
	    getFilename: function() {
	        return this._file.getFilename();
	    },

	    /**
	     * Returns true if no errors are added.
	     *
	     * @returns {Boolean}
	     */
	    isEmpty: function() {
	        return this._errorList.length === 0;
	    },

	    /**
	     * Returns amount of errors added by the rules.
	     *
	     * @returns {Number}
	     */
	    getErrorCount: function() {
	        return this._errorList.length;
	    },

	    /**
	     * Strips error list to the specified length.
	     *
	     * @param {Number} length
	     */
	    stripErrorList: function(length) {
	        this._errorList.splice(length);
	    },

	    /**
	     * Filters out errors based on the supplied filter function
	     *
	     * @param {Function} filter
	     */
	    filter: function(filter) {
	        this._errorList = this._errorList.filter(filter);
	    },

	    /**
	     * Formats error for further output.
	     *
	     * @param {Object} error
	     * @param {Boolean} [colorize = false]
	     * @returns {String}
	     */
	    explainError: function(error, colorize) {
	        var lineNumber = error.line - 1;
	        var lines = this._file.getLines();
	        var result = [
	            renderLine(lineNumber, lines[lineNumber], colorize),
	            renderPointer(error.column, colorize)
	        ];
	        var i = lineNumber - 1;
	        var linesAround = 2;
	        while (i >= 0 && i >= (lineNumber - linesAround)) {
	            result.unshift(renderLine(i, lines[i], colorize));
	            i--;
	        }
	        i = lineNumber + 1;
	        while (i < lines.length && i <= (lineNumber + linesAround)) {
	            result.push(renderLine(i, lines[i], colorize));
	            i++;
	        }
	        result.unshift(formatErrorMessage(error.message, this.getFilename(), colorize));
	        return result.join('\n');
	    },

	    /**
	     * Sets the current rule so that errors are aware
	     * of which rule triggered them.
	     *
	     * @param {String} rule
	     */
	    setCurrentRule: function(rule) {
	        this._currentRule = rule;
	    }

	};

	/**
	 * Formats error message header.
	 *
	 * @param {String} message
	 * @param {String} filename
	 * @param {Boolean} colorize
	 * @returns {String}
	 */
	function formatErrorMessage(message, filename, colorize) {
	    return (colorize ? chalk.bold(message) : message) +
	        ' at ' +
	        (colorize ? chalk.green(filename) : filename) + ' :';
	}

	/**
	 * Simple util for prepending spaces to the string until it fits specified size.
	 *
	 * @param {String} s
	 * @param {Number} len
	 * @returns {String}
	 */
	function prependSpaces(s, len) {
	    while (s.length < len) {
	        s = ' ' + s;
	    }
	    return s;
	}

	/**
	 * Renders single line of code in style error formatted output.
	 *
	 * @param {Number} n line number
	 * @param {String} line
	 * @param {Boolean} [colorize = false]
	 * @returns {String}
	 */
	function renderLine(n, line, colorize) {
	    // Convert tabs to spaces, so errors in code lines with tabs as indention symbol
	    // could be correctly rendered, plus it will provide less verbose output
	    line = line.replace(/\t/g, ' ');

	    // "n + 1" to print lines in human way (counted from 1)
	    var lineNumber = prependSpaces((n + 1).toString(), 5) + ' |';
	    return ' ' + (colorize ? chalk.grey(lineNumber) : lineNumber) + line;
	}

	/**
	 * Renders pointer:
	 * ---------------^
	 *
	 * @param {Number} column
	 * @param {Boolean} [colorize = false]
	 * @returns {String}
	 */
	function renderPointer(column, colorize) {
	    var res = (new Array(column + 9)).join('-') + '^';
	    return colorize ? chalk.grey(res) : res;
	}

	module.exports = Errors;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }

	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}

	// based on node assert, original notice:

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	var util = __webpack_require__(24);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};

	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;

	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};

	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }

	    memos.actual.push(actual);
	    memos.expected.push(expected);

	    return objEquiv(actual, expected, strict, memos);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}


	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }

	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }

	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }

	  return expected.call({}, actual) === true;
	}

	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }

	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }

	  actual = _tryBlock(block);

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;

	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};

	assert.ifError = function(err) { if (err) throw err; };

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(26);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(27);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(25)))

/***/ },
/* 25 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 27 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var escapeStringRegexp = __webpack_require__(29);
	var ansiStyles = __webpack_require__(30);
	var stripAnsi = __webpack_require__(32);
	var hasAnsi = __webpack_require__(34);
	var supportsColor = __webpack_require__(36);
	var defineProps = Object.defineProperties;

	function Chalk(options) {
		// detect mode if not set manually
		this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
	}

	// use bright blue on Windows as the normal blue color is illegible
	if (process.platform === 'win32') {
		ansiStyles.blue.open = '\u001b[94m';
	}

	function build(_styles) {
		var builder = function builder() {
			return applyStyle.apply(builder, arguments);
		};
		builder._styles = _styles;
		builder.enabled = this.enabled;
		// __proto__ is used because we must return a function, but there is
		// no way to create a function with a different prototype.
		builder.__proto__ = proto;
		return builder;
	}

	var styles = (function () {
		var ret = {};

		Object.keys(ansiStyles).forEach(function (key) {
			ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

			ret[key] = {
				get: function () {
					return build.call(this, this._styles.concat(key));
				}
			};
		});

		return ret;
	})();

	var proto = defineProps(function chalk() {}, styles);

	function applyStyle() {
		// support varags, but simply cast to string in case there's only one arg
		var args = arguments;
		var argsLen = args.length;
		var str = argsLen !== 0 && String(arguments[0]);
		if (argsLen > 1) {
			// don't slice `arguments`, it prevents v8 optimizations
			for (var a = 1; a < argsLen; a++) {
				str += ' ' + args[a];
			}
		}

		if (!this.enabled || !str) {
			return str;
		}

		/*jshint validthis: true */
		var nestedStyles = this._styles;

		var i = nestedStyles.length;
		while (i--) {
			var code = ansiStyles[nestedStyles[i]];
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			str = code.open + str.replace(code.closeRe, code.open) + code.close;
		}

		return str;
	}

	function init() {
		var ret = {};

		Object.keys(styles).forEach(function (name) {
			ret[name] = {
				get: function () {
					return build.call(this, [name]);
				}
			};
		});

		return ret;
	}

	defineProps(Chalk.prototype, init());

	module.exports = new Chalk();
	module.exports.styles = ansiStyles;
	module.exports.hasColor = hasAnsi;
	module.exports.stripColor = stripAnsi;
	module.exports.supportsColor = supportsColor;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)))

/***/ },
/* 29 */
/***/ function(module, exports) {

	'use strict';

	var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

	module.exports = function (str) {
		if (typeof str !== 'string') {
			throw new TypeError('Expected a string');
		}

		return str.replace(matchOperatorsRe, '\\$&');
	};


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict';

	function assembleStyles () {
		var styles = {
			modifiers: {
				reset: [0, 0],
				bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
				dim: [2, 22],
				italic: [3, 23],
				underline: [4, 24],
				inverse: [7, 27],
				hidden: [8, 28],
				strikethrough: [9, 29]
			},
			colors: {
				black: [30, 39],
				red: [31, 39],
				green: [32, 39],
				yellow: [33, 39],
				blue: [34, 39],
				magenta: [35, 39],
				cyan: [36, 39],
				white: [37, 39],
				gray: [90, 39]
			},
			bgColors: {
				bgBlack: [40, 49],
				bgRed: [41, 49],
				bgGreen: [42, 49],
				bgYellow: [43, 49],
				bgBlue: [44, 49],
				bgMagenta: [45, 49],
				bgCyan: [46, 49],
				bgWhite: [47, 49]
			}
		};

		// fix humans
		styles.colors.grey = styles.colors.gray;

		Object.keys(styles).forEach(function (groupName) {
			var group = styles[groupName];

			Object.keys(group).forEach(function (styleName) {
				var style = group[styleName];

				styles[styleName] = group[styleName] = {
					open: '\u001b[' + style[0] + 'm',
					close: '\u001b[' + style[1] + 'm'
				};
			});

			Object.defineProperty(styles, groupName, {
				value: group,
				enumerable: false
			});
		});

		return styles;
	}

	Object.defineProperty(module, 'exports', {
		enumerable: true,
		get: assembleStyles
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(31)(module)))

/***/ },
/* 31 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ansiRegex = __webpack_require__(33)();

	module.exports = function (str) {
		return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
	};


/***/ },
/* 33 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function () {
		return /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/g;
	};


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ansiRegex = __webpack_require__(35);
	var re = new RegExp(ansiRegex().source); // remove the `g` flag
	module.exports = re.test.bind(re);


/***/ },
/* 35 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function () {
		return /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/g;
	};


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var argv = process.argv;

	module.exports = (function () {
		if ('FORCE_COLOR' in process.env) {
			return true;
		}

		if (argv.indexOf('--no-color') !== -1 ||
			argv.indexOf('--no-colors') !== -1 ||
			argv.indexOf('--color=false') !== -1) {
			return false;
		}

		if (argv.indexOf('--color') !== -1 ||
			argv.indexOf('--colors') !== -1 ||
			argv.indexOf('--color=true') !== -1 ||
			argv.indexOf('--color=always') !== -1) {
			return true;
		}

		if (process.stdout && !process.stdout.isTTY) {
			return false;
		}

		if (process.platform === 'win32') {
			return true;
		}

		if ('COLORTERM' in process.env) {
			return true;
		}

		if (process.env.TERM === 'dumb') {
			return false;
		}

		if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
			return true;
		}

		return false;
	})();

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(24);
	var EventEmitter = __webpack_require__(38).EventEmitter;

	/**
	 * Token assertions class.
	 *
	 * @name {TokenAssert}
	 * @param {JsFile} file
	 */
	function TokenAssert(file) {
	    EventEmitter.call(this);

	    this._file = file;
	}

	utils.inherits(TokenAssert, EventEmitter);

	/**
	 * Requires to have whitespace between specified tokens. Ignores newlines.
	 *
	 * @param {Object} options.token
	 * @param {Object} options.nextToken
	 * @param {String} [options.message]
	 * @param {Number} [options.spaces] Amount of spaces between tokens.
	 */
	TokenAssert.prototype.whitespaceBetween = function(options) {
	    options.atLeast = 1;
	    this.spacesBetween(options);
	};

	/**
	 * Requires to have no whitespace between specified tokens.
	 *
	 * @param {Object} options.token
	 * @param {Object} options.nextToken
	 * @param {String} [options.message]
	 * @param {Boolean} [options.disallowNewLine=false]
	 */
	TokenAssert.prototype.noWhitespaceBetween = function(options) {
	    options.exactly = 0;
	    this.spacesBetween(options);
	};

	/**
	 * Requires to have the whitespace between specified tokens with the provided options.
	 *
	 * @param {Object} options.token
	 * @param {Object} options.nextToken
	 * @param {String} [options.message]
	 * @param {Object} [options.atLeast] At least how many spaces the tokens are apart
	 * @param {Object} [options.atMost] At most how many spaces the tokens are apart
	 * @param {Object} [options.exactly] Exactly how many spaces the tokens are apart
	 * @param {Boolean} [options.disallowNewLine=false]
	 */
	TokenAssert.prototype.spacesBetween = function(options) {
	    var token = options.token;
	    var nextToken = options.nextToken;
	    var atLeast = options.atLeast;
	    var atMost = options.atMost;
	    var exactly = options.exactly;

	    if (!token || !nextToken) {
	        return;
	    }

	    this._validateOptions(options);

	    if (!options.disallowNewLine && token.loc.end.line !== nextToken.loc.start.line) {
	        return;
	    }

	    // Only attempt to remove or add lines if there are no comments between the two nodes
	    // as this prevents accidentally moving a valid token onto a line comment ed line
	    var fixed = this._file.getNextToken(options.token, {includeComments: true}) === nextToken;

	    var emitError = function(countPrefix, spaceCount) {
	        if (fixed) {
	            nextToken.whitespaceBefore = new Array(spaceCount + 1).join(' ');
	        }

	        var msgPostfix = token.value + ' and ' + nextToken.value;

	        if (!options.message) {
	            if (exactly === 0) {
	                // support noWhitespaceBetween
	                options.message = 'Unexpected whitespace between ' + msgPostfix;
	            } else if (exactly !== undefined) {
	                // support whitespaceBetween (spaces option)
	                options.message = spaceCount + ' spaces required between ' + msgPostfix;
	            } else if (atLeast === 1 && atMost === undefined) {
	                // support whitespaceBetween (no spaces option)
	                options.message = 'Missing space between ' + msgPostfix;
	            } else {
	                options.message = countPrefix + ' ' + spaceCount + ' spaces required between ' + msgPostfix;
	            }
	        }

	        this.emit('error', {
	            message: options.message,
	            line: token.loc.end.line,
	            column: token.loc.end.column,
	            fixed: fixed
	        });
	    }.bind(this);

	    var spacesBetween = Math.abs(nextToken.range[0] - token.range[1]);
	    if (atLeast !== undefined && spacesBetween < atLeast) {
	        emitError('at least', atLeast);
	    } else if (atMost !== undefined && spacesBetween > atMost) {
	        emitError('at most', atMost);
	    } else if (exactly !== undefined && spacesBetween !== exactly) {
	        emitError('exactly', exactly);
	    }
	};

	/**
	 * Requires the specified line to have the expected indentation.
	 *
	 * @param {Number} options.lineNumber
	 * @param {Number} options.actual
	 * @param {Number} options.expected
	 * @param {String} options.indentChar
	 * @param {Boolean} [options.silent] if true, will suppress error emission but still fix whitespace
	 */
	TokenAssert.prototype.indentation = function(options) {
	    var lineNumber = options.lineNumber;
	    var actual = options.actual;
	    var expected = options.expected;
	    var indentChar = options.indentChar;

	    if (actual === expected) {
	        return;
	    }

	    if (!options.silent) {
	        this.emit('error', {
	            message: 'Expected indentation of ' + expected + ' characters',
	            line: lineNumber,
	            column: expected,
	            fixed: true
	        });
	    }

	    var token = this._file.getFirstTokenOnLine(lineNumber, {includeComments: true});
	    var newWhitespace = (new Array(expected + 1)).join(indentChar);

	    if (!token) {
	        this._setEmptyLineIndentation(lineNumber, newWhitespace);
	        return;
	    }

	    this._updateWhitespaceByLine(token, function(lines) {
	        lines[lines.length - 1] = newWhitespace;

	        return lines;
	    });

	    if (token.isComment) {
	        this._updateCommentWhitespace(token, indentChar, actual, expected);
	    }
	};

	/**
	 * Updates the whitespace of a line by passing split lines to a callback function
	 * for editing.
	 *
	 * @param  {Number} lineNumber
	 * @param  {Function} callback
	 */
	TokenAssert.prototype._updateWhitespaceByLine = function(token, callback) {
	    var lineBreak = this._file.getLineBreakStyle();
	    var lines = token.whitespaceBefore.split(/\r\n|\r|\n/);

	    lines = callback(lines);
	    token.whitespaceBefore = lines.join(lineBreak);
	};

	/**
	 * Updates the whitespace of a line by passing split lines to a callback function
	 * for editing.
	 *
	 * @param  {Number} lineNumber
	 * @param  {Function} callback
	 */
	TokenAssert.prototype._updateCommentWhitespace = function(token, indentChar, actual, expected) {
	    var difference = expected - actual;
	    var tokenLines = token.value.split(/\r\n|\r|\n/);
	    var i = 1;
	    if (difference >= 0) {
	        var lineWhitespace = (new Array(difference + 1)).join(indentChar);
	        for (; i < tokenLines.length; i++) {
	            tokenLines[i] = tokenLines[i] === '' ? '' : lineWhitespace + tokenLines[i];
	        }
	    } else {
	        for (; i < tokenLines.length; i++) {
	            tokenLines[i] = tokenLines[i].substring(-difference);
	        }
	    }

	    token.value = tokenLines.join(this._file.getLineBreakStyle());
	};

	/**
	 * Fixes the indentation of a line that has no tokens on it
	 *
	 * @param  {Number} lineNumber
	 * @param  {String} newWhitespace
	 */
	TokenAssert.prototype._setEmptyLineIndentation = function(lineNumber, newWhitespace) {
	    var token;
	    do {
	        token = this._file.getFirstTokenOnLine(++lineNumber, {includeComments: true});
	    } while (!token);

	    this._updateWhitespaceByLine(token, function(lines) {
	        if (lines[0] !== '') {
	            lines[0] = newWhitespace;
	        }

	        for (var i = 1; i < lines.length; i++) {
	            lines[i] = newWhitespace;
	        }

	        return lines;
	    });
	};

	/**
	 * Requires tokens to be on the same line.
	 *
	 * @param {Object} options.token
	 * @param {Object} options.nextToken
	 * @param {Boolean} [options.stickToPreviousToken]
	 * @param {String} [options.message]
	 */
	TokenAssert.prototype.sameLine = function(options) {
	    options.exactly = 0;

	    this.linesBetween(options);
	};

	/**
	 * Requires tokens to be on different lines.
	 *
	 * @param {Object} options.token
	 * @param {Object} options.nextToken
	 * @param {Object} [options.message]
	 */
	TokenAssert.prototype.differentLine = function(options) {
	    options.atLeast = 1;

	    this.linesBetween(options);
	};

	/**
	 * Requires tokens to have a certain amount of lines between them.
	 * Set at least one of atLeast or atMost OR set exactly.
	 *
	 * @param {Object} options.token
	 * @param {Object} options.nextToken
	 * @param {Object} [options.message]
	 * @param {Object} [options.atLeast] At least how many lines the tokens are apart
	 * @param {Object} [options.atMost] At most how many lines the tokens are apart
	 * @param {Object} [options.exactly] Exactly how many lines the tokens are apart
	 * @param {Boolean} [options.stickToPreviousToken] When auto-fixing stick the
	 *     nextToken onto the previous token.
	 */
	TokenAssert.prototype.linesBetween = function(options) {
	    var token = options.token;
	    var nextToken = options.nextToken;
	    var atLeast = options.atLeast;
	    var atMost = options.atMost;
	    var exactly = options.exactly;

	    if (!token || !nextToken) {
	        return;
	    }

	    this._validateOptions(options);

	    // Only attempt to remove or add lines if there are no comments between the two nodes
	    // as this prevents accidentally moving a valid token onto a line comment ed line
	    var fixed = this._file.getNextToken(options.token, {includeComments: true}) === nextToken;

	    var linesBetween = Math.abs(token.loc.end.line - nextToken.loc.start.line);

	    var emitError = function(countPrefix, lineCount) {
	        var msgPrefix = token.value + ' and ' + nextToken.value;

	        if (!options.message) {
	            if (exactly === 0) {
	                // support sameLine
	                options.message = msgPrefix + ' should be on the same line';
	            } else if (atLeast === 1 && atMost === undefined) {
	                // support differentLine
	                options.message = msgPrefix + ' should be on different lines';
	            } else {
	                // support linesBetween
	                options.message = msgPrefix + ' should have ' + countPrefix + ' ' + lineCount + ' line(s) between them';
	            }
	        }

	        if (fixed) {
	            this._augmentLineCount(options, lineCount);
	        }

	        this.emit('error', {
	            message: options.message,
	            line: token.loc.end.line,
	            column: token.loc.end.column,
	            fixed: fixed
	        });
	    }.bind(this);

	    if (atLeast !== undefined && linesBetween < atLeast) {
	        emitError('at least', atLeast);
	    } else if (atMost !== undefined && linesBetween > atMost) {
	        emitError('at most', atMost);
	    } else if (exactly !== undefined && linesBetween !== exactly) {
	        emitError('exactly', exactly);
	    }
	};

	/**
	 * Throws errors if atLeast, atMost, and exactly options don't mix together properly or
	 * if the tokens provided are equivalent.
	 *
	 * @param {Object} options.token
	 * @param {Object} options.nextToken
	 * @param {Object} [options.atLeast] At least how many spaces the tokens are apart
	 * @param {Object} [options.atMost] At most how many spaces the tokens are apart
	 * @param {Object} [options.exactly] Exactly how many spaces the tokens are apart
	 * @throws {Error} If the options are non-sensical
	 */
	TokenAssert.prototype._validateOptions = function(options) {
	    var token = options.token;
	    var nextToken = options.nextToken;
	    var atLeast = options.atLeast;
	    var atMost = options.atMost;
	    var exactly = options.exactly;

	    if (token === nextToken) {
	        throw new Error('You cannot specify the same token as both token and nextToken');
	    }

	    if (atLeast === undefined &&
	        atMost === undefined &&
	        exactly === undefined) {
	        throw new Error('You must specify at least one option');
	    }

	    if (exactly !== undefined && (atLeast !== undefined || atMost !== undefined)) {
	        throw new Error('You cannot specify atLeast or atMost with exactly');
	    }

	    if (atLeast !== undefined && atMost !== undefined && atMost < atLeast) {
	        throw new Error('atLeast and atMost are in conflict');
	    }
	};

	/**
	 * Augments token whitespace to contain the correct number of newlines while preserving indentation
	 *
	 * @param {Object} options.nextToken
	 * @param {Boolean} [options.stickToPreviousToken]
	 * @param {Number} lineCount
	 */
	TokenAssert.prototype._augmentLineCount = function(options, lineCount) {
	    var token = options.nextToken;
	    if (lineCount === 0) {
	        if (options.stickToPreviousToken) {
	            var nextToken = this._file.getNextToken(token, {includeComments: true});
	            nextToken.whitespaceBefore = token.whitespaceBefore;
	        }
	        token.whitespaceBefore = ' ';
	        return;
	    }

	    this._updateWhitespaceByLine(token, function(lines) {
	        var currentLineCount = lines.length;
	        var lastLine = lines[lines.length - 1];

	        if (currentLineCount <= lineCount) {
	            // add additional lines that maintain the same indentation as the former last line
	            for (; currentLineCount <= lineCount; currentLineCount++) {
	                lines[lines.length - 1] = '';
	                lines.push(lastLine);
	            }
	        } else {
	            // remove lines and then ensure that the new last line maintains the previous indentation
	            lines = lines.slice(0, lineCount + 1);
	            lines[lines.length - 1] = lastLine;
	        }
	        return lines;
	    });
	};

	/**
	 * Requires specific token before given.
	 *
	 * @param {Object} options.token
	 * @param {Object} options.expectedTokenBefore
	 * @param {String} [options.message]
	 */
	TokenAssert.prototype.tokenBefore = function(options) {
	    var token = options.token;
	    var actualTokenBefore = this._file.getPrevToken(token);
	    var expectedTokenBefore = options.expectedTokenBefore;
	    if (!actualTokenBefore) {
	        this.emit('error', {
	            message: expectedTokenBefore.value + ' was expected before ' + token.value + ' but document start found',
	            line: token.loc.start.line,
	            column: token.loc.start.column
	        });
	        return;
	    }
	    if (
	        actualTokenBefore.type !== expectedTokenBefore.type ||
	        actualTokenBefore.value !== expectedTokenBefore.value
	    ) {
	        var message = options.message;
	        if (!message) {
	            var showTypes = expectedTokenBefore.value === actualTokenBefore.value;
	            message =
	                expectedTokenBefore.value + (showTypes ? ' (' + expectedTokenBefore.type + ')' : '') +
	                ' was expected before ' + token.value +
	                ' but ' + actualTokenBefore.value + (showTypes ? ' (' + actualTokenBefore.type + ')' : '') + ' found';
	        }
	        this.emit('error', {
	            message: message,
	            line: actualTokenBefore.loc.end.line,
	            column: actualTokenBefore.loc.end.column
	        });
	    }
	};
	/**
	 * Disallows specific token before given.
	 *
	 * @param {Object} options.token
	 * @param {Object} options.expectedTokenBefore
	 * @param {String} [options.message]
	 */
	TokenAssert.prototype.noTokenBefore = function(options) {
	    var token = options.token;
	    var actualTokenBefore = this._file.getPrevToken(token);
	    if (!actualTokenBefore) {
	        // document start
	        return;
	    }
	    var expectedTokenBefore = options.expectedTokenBefore;
	    if (actualTokenBefore.type === expectedTokenBefore.type &&
	        actualTokenBefore.value === expectedTokenBefore.value
	    ) {
	        this.emit('error', {
	            message: options.message || 'Illegal ' + expectedTokenBefore.value + ' was found before ' + token.value,
	            line: actualTokenBefore.loc.end.line,
	            column: actualTokenBefore.loc.end.column
	        });
	    }
	};

	module.exports = TokenAssert;


/***/ },
/* 38 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var treeIterator = __webpack_require__(40);

	/**
	 * Operator list which are represented as keywords in token list.
	 */
	var KEYWORD_OPERATORS = {
	    'instanceof': true,
	    'in': true
	};

	/**
	 * File representation for JSCS.
	 *
	 * @name JsFile
	 */
	var JsFile = function(filename, source, tree, options) {
	    options = options || {};

	    this._filename = filename;
	    this._source = source;
	    this._tree = tree || {tokens: [], comments: []};

	    this._es3 = options.es3 || false;
	    this._es6 = options.es6 || false;

	    this._lineBreaks = null;
	    this._lines = source.split(/\r\n|\r|\n/);

	    this._tree.tokens = this._fixEs6Tokens(this._tree.tokens);
	    this._tokens = this._buildTokenList(this._tree.tokens, this._tree.comments);
	    this._addEOFToken();
	    this._applyWhitespaceData(this._tokens, source);

	    var tokenIndexes = this._buildTokenIndex(this._tokens);
	    this._tokenRangeStartIndex = tokenIndexes.tokenRangeStartIndex;
	    this._tokenRangeEndIndex = tokenIndexes.tokenRangeEndIndex;
	    this._tokensByLineIndex = tokenIndexes.tokensByLineIndex;

	    var nodeIndexes = this._buildNodeIndex();
	    this._index = nodeIndexes.nodesByType;
	    this._nodesByStartRange = nodeIndexes.nodesByStartRange;

	    this._fixEsprimaIdentifiers();

	    this._buildDisabledRuleIndex();
	};

	JsFile.prototype = {
	    /**
	     * Returns the first line break character encountered in the file.
	     * Assumes LF if the file is only one line.
	     *
	     * @returns {String}
	     */
	    getLineBreakStyle: function() {
	        var lineBreaks = this.getLineBreaks();
	        return lineBreaks.length ? lineBreaks[0] : '\n';
	    },

	    /**
	     * Returns all line break characters from the file.
	     *
	     * @returns {String[]}
	     */
	    getLineBreaks: function() {
	        if (this._lineBreaks === null) {
	            this._lineBreaks = this._source.match(/\r\n|\r|\n/g) || [];
	        }
	        return this._lineBreaks;
	    },

	    /**
	     * Builds an index of disabled rules by starting line for error suppression.
	     *
	     * @private
	     */
	    _buildDisabledRuleIndex: function() {
	        this._disabledRuleIndex = [];

	        var comments = this.getComments();
	        var commentRe = /(jscs\s*:\s*(en|dis)able)(.*)/;

	        comments.forEach(function(comment) {
	            var enabled;
	            var parsed = commentRe.exec(comment.value.trim());

	            if (!parsed || parsed.index !== 0) {
	                return;
	            }

	            enabled = parsed[2] === 'en';
	            this._addToDisabledRuleIndex(enabled, parsed[3], comment.loc.start.line);
	        }, this);
	    },

	    /**
	     * Returns whether a specific rule is disabled on the given line.
	     *
	     * @param {String} ruleName the rule name being tested
	     * @param {Number} line the line number being tested
	     * @returns {Boolean} true if the rule is enabled
	     */
	    isEnabledRule: function(ruleName, line) {
	        var enabled = true;
	        this._disabledRuleIndex.some(function(region) {
	            // once the comment we're inspecting occurs after the location of the error,
	            // no longer check for whether the state is enabled or disable
	            if (region.line > line) {
	                return true;
	            }

	            if (region.rule === ruleName || region.rule === '*') {
	                enabled = region.enabled;
	            }
	        }, this);

	        return enabled;
	    },

	    /**
	     * Adds rules to the disabled index given a string containing rules (or '' for all).
	     *
	     * @param {Boolean} enabled whether the rule is disabled or enabled on this line
	     * @param {String} rulesStr the string containing specific rules to en/disable
	     * @param {Number} line the line the comment appears on
	     * @private
	     */
	    _addToDisabledRuleIndex: function(enabled, rulesStr, line) {
	        rulesStr = rulesStr || '*';

	        rulesStr.split(',').forEach(function(rule) {
	            rule = rule.trim();

	            if (!rule) {
	                return;
	            }

	            this._disabledRuleIndex.push({
	                rule: rule,
	                enabled: enabled,
	                line: line
	            });
	        }, this);
	    },

	    /**
	     * Builds token index by starting pos for futher navigation.
	     *
	     * @param {Object[]} tokens
	     * @returns {{tokenRangeStartIndex: {}, tokenRangeEndIndex: {}}}
	     * @private
	     */
	    _buildTokenIndex: function(tokens) {
	        var tokenRangeStartIndex = {};
	        var tokenRangeEndIndex = {};
	        var tokensByLineIndex = {};
	        for (var i = 0, l = tokens.length; i < l; i++) {
	            var token = tokens[i];

	            // tokens by range
	            tokenRangeStartIndex[token.range[0]] = i;
	            tokenRangeEndIndex[token.range[1]] = i;

	            // tokens by line
	            var lineNumber = token.loc.start.line;
	            if (!tokensByLineIndex[lineNumber]) {
	                tokensByLineIndex[lineNumber] = [];
	            }
	            tokensByLineIndex[lineNumber].push(token);

	            token._tokenIndex = i;
	        }
	        return {
	            tokenRangeStartIndex: tokenRangeStartIndex,
	            tokenRangeEndIndex: tokenRangeEndIndex,
	            tokensByLineIndex: tokensByLineIndex
	        };
	    },

	    /**
	     * Returns token using range start from the index.
	     *
	     * @returns {Object|undefined}
	     */
	    getTokenByRangeStart: function(start) {
	        var tokenIndex = this._tokenRangeStartIndex[start];
	        return tokenIndex === undefined ? undefined : this._tokens[tokenIndex];
	    },

	    /**
	     * Returns token using range end from the index.
	     *
	     * @returns {Object|undefined}
	     */
	    getTokenByRangeEnd: function(end) {
	        var tokenIndex = this._tokenRangeEndIndex[end];
	        return tokenIndex === undefined ? undefined : this._tokens[tokenIndex];
	    },

	    /**
	     * Returns the first token for the node from the AST.
	     *
	     * @param {Object} node
	     * @returns {Object}
	     */
	    getFirstNodeToken: function(node) {
	        return this.getTokenByRangeStart(node.range[0]);
	    },

	    /**
	     * Returns the last token for the node from the AST.
	     *
	     * @param {Object} node
	     * @returns {Object}
	     */
	    getLastNodeToken: function(node) {
	        return this.getTokenByRangeEnd(node.range[1]);
	    },

	    /**
	     * Returns the first token for the file.
	     *
	     * @returns {Object}
	     */
	    getFirstToken: function() {
	        return this._tokens[0];
	    },

	    /**
	     * Returns the last token for the file.
	     *
	     * @returns {Object}
	     */
	    getLastToken: function() {
	        return this._tokens[this._tokens.length - 1];
	    },

	    /**
	     * Returns the first token before the given.
	     *
	     * @param {Object} token
	     * @param {Object} [options]
	     * @param {Boolean} [options.includeComments=false]
	     * @returns {Object|undefined}
	     */
	    getPrevToken: function(token, options) {
	        var index = token._tokenIndex - 1;
	        if (index < 0) {
	            return undefined;
	        }

	        if (options && options.includeComments) {
	            return this._tokens[index];
	        }

	        do {
	            if (!this._tokens[index].isComment) {
	                return this._tokens[index];
	            }
	        } while (--index >= 0);

	        return undefined;
	    },

	    /**
	     * Returns the first token after the given.
	     *
	     * @param {Object} token
	     * @param {Object} [options]
	     * @param {Boolean} [options.includeComments=false]
	     * @returns {Object|undefined}
	     */
	    getNextToken: function(token, options) {
	        var index = token._tokenIndex + 1;

	        if (index >= this._tokens.length) {
	            return undefined;
	        }

	        if (options && options.includeComments) {
	            return this._tokens[index];
	        }

	        do {
	            if (!this._tokens[index].isComment) {
	                return this._tokens[index];
	            }
	        } while (++index < this._tokens.length);
	    },

	    /**
	     * Returns the first token before the given which matches type (and value).
	     *
	     * @param {Object} token
	     * @param {String} type
	     * @param {String} [value]
	     * @returns {Object|undefined}
	     */
	    findPrevToken: function(token, type, value) {
	        var prevToken = this.getPrevToken(token);
	        while (prevToken) {
	            if (prevToken.type === type && (value === undefined || prevToken.value === value)) {
	                return prevToken;
	            }
	            prevToken = this.getPrevToken(prevToken);
	        }
	        return prevToken;
	    },

	    /**
	     * Returns the first token after the given which matches type (and value).
	     *
	     * @param {Object} token
	     * @param {String} type
	     * @param {String} [value]
	     * @returns {Object|undefined}
	     */
	    findNextToken: function(token, type, value) {
	        var nextToken = this.getNextToken(token);
	        while (nextToken) {
	            if (nextToken.type === type && (value === undefined || nextToken.value === value)) {
	                return nextToken;
	            }
	            nextToken = this.getNextToken(nextToken);
	        }
	        return nextToken;
	    },

	    /**
	     * Returns the first token before the given which matches type (and value).
	     *
	     * @param {Object} token
	     * @param {String} value
	     * @returns {Object|undefined}
	     */
	    findPrevOperatorToken: function(token, value) {
	        return this.findPrevToken(token, value in KEYWORD_OPERATORS ? 'Keyword' : 'Punctuator', value);
	    },

	    /**
	     * Returns the first token after the given which matches type (and value).
	     *
	     * @param {Object} token
	     * @param {String} value
	     * @returns {Object|undefined}
	     */
	    findNextOperatorToken: function(token, value) {
	        return this.findNextToken(token, value in KEYWORD_OPERATORS ? 'Keyword' : 'Punctuator', value);
	    },

	    /**
	     * Iterates through the token tree using tree iterator.
	     * Calls passed function for every token.
	     *
	     * @param {Function} cb
	     * @param {Object} [tree]
	     */
	    iterate: function(cb, tree) {
	        return treeIterator.iterate(tree || this._tree, cb);
	    },

	    /**
	     * Returns node by its range position
	     *
	     * @returns {Object}
	     */
	    getNodeByRange: function(number) {
	        var result = {};
	        this.iterate(function(node) {
	            if (number >= node.range[0] && number < node.range[1]) {
	                result = node;
	            }
	            if (number < node.range[0]) {
	                return false;
	            }
	        });
	        return result;
	    },

	    /**
	     * Returns nodes by range start index from earlier built index.
	     *
	     * @param {Object} token
	     * @returns {Object[]}
	     */
	    getNodesByFirstToken: function(token) {
	        var result = [];
	        if (token && token.range && token.range[0] >= 0) {
	            var nodes = this._nodesByStartRange[token.range[0]];
	            if (nodes) {
	                result = result.concat(nodes);
	            }
	        }
	        return result;
	    },

	    /**
	     * Returns nodes by type(s) from earlier built index.
	     *
	     * @param {String|String[]} type
	     * @returns {Object[]}
	     */
	    getNodesByType: function(type) {
	        if (typeof type === 'string') {
	            return this._index[type] || [];
	        } else {
	            var result = [];
	            for (var i = 0, l = type.length; i < l; i++) {
	                var nodes = this._index[type[i]];
	                if (nodes) {
	                    result = result.concat(nodes);
	                }
	            }
	            return result;
	        }
	    },

	    /**
	     * Iterates nodes by type(s) from earlier built index.
	     * Calls passed function for every matched node.
	     *
	     * @param {String|String[]} type
	     * @param {Function} cb
	     */
	    iterateNodesByType: function(type, cb) {
	        return this.getNodesByType(type).forEach(cb);
	    },

	    /**
	     * Iterates tokens by type(s) from the token array.
	     * Calls passed function for every matched token.
	     *
	     * @param {String|String[]} type
	     * @param {Function} cb
	     */
	    iterateTokensByType: function(type, cb) {
	        var types = (typeof type === 'string') ? [type] : type;
	        var typeIndex = {};
	        types.forEach(function(type) {
	            typeIndex[type] = true;
	        });

	        this.getTokens().forEach(function(token, index, tokens) {
	            if (typeIndex[token.type]) {
	                cb(token, index, tokens);
	            }
	        });
	    },

	    /**
	     * Iterates token by value from the token array.
	     * Calls passed function for every matched token.
	     *
	     * @param {String|String[]} name
	     * @param {Function} cb
	     */
	    iterateTokenByValue: function(name, cb) {
	        var names = (typeof name === 'string') ? [name] : name;
	        var nameIndex = {};
	        names.forEach(function(type) {
	            nameIndex[type] = true;
	        });

	        this.getTokens().forEach(function(token, index, tokens) {
	            if (nameIndex.hasOwnProperty(token.value)) {
	                cb(token, index, tokens);
	            }
	        });
	    },

	    /**
	     * Iterates tokens by type and value(s) from the token array.
	     * Calls passed function for every matched token.
	     *
	     * @param {String} type
	     * @param {String|String[]} value
	     * @param {Function} cb
	     */
	    iterateTokensByTypeAndValue: function(type, value, cb) {
	        var values = (typeof value === 'string') ? [value] : value;
	        var valueIndex = {};
	        values.forEach(function(type) {
	            valueIndex[type] = true;
	        });

	        this.getTokens().forEach(function(token, index, tokens) {
	            if (token.type === type && valueIndex[token.value]) {
	                cb(token, index, tokens);
	            }
	        });
	    },

	    /**
	     * Returns first token for the specified line.
	     * Line numbers start with 1.
	     *
	     * @param {Number} lineNumber
	     * @param {Object} [options]
	     * @param {Boolean} [options.includeComments = false]
	     * @returns {Object|undefined}
	     */
	    getFirstTokenOnLine: function(lineNumber, options) {
	        var tokensByLine = this._tokensByLineIndex[lineNumber];

	        if (!tokensByLine) {
	            return undefined;
	        }

	        if (options && options.includeComments) {
	            return tokensByLine[0];
	        }

	        for (var i = 0; i < tokensByLine.length; i++) {
	            var token = tokensByLine[i];
	            if (!token.isComment) {
	                return token;
	            }
	        }

	        return undefined;
	    },

	    /**
	     * Returns which dialect of JS this file supports.
	     *
	     * @returns {String}
	     */
	    getDialect: function() {
	        if (this._es6) {
	            return 'es6';
	        }

	        if (this._es3) {
	            return 'es3';
	        }

	        return 'es5';
	    },

	    /**
	     * Returns string representing contents of the file.
	     *
	     * @returns {String}
	     */
	    getSource: function() {
	        return this._source;
	    },

	    /**
	     * Returns token tree, built using esprima.
	     *
	     * @returns {Object}
	     */
	    getTree: function() {
	        return this._tree;
	    },

	    /**
	     * Returns token list, built using esprima.
	     *
	     * @returns {Object[]}
	     */
	    getTokens: function() {
	        return this._tokens;
	    },

	    /**
	     * Returns comment token list, built using esprima.
	     */
	    getComments: function() {
	        return this._tree.comments;
	    },

	    /**
	     * Returns source filename for this object representation.
	     *
	     * @returns {String}
	     */
	    getFilename: function() {
	        return this._filename;
	    },

	    /**
	     * Returns array of source lines for the file.
	     *
	     * @returns {String[]}
	     */
	    getLines: function() {
	        return this._lines;
	    },

	    /**
	     * Returns array of source lines for the file with comments removed.
	     *
	     * @returns {Array}
	     */
	    getLinesWithCommentsRemoved: function() {
	        var lines = this.getLines().concat();

	        this.getComments().concat().reverse().forEach(function(comment) {
	            var startLine = comment.loc.start.line;
	            var startCol = comment.loc.start.column;
	            var endLine = comment.loc.end.line;
	            var endCol = comment.loc.end.column;
	            var i = startLine - 1;

	            if (startLine === endLine) {
	                lines[i] = lines[i].substring(0, startCol) + lines[i].substring(endCol);
	            } else {
	                lines[i] = lines[i].substring(0, startCol);
	                for (var x = i + 1; x < endLine - 1; x++) {
	                    lines[x] = '';
	                }
	                lines[x] = lines[x].substring(endCol);
	            }
	        });

	        return lines;
	    },

	    /**
	     * Renders JS-file sources using token list.
	     *
	     * @returns {String}
	     */
	    render: function() {
	        var result = '';

	        // For-loop for maximal speed.
	        for (var i = 0; i < this._tokens.length; i++) {
	            var token = this._tokens[i];

	            result += token.whitespaceBefore;

	            switch (token.type) {
	                // Line-comment: // ...
	                case 'Line':
	                    result += '//' + token.value;
	                    break;

	                // Block-comment: /* ... */
	                case 'Block':
	                    result += '/*' + token.value + '*/';
	                    break;

	                default:
	                    result += token.value;
	            }
	        }
	        return result;
	    },

	    /**
	     * Builds token list using both code tokens and comment-tokens.
	     *
	     * @returns {Object[]}
	     * @private
	     */
	    _buildTokenList: function(codeTokens, commentTokens) {
	        var result = [];
	        var codeQueue = codeTokens.concat();
	        var commentQueue = commentTokens.concat();
	        while (codeQueue.length > 0 || commentQueue.length > 0) {
	            if (codeQueue.length > 0 && (!commentQueue.length || commentQueue[0].range[0] > codeQueue[0].range[0])) {
	                result.push(codeQueue.shift());
	            } else {
	                var commentToken = commentQueue.shift();
	                commentToken.isComment = true;
	                result.push(commentToken);
	            }
	        }
	        return result;
	    },

	    /**
	     * Adds JSCS-specific EOF (end of file) token.
	     *
	     * @private
	     */
	    _addEOFToken: function() {
	        var loc = {
	            line: this._lines.length,
	            column: this._lines[this._lines.length - 1].length
	        };
	        this._tokens.push({
	            type: 'EOF',
	            value: '',
	            range: [this._source.length, this._source.length + 1],
	            loc: {start: loc, end: loc}
	        });
	    },

	    /**
	     * Applies whitespace information to the token list.
	     *
	     * @param {Object[]} tokens
	     * @param {String} source
	     * @private
	     */
	    _applyWhitespaceData: function(tokens, source) {
	        var prevPos = 0;
	        // For-loop for maximal speed.
	        for (var i = 0; i < tokens.length; i++) {
	            var token = tokens[i];
	            var rangeStart = token.range[0];
	            var whitespace;
	            if (rangeStart === prevPos) {
	                whitespace = '';
	            } else {
	                whitespace = source.substring(prevPos, rangeStart);
	            }
	            token.whitespaceBefore = whitespace;
	            prevPos = token.range[1];
	        }
	    },

	    /**
	     * Temporary fix (I hope) for esprima tokenizer, which results
	     * in duplicate tokens on `export default function() {}`
	     * (https://code.google.com/p/esprima/issues/detail?id=631)
	     *
	     * @param {Object[]} tokens
	     * @returns {Object[]}
	     * @private
	     */
	    _fixEs6Tokens: function(tokens) {
	        if (this.getDialect() !== 'es6') {
	            return tokens;
	        }

	        var tokenHash = {};
	        return tokens.filter(function(token) {
	            var hashKey = token.range[0] + '_' + token.range[1];
	            var isDuplicate = tokenHash[hashKey];

	            tokenHash[hashKey] = true;

	            return !isDuplicate;
	        });
	    },

	    /**
	     * Builds node indexes using
	     *  i. node type as the key
	     *  ii. node start range as the key
	     * @returns {{nodesByType: {}, nodesByStartRange: {}}}
	     * @private
	     */
	    _buildNodeIndex: function() {
	        var nodesByType = {};
	        var nodesByStartRange = {};
	        this.iterate(function(node, parentNode, parentCollection) {
	            var type = node.type;

	            node.parentNode = parentNode;
	            node.parentCollection = parentCollection;
	            (nodesByType[type] || (nodesByType[type] = [])).push(node);

	            // this part builds a node index that uses node start ranges as the key
	            var startRange = node.range[0];
	            (nodesByStartRange[startRange] || (nodesByStartRange[startRange] = [])).push(node);
	        });
	        return {
	            nodesByType: nodesByType,
	            nodesByStartRange: nodesByStartRange
	        };
	    },

	    /**
	     * Temporary fix (I hope) for esprima tokenizer
	     * (https://code.google.com/p/esprima/issues/detail?id=481)
	     * Fixes #83, #180
	     * @private
	     */
	    _fixEsprimaIdentifiers: function() {
	        var _this = this;

	        this.iterateNodesByType(['Property', 'MemberExpression'], function(node) {
	            switch (node.type) {
	                case 'Property':
	                    convertKeywordToIdentifierIfRequired(node.key);
	                    break;
	                case 'MemberExpression':
	                    convertKeywordToIdentifierIfRequired(node.property);
	                    break;
	            }
	        });

	        function convertKeywordToIdentifierIfRequired(node) {
	            var token = _this.getTokenByRangeStart(node.range[0]);
	            if (token.type === 'Keyword') {
	                token.type = 'Identifier';
	            }
	        }
	    }
	};

	/**
	 * Parses a JS-file.
	 *
	 * @param {String} source
	 * @param {Object} esprima
	 * @param {Object} [esprimaOptions]
	 * @returns {Object}
	 */
	JsFile.parse = function(source, esprima, esprimaOptions) {
	    var finalEsprimaOptions = {
	        tolerant: true
	    };

	    if (esprimaOptions) {
	        for (var key in esprimaOptions) {
	            finalEsprimaOptions[key] = esprimaOptions[key];
	        }
	    }

	    // Set required options
	    finalEsprimaOptions.loc = true;
	    finalEsprimaOptions.range = true;
	    finalEsprimaOptions.comment = true;
	    finalEsprimaOptions.tokens = true;
	    finalEsprimaOptions.sourceType = 'module';

	    var hashbang = source.indexOf('#!') === 0;
	    var tree;

	    // Convert bin annotation to a comment
	    if (hashbang) {
	        source = '//' + source.substr(2);
	    }

	    var instrumentationData = {};
	    var hasInstrumentationData = false;
	    // Process special case code like iOS instrumentation imports: `#import 'abc.js';`
	    source = source.replace(/^#!?[^\n]+\n/gm, function(str, pos) {
	        hasInstrumentationData = true;
	        instrumentationData[pos] = str.substring(0, str.length - 1);
	        return '//' + str.slice(2);
	    });

	    tree = esprima.parse(source, finalEsprimaOptions);

	    // Change the bin annotation comment
	    if (hashbang) {
	        tree.comments[0].type = 'Hashbang';
	        tree.comments[0].value = '#!' + tree.comments[0].value;
	    }

	    if (hasInstrumentationData) {
	        tree.comments.forEach(function(token) {
	            var rangeStart = token.range[0];
	            if (instrumentationData.hasOwnProperty(rangeStart)) {
	                token.type = 'InstrumentationDirective';
	                token.value = instrumentationData[rangeStart];
	            }
	        });
	    }

	    return tree;
	};

	module.exports = JsFile;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var estraverse = __webpack_require__(41);

	module.exports = {
	    iterate: iterate
	};

	function iterate(node, cb) {
	    if ('type' in node) {
	        estraverse.traverse(node, {
	            enter: function(node, parent) {
	                var parentCollection = [];

	                // parentCollection support
	                var path = this.path();
	                if (path) {
	                    var collectionKey;
	                    while (path.length > 0) {
	                        var pathElement = path.pop();
	                        if (typeof pathElement === 'string') {
	                            collectionKey = pathElement;
	                            break;
	                        }
	                    }

	                    parentCollection = parent[collectionKey];
	                    if (!Array.isArray(parentCollection)) {
	                        parentCollection = [parentCollection];
	                    }
	                }

	                if (cb(node, parent, parentCollection) === false) {
	                    return estraverse.VisitorOption.Skip;
	                }
	            },
	            keys: {
	                JSXIdentifier: [],
	                JSXNamespacedName: ['namespace', 'name'],
	                JSXMemberExpression: ['object', 'property'],
	                JSXEmptyExpression: [],
	                JSXExpressionContainer: ['expression'],
	                JSXElement: ['openingElement', 'closingElement', 'children'],
	                JSXClosingElement: ['name'],
	                JSXOpeningElement: ['name', 'attributes'],
	                JSXAttribute: ['name', 'value'],
	                JSXSpreadAttribute: ['argument'],
	                JSXText: null,
	                XJSIdentifier: [],
	                XJSNamespacedName: ['namespace', 'name'],
	                XJSMemberExpression: ['object', 'property'],
	                XJSEmptyExpression: [],
	                XJSExpressionContainer: ['expression'],
	                XJSElement: ['openingElement', 'closingElement', 'children'],
	                XJSClosingElement: ['name'],
	                XJSOpeningElement: ['name', 'attributes'],
	                XJSAttribute: ['name', 'value'],
	                XJSSpreadAttribute: ['argument'],
	                XJSText: null
	            }
	        });
	    }
	}


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	/*jslint vars:false, bitwise:true*/
	/*jshint indent:4*/
	/*global exports:true, define:true*/
	(function (root, factory) {
	    'use strict';

	    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
	    // and plain browser loading,
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== 'undefined') {
	        factory(exports);
	    } else {
	        factory((root.estraverse = {}));
	    }
	}(this, function clone(exports) {
	    'use strict';

	    var Syntax,
	        isArray,
	        VisitorOption,
	        VisitorKeys,
	        objectCreate,
	        objectKeys,
	        BREAK,
	        SKIP,
	        REMOVE;

	    function ignoreJSHintError() { }

	    isArray = Array.isArray;
	    if (!isArray) {
	        isArray = function isArray(array) {
	            return Object.prototype.toString.call(array) === '[object Array]';
	        };
	    }

	    function deepCopy(obj) {
	        var ret = {}, key, val;
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                val = obj[key];
	                if (typeof val === 'object' && val !== null) {
	                    ret[key] = deepCopy(val);
	                } else {
	                    ret[key] = val;
	                }
	            }
	        }
	        return ret;
	    }

	    function shallowCopy(obj) {
	        var ret = {}, key;
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    ignoreJSHintError(shallowCopy);

	    // based on LLVM libc++ upper_bound / lower_bound
	    // MIT License

	    function upperBound(array, func) {
	        var diff, len, i, current;

	        len = array.length;
	        i = 0;

	        while (len) {
	            diff = len >>> 1;
	            current = i + diff;
	            if (func(array[current])) {
	                len = diff;
	            } else {
	                i = current + 1;
	                len -= diff + 1;
	            }
	        }
	        return i;
	    }

	    function lowerBound(array, func) {
	        var diff, len, i, current;

	        len = array.length;
	        i = 0;

	        while (len) {
	            diff = len >>> 1;
	            current = i + diff;
	            if (func(array[current])) {
	                i = current + 1;
	                len -= diff + 1;
	            } else {
	                len = diff;
	            }
	        }
	        return i;
	    }
	    ignoreJSHintError(lowerBound);

	    objectCreate = Object.create || (function () {
	        function F() { }

	        return function (o) {
	            F.prototype = o;
	            return new F();
	        };
	    })();

	    objectKeys = Object.keys || function (o) {
	        var keys = [], key;
	        for (key in o) {
	            keys.push(key);
	        }
	        return keys;
	    };

	    function extend(to, from) {
	        var keys = objectKeys(from), key, i, len;
	        for (i = 0, len = keys.length; i < len; i += 1) {
	            key = keys[i];
	            to[key] = from[key];
	        }
	        return to;
	    }

	    Syntax = {
	        AssignmentExpression: 'AssignmentExpression',
	        ArrayExpression: 'ArrayExpression',
	        ArrayPattern: 'ArrayPattern',
	        ArrowFunctionExpression: 'ArrowFunctionExpression',
	        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
	        BlockStatement: 'BlockStatement',
	        BinaryExpression: 'BinaryExpression',
	        BreakStatement: 'BreakStatement',
	        CallExpression: 'CallExpression',
	        CatchClause: 'CatchClause',
	        ClassBody: 'ClassBody',
	        ClassDeclaration: 'ClassDeclaration',
	        ClassExpression: 'ClassExpression',
	        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
	        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
	        ConditionalExpression: 'ConditionalExpression',
	        ContinueStatement: 'ContinueStatement',
	        DebuggerStatement: 'DebuggerStatement',
	        DirectiveStatement: 'DirectiveStatement',
	        DoWhileStatement: 'DoWhileStatement',
	        EmptyStatement: 'EmptyStatement',
	        ExportBatchSpecifier: 'ExportBatchSpecifier',
	        ExportDeclaration: 'ExportDeclaration',
	        ExportSpecifier: 'ExportSpecifier',
	        ExpressionStatement: 'ExpressionStatement',
	        ForStatement: 'ForStatement',
	        ForInStatement: 'ForInStatement',
	        ForOfStatement: 'ForOfStatement',
	        FunctionDeclaration: 'FunctionDeclaration',
	        FunctionExpression: 'FunctionExpression',
	        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
	        Identifier: 'Identifier',
	        IfStatement: 'IfStatement',
	        ImportDeclaration: 'ImportDeclaration',
	        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	        ImportSpecifier: 'ImportSpecifier',
	        Literal: 'Literal',
	        LabeledStatement: 'LabeledStatement',
	        LogicalExpression: 'LogicalExpression',
	        MemberExpression: 'MemberExpression',
	        MethodDefinition: 'MethodDefinition',
	        ModuleSpecifier: 'ModuleSpecifier',
	        NewExpression: 'NewExpression',
	        ObjectExpression: 'ObjectExpression',
	        ObjectPattern: 'ObjectPattern',
	        Program: 'Program',
	        Property: 'Property',
	        ReturnStatement: 'ReturnStatement',
	        SequenceExpression: 'SequenceExpression',
	        SpreadElement: 'SpreadElement',
	        SwitchStatement: 'SwitchStatement',
	        SwitchCase: 'SwitchCase',
	        TaggedTemplateExpression: 'TaggedTemplateExpression',
	        TemplateElement: 'TemplateElement',
	        TemplateLiteral: 'TemplateLiteral',
	        ThisExpression: 'ThisExpression',
	        ThrowStatement: 'ThrowStatement',
	        TryStatement: 'TryStatement',
	        UnaryExpression: 'UnaryExpression',
	        UpdateExpression: 'UpdateExpression',
	        VariableDeclaration: 'VariableDeclaration',
	        VariableDeclarator: 'VariableDeclarator',
	        WhileStatement: 'WhileStatement',
	        WithStatement: 'WithStatement',
	        YieldExpression: 'YieldExpression'
	    };

	    VisitorKeys = {
	        AssignmentExpression: ['left', 'right'],
	        ArrayExpression: ['elements'],
	        ArrayPattern: ['elements'],
	        ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],
	        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
	        BlockStatement: ['body'],
	        BinaryExpression: ['left', 'right'],
	        BreakStatement: ['label'],
	        CallExpression: ['callee', 'arguments'],
	        CatchClause: ['param', 'body'],
	        ClassBody: ['body'],
	        ClassDeclaration: ['id', 'body', 'superClass'],
	        ClassExpression: ['id', 'body', 'superClass'],
	        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
	        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
	        ConditionalExpression: ['test', 'consequent', 'alternate'],
	        ContinueStatement: ['label'],
	        DebuggerStatement: [],
	        DirectiveStatement: [],
	        DoWhileStatement: ['body', 'test'],
	        EmptyStatement: [],
	        ExportBatchSpecifier: [],
	        ExportDeclaration: ['declaration', 'specifiers', 'source'],
	        ExportSpecifier: ['id', 'name'],
	        ExpressionStatement: ['expression'],
	        ForStatement: ['init', 'test', 'update', 'body'],
	        ForInStatement: ['left', 'right', 'body'],
	        ForOfStatement: ['left', 'right', 'body'],
	        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
	        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
	        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
	        Identifier: [],
	        IfStatement: ['test', 'consequent', 'alternate'],
	        ImportDeclaration: ['specifiers', 'source'],
	        ImportDefaultSpecifier: ['id'],
	        ImportNamespaceSpecifier: ['id'],
	        ImportSpecifier: ['id', 'name'],
	        Literal: [],
	        LabeledStatement: ['label', 'body'],
	        LogicalExpression: ['left', 'right'],
	        MemberExpression: ['object', 'property'],
	        MethodDefinition: ['key', 'value'],
	        ModuleSpecifier: [],
	        NewExpression: ['callee', 'arguments'],
	        ObjectExpression: ['properties'],
	        ObjectPattern: ['properties'],
	        Program: ['body'],
	        Property: ['key', 'value'],
	        ReturnStatement: ['argument'],
	        SequenceExpression: ['expressions'],
	        SpreadElement: ['argument'],
	        SwitchStatement: ['discriminant', 'cases'],
	        SwitchCase: ['test', 'consequent'],
	        TaggedTemplateExpression: ['tag', 'quasi'],
	        TemplateElement: [],
	        TemplateLiteral: ['quasis', 'expressions'],
	        ThisExpression: [],
	        ThrowStatement: ['argument'],
	        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
	        UnaryExpression: ['argument'],
	        UpdateExpression: ['argument'],
	        VariableDeclaration: ['declarations'],
	        VariableDeclarator: ['id', 'init'],
	        WhileStatement: ['test', 'body'],
	        WithStatement: ['object', 'body'],
	        YieldExpression: ['argument']
	    };

	    // unique id
	    BREAK = {};
	    SKIP = {};
	    REMOVE = {};

	    VisitorOption = {
	        Break: BREAK,
	        Skip: SKIP,
	        Remove: REMOVE
	    };

	    function Reference(parent, key) {
	        this.parent = parent;
	        this.key = key;
	    }

	    Reference.prototype.replace = function replace(node) {
	        this.parent[this.key] = node;
	    };

	    Reference.prototype.remove = function remove() {
	        if (isArray(this.parent)) {
	            this.parent.splice(this.key, 1);
	            return true;
	        } else {
	            this.replace(null);
	            return false;
	        }
	    };

	    function Element(node, path, wrap, ref) {
	        this.node = node;
	        this.path = path;
	        this.wrap = wrap;
	        this.ref = ref;
	    }

	    function Controller() { }

	    // API:
	    // return property path array from root to current node
	    Controller.prototype.path = function path() {
	        var i, iz, j, jz, result, element;

	        function addToPath(result, path) {
	            if (isArray(path)) {
	                for (j = 0, jz = path.length; j < jz; ++j) {
	                    result.push(path[j]);
	                }
	            } else {
	                result.push(path);
	            }
	        }

	        // root node
	        if (!this.__current.path) {
	            return null;
	        }

	        // first node is sentinel, second node is root element
	        result = [];
	        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
	            element = this.__leavelist[i];
	            addToPath(result, element.path);
	        }
	        addToPath(result, this.__current.path);
	        return result;
	    };

	    // API:
	    // return type of current node
	    Controller.prototype.type = function () {
	        var node = this.current();
	        return node.type || this.__current.wrap;
	    };

	    // API:
	    // return array of parent elements
	    Controller.prototype.parents = function parents() {
	        var i, iz, result;

	        // first node is sentinel
	        result = [];
	        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
	            result.push(this.__leavelist[i].node);
	        }

	        return result;
	    };

	    // API:
	    // return current node
	    Controller.prototype.current = function current() {
	        return this.__current.node;
	    };

	    Controller.prototype.__execute = function __execute(callback, element) {
	        var previous, result;

	        result = undefined;

	        previous  = this.__current;
	        this.__current = element;
	        this.__state = null;
	        if (callback) {
	            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
	        }
	        this.__current = previous;

	        return result;
	    };

	    // API:
	    // notify control skip / break
	    Controller.prototype.notify = function notify(flag) {
	        this.__state = flag;
	    };

	    // API:
	    // skip child nodes of current node
	    Controller.prototype.skip = function () {
	        this.notify(SKIP);
	    };

	    // API:
	    // break traversals
	    Controller.prototype['break'] = function () {
	        this.notify(BREAK);
	    };

	    // API:
	    // remove node
	    Controller.prototype.remove = function () {
	        this.notify(REMOVE);
	    };

	    Controller.prototype.__initialize = function(root, visitor) {
	        this.visitor = visitor;
	        this.root = root;
	        this.__worklist = [];
	        this.__leavelist = [];
	        this.__current = null;
	        this.__state = null;
	        this.__fallback = visitor.fallback === 'iteration';
	        this.__keys = VisitorKeys;
	        if (visitor.keys) {
	            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
	        }
	    };

	    function isNode(node) {
	        if (node == null) {
	            return false;
	        }
	        return typeof node === 'object' && typeof node.type === 'string';
	    }

	    function isProperty(nodeType, key) {
	        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
	    }

	    Controller.prototype.traverse = function traverse(root, visitor) {
	        var worklist,
	            leavelist,
	            element,
	            node,
	            nodeType,
	            ret,
	            key,
	            current,
	            current2,
	            candidates,
	            candidate,
	            sentinel;

	        this.__initialize(root, visitor);

	        sentinel = {};

	        // reference
	        worklist = this.__worklist;
	        leavelist = this.__leavelist;

	        // initialize
	        worklist.push(new Element(root, null, null, null));
	        leavelist.push(new Element(null, null, null, null));

	        while (worklist.length) {
	            element = worklist.pop();

	            if (element === sentinel) {
	                element = leavelist.pop();

	                ret = this.__execute(visitor.leave, element);

	                if (this.__state === BREAK || ret === BREAK) {
	                    return;
	                }
	                continue;
	            }

	            if (element.node) {

	                ret = this.__execute(visitor.enter, element);

	                if (this.__state === BREAK || ret === BREAK) {
	                    return;
	                }

	                worklist.push(sentinel);
	                leavelist.push(element);

	                if (this.__state === SKIP || ret === SKIP) {
	                    continue;
	                }

	                node = element.node;
	                nodeType = element.wrap || node.type;
	                candidates = this.__keys[nodeType];
	                if (!candidates) {
	                    if (this.__fallback) {
	                        candidates = objectKeys(node);
	                    } else {
	                        throw new Error('Unknown node type ' + nodeType + '.');
	                    }
	                }

	                current = candidates.length;
	                while ((current -= 1) >= 0) {
	                    key = candidates[current];
	                    candidate = node[key];
	                    if (!candidate) {
	                        continue;
	                    }

	                    if (isArray(candidate)) {
	                        current2 = candidate.length;
	                        while ((current2 -= 1) >= 0) {
	                            if (!candidate[current2]) {
	                                continue;
	                            }
	                            if (isProperty(nodeType, candidates[current])) {
	                                element = new Element(candidate[current2], [key, current2], 'Property', null);
	                            } else if (isNode(candidate[current2])) {
	                                element = new Element(candidate[current2], [key, current2], null, null);
	                            } else {
	                                continue;
	                            }
	                            worklist.push(element);
	                        }
	                    } else if (isNode(candidate)) {
	                        worklist.push(new Element(candidate, key, null, null));
	                    }
	                }
	            }
	        }
	    };

	    Controller.prototype.replace = function replace(root, visitor) {
	        function removeElem(element) {
	            var i,
	                key,
	                nextElem,
	                parent;

	            if (element.ref.remove()) {
	                // When the reference is an element of an array.
	                key = element.ref.key;
	                parent = element.ref.parent;

	                // If removed from array, then decrease following items' keys.
	                i = worklist.length;
	                while (i--) {
	                    nextElem = worklist[i];
	                    if (nextElem.ref && nextElem.ref.parent === parent) {
	                        if  (nextElem.ref.key < key) {
	                            break;
	                        }
	                        --nextElem.ref.key;
	                    }
	                }
	            }
	        }

	        var worklist,
	            leavelist,
	            node,
	            nodeType,
	            target,
	            element,
	            current,
	            current2,
	            candidates,
	            candidate,
	            sentinel,
	            outer,
	            key;

	        this.__initialize(root, visitor);

	        sentinel = {};

	        // reference
	        worklist = this.__worklist;
	        leavelist = this.__leavelist;

	        // initialize
	        outer = {
	            root: root
	        };
	        element = new Element(root, null, null, new Reference(outer, 'root'));
	        worklist.push(element);
	        leavelist.push(element);

	        while (worklist.length) {
	            element = worklist.pop();

	            if (element === sentinel) {
	                element = leavelist.pop();

	                target = this.__execute(visitor.leave, element);

	                // node may be replaced with null,
	                // so distinguish between undefined and null in this place
	                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
	                    // replace
	                    element.ref.replace(target);
	                }

	                if (this.__state === REMOVE || target === REMOVE) {
	                    removeElem(element);
	                }

	                if (this.__state === BREAK || target === BREAK) {
	                    return outer.root;
	                }
	                continue;
	            }

	            target = this.__execute(visitor.enter, element);

	            // node may be replaced with null,
	            // so distinguish between undefined and null in this place
	            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
	                // replace
	                element.ref.replace(target);
	                element.node = target;
	            }

	            if (this.__state === REMOVE || target === REMOVE) {
	                removeElem(element);
	                element.node = null;
	            }

	            if (this.__state === BREAK || target === BREAK) {
	                return outer.root;
	            }

	            // node may be null
	            node = element.node;
	            if (!node) {
	                continue;
	            }

	            worklist.push(sentinel);
	            leavelist.push(element);

	            if (this.__state === SKIP || target === SKIP) {
	                continue;
	            }

	            nodeType = element.wrap || node.type;
	            candidates = this.__keys[nodeType];
	            if (!candidates) {
	                if (this.__fallback) {
	                    candidates = objectKeys(node);
	                } else {
	                    throw new Error('Unknown node type ' + nodeType + '.');
	                }
	            }

	            current = candidates.length;
	            while ((current -= 1) >= 0) {
	                key = candidates[current];
	                candidate = node[key];
	                if (!candidate) {
	                    continue;
	                }

	                if (isArray(candidate)) {
	                    current2 = candidate.length;
	                    while ((current2 -= 1) >= 0) {
	                        if (!candidate[current2]) {
	                            continue;
	                        }
	                        if (isProperty(nodeType, candidates[current])) {
	                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
	                        } else if (isNode(candidate[current2])) {
	                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
	                        } else {
	                            continue;
	                        }
	                        worklist.push(element);
	                    }
	                } else if (isNode(candidate)) {
	                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
	                }
	            }
	        }

	        return outer.root;
	    };

	    function traverse(root, visitor) {
	        var controller = new Controller();
	        return controller.traverse(root, visitor);
	    }

	    function replace(root, visitor) {
	        var controller = new Controller();
	        return controller.replace(root, visitor);
	    }

	    function extendCommentRange(comment, tokens) {
	        var target;

	        target = upperBound(tokens, function search(token) {
	            return token.range[0] > comment.range[0];
	        });

	        comment.extendedRange = [comment.range[0], comment.range[1]];

	        if (target !== tokens.length) {
	            comment.extendedRange[1] = tokens[target].range[0];
	        }

	        target -= 1;
	        if (target >= 0) {
	            comment.extendedRange[0] = tokens[target].range[1];
	        }

	        return comment;
	    }

	    function attachComments(tree, providedComments, tokens) {
	        // At first, we should calculate extended comment ranges.
	        var comments = [], comment, len, i, cursor;

	        if (!tree.range) {
	            throw new Error('attachComments needs range information');
	        }

	        // tokens array is empty, we attach comments to tree as 'leadingComments'
	        if (!tokens.length) {
	            if (providedComments.length) {
	                for (i = 0, len = providedComments.length; i < len; i += 1) {
	                    comment = deepCopy(providedComments[i]);
	                    comment.extendedRange = [0, tree.range[0]];
	                    comments.push(comment);
	                }
	                tree.leadingComments = comments;
	            }
	            return tree;
	        }

	        for (i = 0, len = providedComments.length; i < len; i += 1) {
	            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
	        }

	        // This is based on John Freeman's implementation.
	        cursor = 0;
	        traverse(tree, {
	            enter: function (node) {
	                var comment;

	                while (cursor < comments.length) {
	                    comment = comments[cursor];
	                    if (comment.extendedRange[1] > node.range[0]) {
	                        break;
	                    }

	                    if (comment.extendedRange[1] === node.range[0]) {
	                        if (!node.leadingComments) {
	                            node.leadingComments = [];
	                        }
	                        node.leadingComments.push(comment);
	                        comments.splice(cursor, 1);
	                    } else {
	                        cursor += 1;
	                    }
	                }

	                // already out of owned node
	                if (cursor === comments.length) {
	                    return VisitorOption.Break;
	                }

	                if (comments[cursor].extendedRange[0] > node.range[1]) {
	                    return VisitorOption.Skip;
	                }
	            }
	        });

	        cursor = 0;
	        traverse(tree, {
	            leave: function (node) {
	                var comment;

	                while (cursor < comments.length) {
	                    comment = comments[cursor];
	                    if (node.range[1] < comment.extendedRange[0]) {
	                        break;
	                    }

	                    if (node.range[1] === comment.extendedRange[0]) {
	                        if (!node.trailingComments) {
	                            node.trailingComments = [];
	                        }
	                        node.trailingComments.push(comment);
	                        comments.splice(cursor, 1);
	                    } else {
	                        cursor += 1;
	                    }
	                }

	                // already out of owned node
	                if (cursor === comments.length) {
	                    return VisitorOption.Break;
	                }

	                if (comments[cursor].extendedRange[0] > node.range[1]) {
	                    return VisitorOption.Skip;
	                }
	            }
	        });

	        return tree;
	    }

	    exports.version = '1.8.1-dev';
	    exports.Syntax = Syntax;
	    exports.traverse = traverse;
	    exports.replace = replace;
	    exports.attachComments = attachComments;
	    exports.VisitorKeys = VisitorKeys;
	    exports.VisitorOption = VisitorOption;
	    exports.Controller = Controller;
	    exports.cloneEnvironment = function () { return clone({}); };

	    return exports;
	}));
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(23);
	var path = __webpack_require__(43);
	var minimatch = __webpack_require__(44);

	var BUILTIN_OPTIONS = {
	    plugins: true,
	    preset: true,
	    excludeFiles: true,
	    additionalRules: true,
	    fileExtensions: true,
	    maxErrors: true,
	    configPath: true,
	    esnext: true,
	    es3: true,
	    esprima: true,
	    esprimaOptions: true,
	    errorFilter: true,
	    verbose: true
	};

	/**
	 * JSCS Configuration.
	 * Browser/Rhino-compatible.
	 *
	 * @name Configuration
	 */
	function Configuration() {
	    this._presets = {};
	    this._rules = {};
	    this._configuredRules = [];
	    this._unsupportedRuleNames = [];
	    this._fileExtensions = ['.js'];
	    this._excludedFileMasks = [];
	    this._excludedFileMatchers = [];
	    this._ruleSettings = {};
	    this._maxErrors = null;
	    this._basePath = '.';
	    this._overrides = {};
	    this._presetName = null;
	    this._esnextEnabled = false;
	    this._es3Enabled = true;
	    this._esprima = null;
	    this._esprimaOptions = {};
	    this._errorFilter = null;
	    this._verbose = null;
	}

	/**
	 * Load settings from a configuration.
	 *
	 * @param {Object} config
	 */
	Configuration.prototype.load = function(config) {
	    this._throwNonCamelCaseErrorIfNeeded(config);

	    var overrides = this._overrides;
	    var currentConfig = {};

	    copyConfiguration(config, currentConfig);
	    copyConfiguration(overrides, currentConfig);

	    var ruleSettings = this._processConfig(currentConfig);
	    var processedSettings = {};

	    Object.keys(ruleSettings).forEach(function(optionName) {
	        var rule = this._rules[optionName];
	        if (rule) {
	            var optionValue = ruleSettings[optionName];
	            if (optionValue !== null) {
	                rule.configure(ruleSettings[optionName]);
	                this._configuredRules.push(rule);
	                processedSettings[optionName] = ruleSettings[optionName];
	            }
	        } else {
	            this._unsupportedRuleNames.push(optionName);
	        }
	    }, this);

	    this._ruleSettings = processedSettings;
	};

	/**
	 * Returns resulting configuration after preset is applied and options are processed.
	 *
	 * @return {Object}
	 */
	Configuration.prototype.getProcessedConfig = function() {
	    var result = {};
	    Object.keys(this._ruleSettings).forEach(function(key) {
	        result[key] = this._ruleSettings[key];
	    }, this);
	    result.excludeFiles = this._excludedFileMasks;
	    result.fileExtensions = this._fileExtensions;
	    result.maxErrors = this._maxErrors;
	    result.preset = this._presetName;
	    result.esnext = this._esnextEnabled;
	    result.es3 = this._es3Enabled;
	    result.esprima = this._esprima;
	    result.esprimaOptions = this._esprimaOptions;
	    result.errorFilter = this._errorFilter;
	    return result;
	};

	/**
	 * Returns list of configured rules.
	 *
	 * @returns {Rule[]}
	 */
	Configuration.prototype.getConfiguredRules = function() {
	    return this._configuredRules;
	};

	/**
	 * Returns the list of unsupported rule names.
	 *
	 * @return {String[]}
	 */
	Configuration.prototype.getUnsupportedRuleNames = function() {
	    return this._unsupportedRuleNames;
	};

	/**
	 * Returns excluded file mask list.
	 *
	 * @returns {String[]}
	 */
	Configuration.prototype.getExcludedFileMasks = function() {
	    return this._excludedFileMasks;
	};

	/**
	 * Returns `true` if specified file path is excluded.
	 *
	 * @param {String} filePath
	 * @returns {Boolean}
	 */
	Configuration.prototype.isFileExcluded = function(filePath) {
	    filePath = path.resolve(filePath);
	    return this._excludedFileMatchers.some(function(matcher) {
	        return matcher.match(filePath);
	    });
	};

	/**
	 * Returns file extension list.
	 *
	 * @returns {String[]}
	 */
	Configuration.prototype.getFileExtensions = function() {
	    return this._fileExtensions;
	};

	/**
	 * Returns maximal error count.
	 *
	 * @returns {Number|undefined}
	 */
	Configuration.prototype.getMaxErrors = function() {
	    return this._maxErrors;
	};

	/**
	 * Returns `true` if `esnext` option is enabled.
	 *
	 * @returns {Boolean}
	 */
	Configuration.prototype.isESNextEnabled = function() {
	    return this._esnextEnabled;
	};

	/**
	 * Returns `true` if `es3` option is enabled.
	 *
	 * @returns {Boolean}
	 */
	Configuration.prototype.isES3Enabled = function() {
	    return this._es3Enabled;
	};

	/**
	 * Returns `true` if `esprima` option is not null.
	 *
	 * @returns {Boolean}
	 */
	Configuration.prototype.hasCustomEsprima = function() {
	    return !!this._esprima;
	};

	/**
	 * Returns the custom esprima parser.
	 *
	 * @returns {Object|null}
	 */
	Configuration.prototype.getCustomEsprima = function() {
	    return this._esprima;
	};

	/**
	 * Returns verbose option.
	 *
	 * @returns {Object|null}
	 */
	Configuration.prototype.getVerbose = function() {
	    return this._verbose || false;
	};

	/**
	 * Returns custom Esprima options.
	 *
	 * @returns {Object}
	 */
	Configuration.prototype.getEsprimaOptions = function() {
	    return this._esprimaOptions;
	};

	/**
	 * Returns the loaded error filter.
	 *
	 * @returns {Function|null}
	 */
	Configuration.prototype.getErrorFilter = function() {
	    return this._errorFilter;
	};

	/**
	 * Returns base path.
	 *
	 * @returns {String}
	 */
	Configuration.prototype.getBasePath = function() {
	    return this._basePath;
	};

	/**
	 * Overrides specified settings.
	 *
	 * @param {String} overrides
	 */
	Configuration.prototype.override = function(overrides) {
	    Object.keys(overrides).forEach(function(key) {
	        this._overrides[key] = overrides[key];
	    }, this);
	};

	/**
	 * returns options, but not rules, from the provided config
	 *
	 * @param  {Object} config
	 * @returns {Object}
	 */
	Configuration.prototype._getOptionsFromConfig = function(config) {
	    return Object.keys(config).reduce(function(options, key) {
	        if (BUILTIN_OPTIONS[key]) {
	            options[key] = config[key];
	        }
	        return options;
	    }, {});
	};

	/**
	 * Processes configuration and returns config options.
	 *
	 * @param {Object} config
	 * @returns {Object}
	 */
	Configuration.prototype._processConfig = function(config) {
	    var ruleSettings = {};

	    // NOTE: options is a separate object to ensure that future options must be added
	    // to BUILTIN_OPTIONS to work, which also assures they aren't mistaken for a rule
	    var options = this._getOptionsFromConfig(config);

	    // Base path
	    if (options.configPath) {
	        assert(
	            typeof options.configPath === 'string',
	            '`configPath` option requires string value'
	        );
	        this._basePath = path.dirname(options.configPath);
	    }

	    // Load plugins
	    if (options.plugins) {
	        assert(Array.isArray(options.plugins), '`plugins` option requires array value');
	        options.plugins.forEach(this._loadPlugin, this);
	    }

	    // Apply presets
	    var presetName = options.preset;
	    if (presetName) {
	        this._presetName = presetName;
	        assert(typeof presetName === 'string', '`preset` option requires string value');
	        var presetData = this._presets[presetName];
	        assert(Boolean(presetData), 'Preset "' + presetName + '" does not exist');
	        var presetResult = this._processConfig(presetData);
	        Object.keys(presetResult).forEach(function(key) {
	            ruleSettings[key] = presetResult[key];
	        });
	    }

	    // File extensions
	    if (options.fileExtensions) {
	        assert(
	            typeof options.fileExtensions === 'string' || Array.isArray(options.fileExtensions),
	            '`fileExtensions` option requires string or array value'
	        );
	        this._fileExtensions = [].concat(options.fileExtensions).map(function(ext) {
	            return ext.toLowerCase();
	        });
	    }

	    // File excludes
	    if (options.excludeFiles) {
	        assert(Array.isArray(options.excludeFiles), '`excludeFiles` option requires array value');
	        this._excludedFileMasks = options.excludeFiles;
	        this._excludedFileMatchers = this._excludedFileMasks.map(function(fileMask) {
	            return new minimatch.Minimatch(path.resolve(this._basePath, fileMask), {
	                dot: true
	            });
	        }, this);
	    }

	    // Additional rules
	    if (options.additionalRules) {
	        assert(Array.isArray(options.additionalRules), '`additionalRules` option requires array value');
	        options.additionalRules.forEach(this._loadAdditionalRule, this);
	    }

	    if (options.hasOwnProperty('maxErrors')) {
	        var maxErrors = options.maxErrors === null ? null : Number(options.maxErrors);
	        assert(
	            maxErrors > 0 || isNaN(maxErrors) || maxErrors === null,
	            '`maxErrors` option requires number or null value'
	        );
	        this._maxErrors = maxErrors;
	    }

	    if (options.hasOwnProperty('esnext')) {
	        assert(
	            typeof options.esnext === 'boolean' || options.esnext === null,
	            '`esnext` option requires boolean or null value'
	        );
	        this._esnextEnabled = Boolean(options.esnext);
	    }

	    if (options.hasOwnProperty('es3')) {
	        assert(
	            typeof options.es3 === 'boolean' || options.es3 === null,
	            '`es3` option requires boolean or null value'
	        );
	        this._es3Enabled = Boolean(options.es3);
	    }

	    if (options.hasOwnProperty('esprima')) {
	        this._loadEsprima(options.esprima);
	    }

	    if (options.hasOwnProperty('esprimaOptions')) {
	        this._loadEsprimaOptions(options.esprimaOptions);
	    }

	    if (options.hasOwnProperty('errorFilter')) {
	        this._loadErrorFilter(options.errorFilter);
	    }

	    if (options.hasOwnProperty('verbose')) {
	        this._loadVerbose(options.verbose);
	    }

	    // NOTE: rule setting must come last in order to
	    // override any rules that are loaded from a preset
	    Object.keys(config).forEach(function(key) {
	        if (!BUILTIN_OPTIONS[key]) {
	            ruleSettings[key] = config[key];
	        }
	    });

	    return ruleSettings;
	};

	/**
	 * Loads plugin data.
	 *
	 * @param {function(Configuration)} plugin
	 * @protected
	 */
	Configuration.prototype._loadPlugin = function(plugin) {
	    assert(typeof plugin === 'function', '`plugin` should be a function');
	    plugin(this);
	};

	/**
	 * Loads an error filter.
	 *
	 * @param {Function|null} errorFilter
	 * @protected
	 */
	Configuration.prototype._loadErrorFilter = function(errorFilter) {
	    assert(
	        typeof errorFilter === 'function' ||
	        errorFilter === null,
	        '`errorFilter` option requires a function or null value'
	    );
	    this._errorFilter = errorFilter;
	};

	/**
	 * Loads verbose option.
	 *
	 * @param {Boolean|null} verbose
	 * @protected
	 */
	Configuration.prototype._loadVerbose = function(verbose) {
	    assert(
	        typeof verbose === 'boolean' || verbose === null,
	        '`verbose` option requires a boolean or null value'
	    );
	    this._verbose = verbose;
	};

	/**
	 * Loads a custom esprima.
	 *
	 * @param {Object|null} esprima
	 * @protected
	 */
	Configuration.prototype._loadEsprima = function(esprima) {
	    assert(
	        (esprima && typeof esprima.parse === 'function') ||
	        esprima === null,
	        '`esprima` option requires a null value or an object with a parse function'
	    );
	    this._esprima = esprima;
	};

	/**
	 * Loads custom Esprima options.
	 *
	 * @param {Object} esprimaOptions
	 * @protected
	 */
	Configuration.prototype._loadEsprimaOptions = function(esprimaOptions) {
	    assert(typeof esprimaOptions === 'object' && esprimaOptions !== null, '`esprimaOptions` should be an object');
	    this._esprimaOptions = esprimaOptions;
	};

	/**
	 * Includes plugin in the configuration environment.
	 *
	 * @param {function(Configuration)|*} plugin
	 */
	Configuration.prototype.usePlugin = function(plugin) {
	    this._loadPlugin(plugin);
	};

	/**
	 * Loads additional rule.
	 *
	 * @param {Rule} additionalRule
	 * @protected
	 */
	Configuration.prototype._loadAdditionalRule = function(additionalRule) {
	    assert(typeof additionalRule === 'object', '`additionalRule` should be an object');
	    this.registerRule(additionalRule);
	};

	/**
	 * Throws error for non camel-case options.
	 *
	 * @param {Object} ruleSettings
	 * @protected
	 */
	Configuration.prototype._throwNonCamelCaseErrorIfNeeded = function(ruleSettings) {
	    function symbolToUpperCase(s, symbol) {
	        return symbol.toUpperCase();
	    }
	    function fixSettings(originalSettings) {
	        var result = {};
	        Object.keys(originalSettings).forEach(function(key) {
	            var camelCaseName = key.replace(/_([a-zA-Z])/g, symbolToUpperCase);
	            var value = originalSettings[key];
	            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
	                value = fixSettings(value);
	            }
	            result[camelCaseName] = value;
	        });
	        return result;
	    }

	    Object.keys(ruleSettings).forEach(function(key) {
	        if (key.indexOf('_') !== -1) {
	            throw new Error(
	                'JSCS now accepts configuration options in camel case. Sorry for inconvenience. ' +
	                'On the bright side, we tried to convert your jscs config to camel case.\n' +
	                '----------------------------------------\n' +
	                JSON.stringify(fixSettings(ruleSettings), null, 4) +
	                '\n----------------------------------------\n'
	            );
	        }
	    });
	};

	/**
	 * Adds rule to the collection.
	 *
	 * @param {Rule|function} rule Rule instance or rule class.
	 */
	Configuration.prototype.registerRule = function(rule) {
	    if (typeof rule === 'function') {
	        var RuleClass = rule;
	        rule = new RuleClass();
	    }

	    var optionName = rule.getOptionName();
	    assert(!this._rules.hasOwnProperty(optionName), 'Rule "' + optionName + '" is already registered');
	    this._rules[optionName] = rule;
	};

	/**
	 * Returns list of registered rules.
	 *
	 * @returns {Rule[]}
	 */
	Configuration.prototype.getRegisteredRules = function() {
	    var rules = this._rules;
	    return Object.keys(rules).map(function(ruleOptionName) {
	        return rules[ruleOptionName];
	    });
	};

	/**
	 * Adds preset to the collection.
	 *
	 * @param {String} presetName
	 * @param {Object} presetConfig
	 */
	Configuration.prototype.registerPreset = function(presetName, presetConfig) {
	    this._presets[presetName] = presetConfig;
	};

	/**
	 * Returns registered presets object (key - preset name, value - preset content).
	 *
	 * @returns {Object}
	 */
	Configuration.prototype.getRegisteredPresets = function() {
	    return this._presets;
	};

	/**
	 * Returns `true` if preset with specified name exists.
	 *
	 * @param {String} presetName
	 * @return {Boolean}
	 */
	Configuration.prototype.hasPreset = function(presetName) {
	    return this._presets.hasOwnProperty(presetName);
	};

	/**
	 * Registers built-in Code Style cheking rules.
	 */
	Configuration.prototype.registerDefaultRules = function() {

	    /*
	        Important!
	        These rules are linked explicitly to keep browser-version supported.
	    */

	    this.registerRule(__webpack_require__(48));
	    this.registerRule(__webpack_require__(52));
	    this.registerRule(__webpack_require__(53));
	    this.registerRule(__webpack_require__(54));
	    this.registerRule(__webpack_require__(55));
	    this.registerRule(__webpack_require__(56));
	    this.registerRule(__webpack_require__(57));
	    this.registerRule(__webpack_require__(58));
	    this.registerRule(__webpack_require__(59));
	    this.registerRule(__webpack_require__(60));

	    /* deprecated rules */
	    this.registerRule(__webpack_require__(61));
	    this.registerRule(__webpack_require__(62));
	    this.registerRule(__webpack_require__(63));
	    this.registerRule(__webpack_require__(64));
	    this.registerRule(__webpack_require__(65));
	    /* deprecated rules (end) */

	    this.registerRule(__webpack_require__(66));
	    this.registerRule(__webpack_require__(67));
	    this.registerRule(__webpack_require__(68));
	    this.registerRule(__webpack_require__(69));
	    this.registerRule(__webpack_require__(70));
	    this.registerRule(__webpack_require__(71));
	    this.registerRule(__webpack_require__(72));
	    this.registerRule(__webpack_require__(73));
	    this.registerRule(__webpack_require__(74));
	    this.registerRule(__webpack_require__(75));
	    this.registerRule(__webpack_require__(76));
	    this.registerRule(__webpack_require__(77));
	    this.registerRule(__webpack_require__(78));
	    this.registerRule(__webpack_require__(79));
	    this.registerRule(__webpack_require__(80));
	    this.registerRule(__webpack_require__(81));
	    this.registerRule(__webpack_require__(82));
	    this.registerRule(__webpack_require__(83));
	    this.registerRule(__webpack_require__(84));
	    this.registerRule(__webpack_require__(85));
	    this.registerRule(__webpack_require__(86));
	    this.registerRule(__webpack_require__(87));
	    this.registerRule(__webpack_require__(88));
	    this.registerRule(__webpack_require__(89));
	    this.registerRule(__webpack_require__(90));
	    this.registerRule(__webpack_require__(91));
	    this.registerRule(__webpack_require__(92));
	    this.registerRule(__webpack_require__(93));
	    this.registerRule(__webpack_require__(94));
	    this.registerRule(__webpack_require__(95));
	    this.registerRule(__webpack_require__(96));
	    this.registerRule(__webpack_require__(97));
	    this.registerRule(__webpack_require__(98));
	    this.registerRule(__webpack_require__(99));
	    this.registerRule(__webpack_require__(100));
	    this.registerRule(__webpack_require__(101));
	    this.registerRule(__webpack_require__(102));

	    this.registerRule(__webpack_require__(103));
	    this.registerRule(__webpack_require__(104));

	    this.registerRule(__webpack_require__(105));
	    this.registerRule(__webpack_require__(106));
	    this.registerRule(__webpack_require__(107));
	    this.registerRule(__webpack_require__(108));
	    this.registerRule(__webpack_require__(109));
	    this.registerRule(__webpack_require__(110));

	    this.registerRule(__webpack_require__(111));
	    this.registerRule(__webpack_require__(112));

	    this.registerRule(__webpack_require__(113));
	    this.registerRule(__webpack_require__(114));

	    this.registerRule(__webpack_require__(115));
	    this.registerRule(__webpack_require__(116));

	    this.registerRule(__webpack_require__(117));

	    this.registerRule(__webpack_require__(118));
	    this.registerRule(__webpack_require__(119));

	    this.registerRule(__webpack_require__(120));
	    this.registerRule(__webpack_require__(121));

	    this.registerRule(__webpack_require__(122));
	    this.registerRule(__webpack_require__(123));

	    this.registerRule(__webpack_require__(124));
	    this.registerRule(__webpack_require__(125));

	    this.registerRule(__webpack_require__(126));
	    this.registerRule(__webpack_require__(127));

	    this.registerRule(__webpack_require__(128));
	    this.registerRule(__webpack_require__(129));

	    this.registerRule(__webpack_require__(130));
	    this.registerRule(__webpack_require__(131));

	    this.registerRule(__webpack_require__(132));
	    this.registerRule(__webpack_require__(133));
	    this.registerRule(__webpack_require__(134));
	    this.registerRule(__webpack_require__(135));
	    this.registerRule(__webpack_require__(136));
	    this.registerRule(__webpack_require__(137));
	    this.registerRule(__webpack_require__(138));
	    this.registerRule(__webpack_require__(139));
	    this.registerRule(__webpack_require__(140));
	    this.registerRule(__webpack_require__(141));

	    this.registerRule(__webpack_require__(142));
	    this.registerRule(__webpack_require__(143));

	    this.registerRule(__webpack_require__(144));
	    this.registerRule(__webpack_require__(145));
	    this.registerRule(__webpack_require__(146));

	    this.registerRule(__webpack_require__(147));

	    this.registerRule(__webpack_require__(148));

	    this.registerRule(__webpack_require__(149));

	    this.registerRule(__webpack_require__(150));
	    this.registerRule(__webpack_require__(151));

	    this.registerRule(__webpack_require__(152));
	    this.registerRule(__webpack_require__(153));
	    this.registerRule(__webpack_require__(154));
	    this.registerRule(__webpack_require__(156));

	    this.registerRule(__webpack_require__(157));
	    this.registerRule(__webpack_require__(158));

	    this.registerRule(__webpack_require__(159));
	    this.registerRule(__webpack_require__(162));

	    this.registerRule(__webpack_require__(164));
	    this.registerRule(__webpack_require__(165));

	    this.registerRule(__webpack_require__(166));
	    this.registerRule(__webpack_require__(167));

	    this.registerRule(__webpack_require__(168));
	    this.registerRule(__webpack_require__(169));

	    this.registerRule(__webpack_require__(170));
	    this.registerRule(__webpack_require__(171));

	    this.registerRule(__webpack_require__(172));
	    this.registerRule(__webpack_require__(173));

	    this.registerRule(__webpack_require__(174));

	    this.registerRule(__webpack_require__(175));

	    this.registerRule(__webpack_require__(176));

	    this.registerRule(__webpack_require__(177));

	    this.registerRule(__webpack_require__(178));
	};

	/**
	 * Registers built-in Code Style cheking presets.
	 */
	Configuration.prototype.registerDefaultPresets = function() {
	    // https://github.com/airbnb/javascript
	    this.registerPreset('airbnb', __webpack_require__(179));

	    // http://javascript.crockford.com/code.html
	    this.registerPreset('crockford', __webpack_require__(180));

	    // https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml
	    this.registerPreset('google', __webpack_require__(181));

	    // http://gruntjs.com/contributing#syntax
	    this.registerPreset('grunt', __webpack_require__(182));

	    // https://contribute.jquery.org/style-guide/js/
	    this.registerPreset('jquery', __webpack_require__(183));

	    // https://github.com/mrdoob/three.js/wiki/Mr.doob's-Code-Style%E2%84%A2
	    this.registerPreset('mdcs', __webpack_require__(184));

	    // https://github.com/felixge/node-style-guide#nodejs-style-guide
	    this.registerPreset('node-style-guide', __webpack_require__(185));

	    // https://www.mediawiki.org/wiki/Manual:Coding_conventions/JavaScript
	    this.registerPreset('wikimedia', __webpack_require__(186));

	    // https://make.wordpress.org/core/handbook/coding-standards/javascript/
	    this.registerPreset('wordpress', __webpack_require__(187));

	    // https://github.com/yandex/codestyle/blob/master/javascript.md
	    this.registerPreset('yandex', __webpack_require__(188));
	};

	module.exports = Configuration;

	function copyConfiguration(source, dest) {
	    Object.keys(source).forEach(function(key) {
	        dest[key] = source[key];
	    });
	    if (source.configPath) {
	        dest.configPath = source.configPath;
	    }
	}


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = minimatch
	minimatch.Minimatch = Minimatch

	var path = { sep: '/' }
	try {
	  path = __webpack_require__(43)
	} catch (er) {}

	var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
	var expand = __webpack_require__(45)

	// any single thing other than /
	// don't need to escape / when using new RegExp()
	var qmark = '[^/]'

	// * => any number of characters
	var star = qmark + '*?'

	// ** when dots are allowed.  Anything goes, except .. and .
	// not (^ or / followed by one or two dots followed by $ or /),
	// followed by anything, any number of times.
	var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

	// not a ^ or / followed by a dot,
	// followed by anything, any number of times.
	var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

	// characters that need to be escaped in RegExp.
	var reSpecials = charSet('().*{}+?[]^$\\!')

	// "abc" -> { a:true, b:true, c:true }
	function charSet (s) {
	  return s.split('').reduce(function (set, c) {
	    set[c] = true
	    return set
	  }, {})
	}

	// normalizes slashes.
	var slashSplit = /\/+/

	minimatch.filter = filter
	function filter (pattern, options) {
	  options = options || {}
	  return function (p, i, list) {
	    return minimatch(p, pattern, options)
	  }
	}

	function ext (a, b) {
	  a = a || {}
	  b = b || {}
	  var t = {}
	  Object.keys(b).forEach(function (k) {
	    t[k] = b[k]
	  })
	  Object.keys(a).forEach(function (k) {
	    t[k] = a[k]
	  })
	  return t
	}

	minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return minimatch

	  var orig = minimatch

	  var m = function minimatch (p, pattern, options) {
	    return orig.minimatch(p, pattern, ext(def, options))
	  }

	  m.Minimatch = function Minimatch (pattern, options) {
	    return new orig.Minimatch(pattern, ext(def, options))
	  }

	  return m
	}

	Minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return Minimatch
	  return minimatch.defaults(def).Minimatch
	}

	function minimatch (p, pattern, options) {
	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }

	  if (!options) options = {}

	  // shortcut: comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    return false
	  }

	  // "" only matches ""
	  if (pattern.trim() === '') return p === ''

	  return new Minimatch(pattern, options).match(p)
	}

	function Minimatch (pattern, options) {
	  if (!(this instanceof Minimatch)) {
	    return new Minimatch(pattern, options)
	  }

	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }

	  if (!options) options = {}
	  pattern = pattern.trim()

	  // windows support: need to use /, not \
	  if (path.sep !== '/') {
	    pattern = pattern.split(path.sep).join('/')
	  }

	  this.options = options
	  this.set = []
	  this.pattern = pattern
	  this.regexp = null
	  this.negate = false
	  this.comment = false
	  this.empty = false

	  // make the set of regexps etc.
	  this.make()
	}

	Minimatch.prototype.debug = function () {}

	Minimatch.prototype.make = make
	function make () {
	  // don't do it more than once.
	  if (this._made) return

	  var pattern = this.pattern
	  var options = this.options

	  // empty patterns and comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    this.comment = true
	    return
	  }
	  if (!pattern) {
	    this.empty = true
	    return
	  }

	  // step 1: figure out negation, etc.
	  this.parseNegate()

	  // step 2: expand braces
	  var set = this.globSet = this.braceExpand()

	  if (options.debug) this.debug = console.error

	  this.debug(this.pattern, set)

	  // step 3: now we have a set, so turn each one into a series of path-portion
	  // matching patterns.
	  // These will be regexps, except in the case of "**", which is
	  // set to the GLOBSTAR object for globstar behavior,
	  // and will not contain any / characters
	  set = this.globParts = set.map(function (s) {
	    return s.split(slashSplit)
	  })

	  this.debug(this.pattern, set)

	  // glob --> regexps
	  set = set.map(function (s, si, set) {
	    return s.map(this.parse, this)
	  }, this)

	  this.debug(this.pattern, set)

	  // filter out everything that didn't compile properly.
	  set = set.filter(function (s) {
	    return s.indexOf(false) === -1
	  })

	  this.debug(this.pattern, set)

	  this.set = set
	}

	Minimatch.prototype.parseNegate = parseNegate
	function parseNegate () {
	  var pattern = this.pattern
	  var negate = false
	  var options = this.options
	  var negateOffset = 0

	  if (options.nonegate) return

	  for (var i = 0, l = pattern.length
	    ; i < l && pattern.charAt(i) === '!'
	    ; i++) {
	    negate = !negate
	    negateOffset++
	  }

	  if (negateOffset) this.pattern = pattern.substr(negateOffset)
	  this.negate = negate
	}

	// Brace expansion:
	// a{b,c}d -> abd acd
	// a{b,}c -> abc ac
	// a{0..3}d -> a0d a1d a2d a3d
	// a{b,c{d,e}f}g -> abg acdfg acefg
	// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
	//
	// Invalid sets are not expanded.
	// a{2..}b -> a{2..}b
	// a{b}c -> a{b}c
	minimatch.braceExpand = function (pattern, options) {
	  return braceExpand(pattern, options)
	}

	Minimatch.prototype.braceExpand = braceExpand

	function braceExpand (pattern, options) {
	  if (!options) {
	    if (this instanceof Minimatch) {
	      options = this.options
	    } else {
	      options = {}
	    }
	  }

	  pattern = typeof pattern === 'undefined'
	    ? this.pattern : pattern

	  if (typeof pattern === 'undefined') {
	    throw new Error('undefined pattern')
	  }

	  if (options.nobrace ||
	    !pattern.match(/\{.*\}/)) {
	    // shortcut. no need to expand.
	    return [pattern]
	  }

	  return expand(pattern)
	}

	// parse a component of the expanded set.
	// At this point, no pattern may contain "/" in it
	// so we're going to return a 2d array, where each entry is the full
	// pattern, split on '/', and then turned into a regular expression.
	// A regexp is made at the end which joins each array with an
	// escaped /, and another full one which joins each regexp with |.
	//
	// Following the lead of Bash 4.1, note that "**" only has special meaning
	// when it is the *only* thing in a path portion.  Otherwise, any series
	// of * is equivalent to a single *.  Globstar behavior is enabled by
	// default, and can be disabled by setting options.noglobstar.
	Minimatch.prototype.parse = parse
	var SUBPARSE = {}
	function parse (pattern, isSub) {
	  var options = this.options

	  // shortcuts
	  if (!options.noglobstar && pattern === '**') return GLOBSTAR
	  if (pattern === '') return ''

	  var re = ''
	  var hasMagic = !!options.nocase
	  var escaping = false
	  // ? => one single character
	  var patternListStack = []
	  var negativeLists = []
	  var plType
	  var stateChar
	  var inClass = false
	  var reClassStart = -1
	  var classStart = -1
	  // . and .. never match anything that doesn't start with .,
	  // even when options.dot is set.
	  var patternStart = pattern.charAt(0) === '.' ? '' // anything
	  // not (start or / followed by . or .. followed by / or end)
	  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
	  : '(?!\\.)'
	  var self = this

	  function clearStateChar () {
	    if (stateChar) {
	      // we had some state-tracking character
	      // that wasn't consumed by this pass.
	      switch (stateChar) {
	        case '*':
	          re += star
	          hasMagic = true
	        break
	        case '?':
	          re += qmark
	          hasMagic = true
	        break
	        default:
	          re += '\\' + stateChar
	        break
	      }
	      self.debug('clearStateChar %j %j', stateChar, re)
	      stateChar = false
	    }
	  }

	  for (var i = 0, len = pattern.length, c
	    ; (i < len) && (c = pattern.charAt(i))
	    ; i++) {
	    this.debug('%s\t%s %s %j', pattern, i, re, c)

	    // skip over any that are escaped.
	    if (escaping && reSpecials[c]) {
	      re += '\\' + c
	      escaping = false
	      continue
	    }

	    switch (c) {
	      case '/':
	        // completely not allowed, even escaped.
	        // Should already be path-split by now.
	        return false

	      case '\\':
	        clearStateChar()
	        escaping = true
	      continue

	      // the various stateChar values
	      // for the "extglob" stuff.
	      case '?':
	      case '*':
	      case '+':
	      case '@':
	      case '!':
	        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

	        // all of those are literals inside a class, except that
	        // the glob [!a] means [^a] in regexp
	        if (inClass) {
	          this.debug('  in class')
	          if (c === '!' && i === classStart + 1) c = '^'
	          re += c
	          continue
	        }

	        // if we already have a stateChar, then it means
	        // that there was something like ** or +? in there.
	        // Handle the stateChar, then proceed with this one.
	        self.debug('call clearStateChar %j', stateChar)
	        clearStateChar()
	        stateChar = c
	        // if extglob is disabled, then +(asdf|foo) isn't a thing.
	        // just clear the statechar *now*, rather than even diving into
	        // the patternList stuff.
	        if (options.noext) clearStateChar()
	      continue

	      case '(':
	        if (inClass) {
	          re += '('
	          continue
	        }

	        if (!stateChar) {
	          re += '\\('
	          continue
	        }

	        plType = stateChar
	        patternListStack.push({
	          type: plType,
	          start: i - 1,
	          reStart: re.length
	        })
	        // negation is (?:(?!js)[^/]*)
	        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
	        this.debug('plType %j %j', stateChar, re)
	        stateChar = false
	      continue

	      case ')':
	        if (inClass || !patternListStack.length) {
	          re += '\\)'
	          continue
	        }

	        clearStateChar()
	        hasMagic = true
	        re += ')'
	        var pl = patternListStack.pop()
	        plType = pl.type
	        // negation is (?:(?!js)[^/]*)
	        // The others are (?:<pattern>)<type>
	        switch (plType) {
	          case '!':
	            negativeLists.push(pl)
	            re += ')[^/]*?)'
	            pl.reEnd = re.length
	            break
	          case '?':
	          case '+':
	          case '*':
	            re += plType
	            break
	          case '@': break // the default anyway
	        }
	      continue

	      case '|':
	        if (inClass || !patternListStack.length || escaping) {
	          re += '\\|'
	          escaping = false
	          continue
	        }

	        clearStateChar()
	        re += '|'
	      continue

	      // these are mostly the same in regexp and glob
	      case '[':
	        // swallow any state-tracking char before the [
	        clearStateChar()

	        if (inClass) {
	          re += '\\' + c
	          continue
	        }

	        inClass = true
	        classStart = i
	        reClassStart = re.length
	        re += c
	      continue

	      case ']':
	        //  a right bracket shall lose its special
	        //  meaning and represent itself in
	        //  a bracket expression if it occurs
	        //  first in the list.  -- POSIX.2 2.8.3.2
	        if (i === classStart + 1 || !inClass) {
	          re += '\\' + c
	          escaping = false
	          continue
	        }

	        // handle the case where we left a class open.
	        // "[z-a]" is valid, equivalent to "\[z-a\]"
	        if (inClass) {
	          // split where the last [ was, make sure we don't have
	          // an invalid re. if so, re-walk the contents of the
	          // would-be class to re-translate any characters that
	          // were passed through as-is
	          // TODO: It would probably be faster to determine this
	          // without a try/catch and a new RegExp, but it's tricky
	          // to do safely.  For now, this is safe and works.
	          var cs = pattern.substring(classStart + 1, i)
	          try {
	            RegExp('[' + cs + ']')
	          } catch (er) {
	            // not a valid class!
	            var sp = this.parse(cs, SUBPARSE)
	            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
	            hasMagic = hasMagic || sp[1]
	            inClass = false
	            continue
	          }
	        }

	        // finish up the class.
	        hasMagic = true
	        inClass = false
	        re += c
	      continue

	      default:
	        // swallow any state char that wasn't consumed
	        clearStateChar()

	        if (escaping) {
	          // no need
	          escaping = false
	        } else if (reSpecials[c]
	          && !(c === '^' && inClass)) {
	          re += '\\'
	        }

	        re += c

	    } // switch
	  } // for

	  // handle the case where we left a class open.
	  // "[abc" is valid, equivalent to "\[abc"
	  if (inClass) {
	    // split where the last [ was, and escape it
	    // this is a huge pita.  We now have to re-walk
	    // the contents of the would-be class to re-translate
	    // any characters that were passed through as-is
	    cs = pattern.substr(classStart + 1)
	    sp = this.parse(cs, SUBPARSE)
	    re = re.substr(0, reClassStart) + '\\[' + sp[0]
	    hasMagic = hasMagic || sp[1]
	  }

	  // handle the case where we had a +( thing at the *end*
	  // of the pattern.
	  // each pattern list stack adds 3 chars, and we need to go through
	  // and escape any | chars that were passed through as-is for the regexp.
	  // Go through and escape them, taking care not to double-escape any
	  // | chars that were already escaped.
	  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
	    var tail = re.slice(pl.reStart + 3)
	    // maybe some even number of \, then maybe 1 \, followed by a |
	    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
	      if (!$2) {
	        // the | isn't already escaped, so escape it.
	        $2 = '\\'
	      }

	      // need to escape all those slashes *again*, without escaping the
	      // one that we need for escaping the | character.  As it works out,
	      // escaping an even number of slashes can be done by simply repeating
	      // it exactly after itself.  That's why this trick works.
	      //
	      // I am sorry that you have to see this.
	      return $1 + $1 + $2 + '|'
	    })

	    this.debug('tail=%j\n   %s', tail, tail)
	    var t = pl.type === '*' ? star
	      : pl.type === '?' ? qmark
	      : '\\' + pl.type

	    hasMagic = true
	    re = re.slice(0, pl.reStart) + t + '\\(' + tail
	  }

	  // handle trailing things that only matter at the very end.
	  clearStateChar()
	  if (escaping) {
	    // trailing \\
	    re += '\\\\'
	  }

	  // only need to apply the nodot start if the re starts with
	  // something that could conceivably capture a dot
	  var addPatternStart = false
	  switch (re.charAt(0)) {
	    case '.':
	    case '[':
	    case '(': addPatternStart = true
	  }

	  // Hack to work around lack of negative lookbehind in JS
	  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
	  // like 'a.xyz.yz' doesn't match.  So, the first negative
	  // lookahead, has to look ALL the way ahead, to the end of
	  // the pattern.
	  for (var n = negativeLists.length - 1; n > -1; n--) {
	    var nl = negativeLists[n]

	    var nlBefore = re.slice(0, nl.reStart)
	    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
	    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
	    var nlAfter = re.slice(nl.reEnd)

	    nlLast += nlAfter

	    // Handle nested stuff like *(*.js|!(*.json)), where open parens
	    // mean that we should *not* include the ) in the bit that is considered
	    // "after" the negated section.
	    var openParensBefore = nlBefore.split('(').length - 1
	    var cleanAfter = nlAfter
	    for (i = 0; i < openParensBefore; i++) {
	      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
	    }
	    nlAfter = cleanAfter

	    var dollar = ''
	    if (nlAfter === '' && isSub !== SUBPARSE) {
	      dollar = '$'
	    }
	    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
	    re = newRe
	  }

	  // if the re is not "" at this point, then we need to make sure
	  // it doesn't match against an empty path part.
	  // Otherwise a/* will match a/, which it should not.
	  if (re !== '' && hasMagic) {
	    re = '(?=.)' + re
	  }

	  if (addPatternStart) {
	    re = patternStart + re
	  }

	  // parsing just a piece of a larger pattern.
	  if (isSub === SUBPARSE) {
	    return [re, hasMagic]
	  }

	  // skip the regexp for non-magical patterns
	  // unescape anything in it, though, so that it'll be
	  // an exact match against a file etc.
	  if (!hasMagic) {
	    return globUnescape(pattern)
	  }

	  var flags = options.nocase ? 'i' : ''
	  var regExp = new RegExp('^' + re + '$', flags)

	  regExp._glob = pattern
	  regExp._src = re

	  return regExp
	}

	minimatch.makeRe = function (pattern, options) {
	  return new Minimatch(pattern, options || {}).makeRe()
	}

	Minimatch.prototype.makeRe = makeRe
	function makeRe () {
	  if (this.regexp || this.regexp === false) return this.regexp

	  // at this point, this.set is a 2d array of partial
	  // pattern strings, or "**".
	  //
	  // It's better to use .match().  This function shouldn't
	  // be used, really, but it's pretty convenient sometimes,
	  // when you just want to work with a regex.
	  var set = this.set

	  if (!set.length) {
	    this.regexp = false
	    return this.regexp
	  }
	  var options = this.options

	  var twoStar = options.noglobstar ? star
	    : options.dot ? twoStarDot
	    : twoStarNoDot
	  var flags = options.nocase ? 'i' : ''

	  var re = set.map(function (pattern) {
	    return pattern.map(function (p) {
	      return (p === GLOBSTAR) ? twoStar
	      : (typeof p === 'string') ? regExpEscape(p)
	      : p._src
	    }).join('\\\/')
	  }).join('|')

	  // must match entire pattern
	  // ending in a * or ** will make it less strict.
	  re = '^(?:' + re + ')$'

	  // can match anything, as long as it's not this.
	  if (this.negate) re = '^(?!' + re + ').*$'

	  try {
	    this.regexp = new RegExp(re, flags)
	  } catch (ex) {
	    this.regexp = false
	  }
	  return this.regexp
	}

	minimatch.match = function (list, pattern, options) {
	  options = options || {}
	  var mm = new Minimatch(pattern, options)
	  list = list.filter(function (f) {
	    return mm.match(f)
	  })
	  if (mm.options.nonull && !list.length) {
	    list.push(pattern)
	  }
	  return list
	}

	Minimatch.prototype.match = match
	function match (f, partial) {
	  this.debug('match', f, this.pattern)
	  // short-circuit in the case of busted things.
	  // comments, etc.
	  if (this.comment) return false
	  if (this.empty) return f === ''

	  if (f === '/' && partial) return true

	  var options = this.options

	  // windows: need to use /, not \
	  if (path.sep !== '/') {
	    f = f.split(path.sep).join('/')
	  }

	  // treat the test path as a set of pathparts.
	  f = f.split(slashSplit)
	  this.debug(this.pattern, 'split', f)

	  // just ONE of the pattern sets in this.set needs to match
	  // in order for it to be valid.  If negating, then just one
	  // match means that we have failed.
	  // Either way, return on the first hit.

	  var set = this.set
	  this.debug(this.pattern, 'set', set)

	  // Find the basename of the path by looking for the last non-empty segment
	  var filename
	  var i
	  for (i = f.length - 1; i >= 0; i--) {
	    filename = f[i]
	    if (filename) break
	  }

	  for (i = 0; i < set.length; i++) {
	    var pattern = set[i]
	    var file = f
	    if (options.matchBase && pattern.length === 1) {
	      file = [filename]
	    }
	    var hit = this.matchOne(file, pattern, partial)
	    if (hit) {
	      if (options.flipNegate) return true
	      return !this.negate
	    }
	  }

	  // didn't get any hits.  this is success if it's a negative
	  // pattern, failure otherwise.
	  if (options.flipNegate) return false
	  return this.negate
	}

	// set partial to true to test if, for example,
	// "/a/b" matches the start of "/*/b/*/d"
	// Partial means, if you run out of file before you run
	// out of pattern, then that's fine, as long as all
	// the parts match.
	Minimatch.prototype.matchOne = function (file, pattern, partial) {
	  var options = this.options

	  this.debug('matchOne',
	    { 'this': this, file: file, pattern: pattern })

	  this.debug('matchOne', file.length, pattern.length)

	  for (var fi = 0,
	      pi = 0,
	      fl = file.length,
	      pl = pattern.length
	      ; (fi < fl) && (pi < pl)
	      ; fi++, pi++) {
	    this.debug('matchOne loop')
	    var p = pattern[pi]
	    var f = file[fi]

	    this.debug(pattern, p, f)

	    // should be impossible.
	    // some invalid regexp stuff in the set.
	    if (p === false) return false

	    if (p === GLOBSTAR) {
	      this.debug('GLOBSTAR', [pattern, p, f])

	      // "**"
	      // a/**/b/**/c would match the following:
	      // a/b/x/y/z/c
	      // a/x/y/z/b/c
	      // a/b/x/b/x/c
	      // a/b/c
	      // To do this, take the rest of the pattern after
	      // the **, and see if it would match the file remainder.
	      // If so, return success.
	      // If not, the ** "swallows" a segment, and try again.
	      // This is recursively awful.
	      //
	      // a/**/b/**/c matching a/b/x/y/z/c
	      // - a matches a
	      // - doublestar
	      //   - matchOne(b/x/y/z/c, b/**/c)
	      //     - b matches b
	      //     - doublestar
	      //       - matchOne(x/y/z/c, c) -> no
	      //       - matchOne(y/z/c, c) -> no
	      //       - matchOne(z/c, c) -> no
	      //       - matchOne(c, c) yes, hit
	      var fr = fi
	      var pr = pi + 1
	      if (pr === pl) {
	        this.debug('** at the end')
	        // a ** at the end will just swallow the rest.
	        // We have found a match.
	        // however, it will not swallow /.x, unless
	        // options.dot is set.
	        // . and .. are *never* matched by **, for explosively
	        // exponential reasons.
	        for (; fi < fl; fi++) {
	          if (file[fi] === '.' || file[fi] === '..' ||
	            (!options.dot && file[fi].charAt(0) === '.')) return false
	        }
	        return true
	      }

	      // ok, let's see if we can swallow whatever we can.
	      while (fr < fl) {
	        var swallowee = file[fr]

	        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

	        // XXX remove this slice.  Just pass the start index.
	        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
	          this.debug('globstar found match!', fr, fl, swallowee)
	          // found a match.
	          return true
	        } else {
	          // can't swallow "." or ".." ever.
	          // can only swallow ".foo" when explicitly asked.
	          if (swallowee === '.' || swallowee === '..' ||
	            (!options.dot && swallowee.charAt(0) === '.')) {
	            this.debug('dot detected!', file, fr, pattern, pr)
	            break
	          }

	          // ** swallows a segment, and continue.
	          this.debug('globstar swallow a segment, and continue')
	          fr++
	        }
	      }

	      // no match was found.
	      // However, in partial mode, we can't say this is necessarily over.
	      // If there's more *pattern* left, then
	      if (partial) {
	        // ran out of file
	        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
	        if (fr === fl) return true
	      }
	      return false
	    }

	    // something other than **
	    // non-magic patterns just have to match exactly
	    // patterns with magic have been turned into regexps.
	    var hit
	    if (typeof p === 'string') {
	      if (options.nocase) {
	        hit = f.toLowerCase() === p.toLowerCase()
	      } else {
	        hit = f === p
	      }
	      this.debug('string match', p, f, hit)
	    } else {
	      hit = f.match(p)
	      this.debug('pattern match', p, f, hit)
	    }

	    if (!hit) return false
	  }

	  // Note: ending in / means that we'll get a final ""
	  // at the end of the pattern.  This can only match a
	  // corresponding "" at the end of the file.
	  // If the file ends in /, then it can only match a
	  // a pattern that ends in /, unless the pattern just
	  // doesn't have any more for it. But, a/b/ should *not*
	  // match "a/b/*", even though "" matches against the
	  // [^/]*? pattern, except in partial mode, where it might
	  // simply not be reached yet.
	  // However, a/b/ should still satisfy a/*

	  // now either we fell off the end of the pattern, or we're done.
	  if (fi === fl && pi === pl) {
	    // ran out of pattern and filename at the same time.
	    // an exact hit!
	    return true
	  } else if (fi === fl) {
	    // ran out of file, but still had pattern left.
	    // this is ok if we're doing the match as part of
	    // a glob fs traversal.
	    return partial
	  } else if (pi === pl) {
	    // ran out of pattern, still have file left.
	    // this is only acceptable if we're on the very last
	    // empty segment of a file with a trailing slash.
	    // a/* should match a/b/
	    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
	    return emptyFileEnd
	  }

	  // should be unreachable.
	  throw new Error('wtf?')
	}

	// replace stuff like \* with *
	function globUnescape (s) {
	  return s.replace(/\\(.)/g, '$1')
	}

	function regExpEscape (s) {
	  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
	}


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var concatMap = __webpack_require__(46);
	var balanced = __webpack_require__(47);

	module.exports = expandTop;

	var escSlash = '\0SLASH'+Math.random()+'\0';
	var escOpen = '\0OPEN'+Math.random()+'\0';
	var escClose = '\0CLOSE'+Math.random()+'\0';
	var escComma = '\0COMMA'+Math.random()+'\0';
	var escPeriod = '\0PERIOD'+Math.random()+'\0';

	function numeric(str) {
	  return parseInt(str, 10) == str
	    ? parseInt(str, 10)
	    : str.charCodeAt(0);
	}

	function escapeBraces(str) {
	  return str.split('\\\\').join(escSlash)
	            .split('\\{').join(escOpen)
	            .split('\\}').join(escClose)
	            .split('\\,').join(escComma)
	            .split('\\.').join(escPeriod);
	}

	function unescapeBraces(str) {
	  return str.split(escSlash).join('\\')
	            .split(escOpen).join('{')
	            .split(escClose).join('}')
	            .split(escComma).join(',')
	            .split(escPeriod).join('.');
	}


	// Basically just str.split(","), but handling cases
	// where we have nested braced sections, which should be
	// treated as individual members, like {a,{b,c},d}
	function parseCommaParts(str) {
	  if (!str)
	    return [''];

	  var parts = [];
	  var m = balanced('{', '}', str);

	  if (!m)
	    return str.split(',');

	  var pre = m.pre;
	  var body = m.body;
	  var post = m.post;
	  var p = pre.split(',');

	  p[p.length-1] += '{' + body + '}';
	  var postParts = parseCommaParts(post);
	  if (post.length) {
	    p[p.length-1] += postParts.shift();
	    p.push.apply(p, postParts);
	  }

	  parts.push.apply(parts, p);

	  return parts;
	}

	function expandTop(str) {
	  if (!str)
	    return [];

	  // I don't know why Bash 4.3 does this, but it does.
	  // Anything starting with {} will have the first two bytes preserved
	  // but *only* at the top level, so {},a}b will not expand to anything,
	  // but a{},b}c will be expanded to [a}c,abc].
	  // One could argue that this is a bug in Bash, but since the goal of
	  // this module is to match Bash's rules, we escape a leading {}
	  if (str.substr(0, 2) === '{}') {
	    str = '\\{\\}' + str.substr(2);
	  }

	  return expand(escapeBraces(str), true).map(unescapeBraces);
	}

	function identity(e) {
	  return e;
	}

	function embrace(str) {
	  return '{' + str + '}';
	}
	function isPadded(el) {
	  return /^-?0\d/.test(el);
	}

	function lte(i, y) {
	  return i <= y;
	}
	function gte(i, y) {
	  return i >= y;
	}

	function expand(str, isTop) {
	  var expansions = [];

	  var m = balanced('{', '}', str);
	  if (!m || /\$$/.test(m.pre)) return [str];

	  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
	  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
	  var isSequence = isNumericSequence || isAlphaSequence;
	  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
	  if (!isSequence && !isOptions) {
	    // {a},b}
	    if (m.post.match(/,.*\}/)) {
	      str = m.pre + '{' + m.body + escClose + m.post;
	      return expand(str);
	    }
	    return [str];
	  }

	  var n;
	  if (isSequence) {
	    n = m.body.split(/\.\./);
	  } else {
	    n = parseCommaParts(m.body);
	    if (n.length === 1) {
	      // x{{a,b}}y ==> x{a}y x{b}y
	      n = expand(n[0], false).map(embrace);
	      if (n.length === 1) {
	        var post = m.post.length
	          ? expand(m.post, false)
	          : [''];
	        return post.map(function(p) {
	          return m.pre + n[0] + p;
	        });
	      }
	    }
	  }

	  // at this point, n is the parts, and we know it's not a comma set
	  // with a single entry.

	  // no need to expand pre, since it is guaranteed to be free of brace-sets
	  var pre = m.pre;
	  var post = m.post.length
	    ? expand(m.post, false)
	    : [''];

	  var N;

	  if (isSequence) {
	    var x = numeric(n[0]);
	    var y = numeric(n[1]);
	    var width = Math.max(n[0].length, n[1].length)
	    var incr = n.length == 3
	      ? Math.abs(numeric(n[2]))
	      : 1;
	    var test = lte;
	    var reverse = y < x;
	    if (reverse) {
	      incr *= -1;
	      test = gte;
	    }
	    var pad = n.some(isPadded);

	    N = [];

	    for (var i = x; test(i, y); i += incr) {
	      var c;
	      if (isAlphaSequence) {
	        c = String.fromCharCode(i);
	        if (c === '\\')
	          c = '';
	      } else {
	        c = String(i);
	        if (pad) {
	          var need = width - c.length;
	          if (need > 0) {
	            var z = new Array(need + 1).join('0');
	            if (i < 0)
	              c = '-' + z + c.slice(1);
	            else
	              c = z + c;
	          }
	        }
	      }
	      N.push(c);
	    }
	  } else {
	    N = concatMap(n, function(el) { return expand(el, false) });
	  }

	  for (var j = 0; j < N.length; j++) {
	    for (var k = 0; k < post.length; k++) {
	      var expansion = pre + N[j] + post[k];
	      if (!isTop || isSequence || expansion)
	        expansions.push(expansion);
	    }
	  }

	  return expansions;
	}



/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports = function (xs, fn) {
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        var x = fn(xs[i], i);
	        if (isArray(x)) res.push.apply(res, x);
	        else res.push(x);
	    }
	    return res;
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 47 */
/***/ function(module, exports) {

	module.exports = balanced;
	function balanced(a, b, str) {
	  if (a instanceof RegExp) a = maybeMatch(a, str);
	  if (b instanceof RegExp) b = maybeMatch(b, str);

	  var r = range(a, b, str);

	  return r && {
	    start: r[0],
	    end: r[1],
	    pre: str.slice(0, r[0]),
	    body: str.slice(r[0] + a.length, r[1]),
	    post: str.slice(r[1] + b.length)
	  };
	}

	function maybeMatch(reg, str) {
	  var m = str.match(reg);
	  return m ? m[0] : null;
	}

	balanced.range = range;
	function range(a, b, str) {
	  var begs, beg, left, right, result;
	  var ai = str.indexOf(a);
	  var bi = str.indexOf(b, ai + 1);
	  var i = ai;

	  if (ai >= 0 && bi > 0) {
	    begs = [];
	    left = str.length;

	    while (i >= 0 && !result) {
	      if (i == ai) {
	        begs.push(i);
	        ai = str.indexOf(a, i + 1);
	      } else if (begs.length == 1) {
	        result = [ begs.pop(), bi ];
	      } else {
	        beg = begs.pop();
	        if (beg < left) {
	          left = beg;
	          right = bi;
	        }

	        bi = str.indexOf(b, i + 1);
	      }

	      i = ai < bi && ai >= 0 ? ai : bi;
	    }

	    if (begs.length) {
	      result = [ left, right ];
	    }
	  }

	  return result;
	}


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires curly braces after statements.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted keywords or `true` to require curly braces after the following keywords:
	 *
	 * JSHint: [`curly`](http://jshint.com/docs/options/#curly)
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireCurlyBraces": [
	 *     "if",
	 *     "else",
	 *     "for",
	 *     "while",
	 *     "do",
	 *     "try",
	 *     "catch",
	 *     "case",
	 *     "default"
	 * ]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * if (x) {
	 *     x++;
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (x) x++;
	 * ```
	 */

	var assert = __webpack_require__(23);
	var defaultKeywords = __webpack_require__(49).curlyBracedKeywords;

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(statementTypes) {
	        assert(
	            Array.isArray(statementTypes) || statementTypes === true,
	            this.getOptionName() + ' option requires array or true value'
	        );

	        if (statementTypes === true) {
	            statementTypes = defaultKeywords;
	        }

	        this._typeIndex = {};
	        for (var i = 0, l = statementTypes.length; i < l; i++) {
	            this._typeIndex[statementTypes[i]] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'requireCurlyBraces';
	    },

	    check: function(file, errors) {

	        function isNotABlockStatement(node) {
	            return node && node.type !== 'BlockStatement';
	        }

	        function addError(typeString, entity) {
	            errors.add(
	                typeString + ' statement without curly braces',
	                entity.loc.start.line,
	                entity.loc.start.column
	            );
	        }

	        function checkBody(type, typeString) {
	            file.iterateNodesByType(type, function(node) {
	                if (isNotABlockStatement(node.body)) {
	                    addError(typeString, node);
	                }
	            });
	        }

	        var typeIndex = this._typeIndex;

	        if (typeIndex['if'] || typeIndex['else']) {
	            file.iterateNodesByType('IfStatement', function(node) {
	                if (typeIndex['if'] && isNotABlockStatement(node.consequent)) {
	                    addError('If', node);
	                }
	                if (typeIndex['else'] && isNotABlockStatement(node.alternate) &&
	                    node.alternate.type !== 'IfStatement') {
	                    addError('Else', file.getPrevToken(file.getFirstNodeToken(node.alternate)));
	                }
	            });
	        }

	        if (typeIndex['case'] || typeIndex['default']) {
	            file.iterateNodesByType('SwitchCase', function(node) {
	                // empty case statement
	                if (node.consequent.length === 0) {
	                    return;
	                }

	                if (node.consequent.length === 1 && node.consequent[0].type === 'BlockStatement') {
	                    return;
	                }

	                if (node.test === null && typeIndex['default']) {
	                    addError('Default', node);
	                }

	                if (node.test !== null && typeIndex['case']) {
	                    addError('Case', node);
	                }
	            });
	        }

	        if (typeIndex['while']) {
	            checkBody('WhileStatement', 'While');
	        }

	        if (typeIndex['for']) {
	            checkBody('ForStatement', 'For');
	            checkBody('ForInStatement', 'For in');
	        }

	        if (typeIndex['do']) {
	            checkBody('DoWhileStatement', 'Do while');
	        }

	        if (typeIndex['with']) {
	            checkBody('WithStatement', 'With');
	        }
	    }

	};


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var path = __webpack_require__(43);
	var Vow = __webpack_require__(50);

	// 7.5.2, 7.6.1 Reserved words
	var ES3_KEYWORDS = {
	    'break': true,
	    'case': true,
	    'catch': true,
	    'continue': true,
	    'default': true,
	    'delete': true,
	    'do': true,
	    'else': true,
	    'false': true,
	    'finally': true,
	    'for': true,
	    'function': true,
	    'if': true,
	    'in': true,
	    'instanceof': true,
	    'new': true,
	    'null': true,
	    'return': true,
	    'switch': true,
	    'this': true,
	    'throw': true,
	    'true': true,
	    'try': true,
	    'typeof': true,
	    'var': true,
	    'void': true,
	    'while': true,
	    'with': true
	};

	// 7.5.3 Future Reserved Words
	var ES3_FUTURE_RESERVED_WORDS = {
	    'abstract': true,
	    'boolean': true,
	    'byte': true,
	    'char': true,
	    'class': true,
	    'const': true,
	    'debugger': true,
	    'double': true,
	    'enum': true,
	    'export': true,
	    'extends': true,
	    'final': true,
	    'float': true,
	    'goto': true,
	    'implements': true,
	    'import': true,
	    'int': true,
	    'interface': true,
	    'long': true,
	    'native': true,
	    'package': true,
	    'private': true,
	    'protected': true,
	    'public': true,
	    'short': true,
	    'static': true,
	    'super': true,
	    'synchronized': true,
	    'throws': true,
	    'transient': true,
	    'volatile': true
	};

	var IDENTIFIER_NAME_RE = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;

	var TRAILING_UNDERSCORES_RE = /(^_+|_+$)/g;

	var SNAKE_CASE_RE = /^([a-z$][a-z0-9$]+)(_[a-z0-9$]+)+$/i;

	/**
	 * All keywords where spaces are a stylistic choice
	 * @type {Array}
	 */
	exports.spacedKeywords = [
	    'do',
	    'for',
	    'if',
	    'else',
	    'switch',
	    'case',
	    'try',
	    'catch',
	    'finally',
	    'void',
	    'while',
	    'with',
	    'return',
	    'typeof',
	    'function'
	];

	/**
	 * All keywords where curly braces are a stylistic choice
	 * @type {Array}
	 */
	exports.curlyBracedKeywords = [
	    'if',
	    'else',
	    'for',
	    'while',
	    'do',
	    'case',
	    'default',
	    'with'
	];

	/**
	 * Returns true if word is keyword in ECMAScript 3 specification.
	 *
	 * @param {String} word
	 * @returns {Boolean}
	 */
	exports.isEs3Keyword = function(word) {
	    return Boolean(ES3_KEYWORDS[word]);
	};

	/**
	 * Returns true if word is future reserved word in ECMAScript 3 specification.
	 *
	 * @param {String} word
	 * @returns {Boolean}
	 */
	exports.isEs3FutureReservedWord = function(word) {
	    return Boolean(ES3_FUTURE_RESERVED_WORDS[word]);
	};

	/**
	 * Returns true if name is valid identifier name.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 */
	exports.isValidIdentifierName = function(name) {
	    return IDENTIFIER_NAME_RE.test(name);
	};

	/**
	 * Snake case tester
	 *
	 * @param {String} name
	 * @return {Boolean}
	 */
	exports.isSnakeCased = function(name) {
	    return SNAKE_CASE_RE.test(name);
	};

	/**
	 * Returns the function expression node if the provided node is an iffe,
	 * other returns undefined.
	 *
	 * @param  {Object} node
	 * @return {?Object}
	 */
	exports.getFunctionNodeFromIIFE = function(node) {
	    if (node.type !== 'CallExpression') {
	        return null;
	    }

	    var callee = node.callee;

	    if (callee.type === 'FunctionExpression') {
	        return callee;
	    }

	    if (callee.type === 'MemberExpression' &&
	        callee.object.type === 'FunctionExpression' &&
	        callee.property.type === 'Identifier' &&
	        (callee.property.name === 'call' || callee.property.name === 'apply')
	    ) {
	        return callee.object;
	    }

	    return null;
	};

	/**
	 * Trims leading and trailing underscores
	 *
	 * @param {String} name
	 * @return {String}
	 */
	exports.trimUnderscores = function(name) {
	    var res = name.replace(TRAILING_UNDERSCORES_RE, '');
	    return res ? res : name;
	};

	/**
	 * Whether or not the given path is relative
	 * @param  {String}  path
	 * @return {Boolean}
	 */
	exports.isRelativePath = function(path) {
	    // Logic from: https://github.com/joyent/node/blob/4f1ae11a62b97052bc83756f8cb8700cc1f61661/lib/module.js#L237
	    var start = path.substring(0, 2);
	    return start === './' || start === '..';
	};

	/**
	 * Resolves a relative filepath against the supplied base path
	 * or just returns the filepath if not relative
	 *
	 * @param  {String} filepath
	 * @param  {String} basePath
	 * @return {String}
	 */
	exports.normalizePath = function(filepath, basePath) {
	    if (this.isRelativePath(filepath)) {
	        return path.resolve(basePath, filepath);
	    }

	    return filepath;
	};

	/**
	 * Wraps a function such that you can interact with a promise and not a
	 * node-style callback.
	 *
	 * @param  {Function} fn - function that expects a node-style callback
	 * @return {Function} When invoked with arguments, returns a promise resolved/rejected
	 *                    based on the results of the wrapped node-style callback
	 */
	exports.promisify = function(fn) {
	    return function() {
	        var deferred = Vow.defer();
	        var args = [].slice.call(arguments);

	        args.push(function(err, result) {
	            if (err) {
	                deferred.reject(err);
	            } else {
	                deferred.resolve(result);
	            }
	        });

	        fn.apply(null, args);

	        return deferred.promise();
	    };
	};

	/**
	 * All possible binary operators supported by JSCS
	 * @type {Array}
	 */
	exports.binaryOperators = [

	    // assignment operators
	    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
	    '&=', '|=', '^=',

	    '+', '-', '*', '/', '%', '<<', '>>', '>>>', '&',
	    '|', '^', '&&', '||', '===', '==', '>=',
	    '<=', '<', '>', '!=', '!==',

	    ','
	];

	/**
	 * Increment and decrement operators
	 * @type {Array}
	 */
	exports.incrementAndDecrementOperators = ['++', '--'];

	/**
	 * All possible unary operators supported by JSCS
	 * @type {Array}
	 */
	exports.unaryOperators = ['-', '+', '!', '~'].concat(exports.incrementAndDecrementOperators);

	/**
	 * All possible operators support by JSCS
	 * @type {Array}
	 */
	exports.operators = exports.binaryOperators.concat(exports.unaryOperators);


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate, process) {/**
	 * @module vow
	 * @author Filatov Dmitry <dfilatov@yandex-team.ru>
	 * @version 0.4.13
	 * @license
	 * Dual licensed under the MIT and GPL licenses:
	 *   * http://www.opensource.org/licenses/mit-license.php
	 *   * http://www.gnu.org/licenses/gpl.html
	 */

	(function(global) {

	var undef,
	    nextTick = (function() {
	        var fns = [],
	            enqueueFn = function(fn) {
	                fns.push(fn);
	                return fns.length === 1;
	            },
	            callFns = function() {
	                var fnsToCall = fns, i = 0, len = fns.length;
	                fns = [];
	                while(i < len) {
	                    fnsToCall[i++]();
	                }
	            };

	        if(typeof setImmediate === 'function') { // ie10, nodejs >= 0.10
	            return function(fn) {
	                enqueueFn(fn) && setImmediate(callFns);
	            };
	        }

	        if(typeof process === 'object' && process.nextTick) { // nodejs < 0.10
	            return function(fn) {
	                enqueueFn(fn) && process.nextTick(callFns);
	            };
	        }

	        var MutationObserver = global.MutationObserver || global.WebKitMutationObserver; // modern browsers
	        if(MutationObserver) {
	            var num = 1,
	                node = document.createTextNode('');

	            new MutationObserver(callFns).observe(node, { characterData : true });

	            return function(fn) {
	                enqueueFn(fn) && (node.data = (num *= -1));
	            };
	        }

	        if(global.postMessage) {
	            var isPostMessageAsync = true;
	            if(global.attachEvent) {
	                var checkAsync = function() {
	                        isPostMessageAsync = false;
	                    };
	                global.attachEvent('onmessage', checkAsync);
	                global.postMessage('__checkAsync', '*');
	                global.detachEvent('onmessage', checkAsync);
	            }

	            if(isPostMessageAsync) {
	                var msg = '__promise' + Math.random() + '_' +new Date,
	                    onMessage = function(e) {
	                        if(e.data === msg) {
	                            e.stopPropagation && e.stopPropagation();
	                            callFns();
	                        }
	                    };

	                global.addEventListener?
	                    global.addEventListener('message', onMessage, true) :
	                    global.attachEvent('onmessage', onMessage);

	                return function(fn) {
	                    enqueueFn(fn) && global.postMessage(msg, '*');
	                };
	            }
	        }

	        var doc = global.document;
	        if('onreadystatechange' in doc.createElement('script')) { // ie6-ie8
	            var createScript = function() {
	                    var script = doc.createElement('script');
	                    script.onreadystatechange = function() {
	                        script.parentNode.removeChild(script);
	                        script = script.onreadystatechange = null;
	                        callFns();
	                };
	                (doc.documentElement || doc.body).appendChild(script);
	            };

	            return function(fn) {
	                enqueueFn(fn) && createScript();
	            };
	        }

	        return function(fn) { // old browsers
	            enqueueFn(fn) && setTimeout(callFns, 0);
	        };
	    })(),
	    throwException = function(e) {
	        nextTick(function() {
	            throw e;
	        });
	    },
	    isFunction = function(obj) {
	        return typeof obj === 'function';
	    },
	    isObject = function(obj) {
	        return obj !== null && typeof obj === 'object';
	    },
	    toStr = Object.prototype.toString,
	    isArray = Array.isArray || function(obj) {
	        return toStr.call(obj) === '[object Array]';
	    },
	    getArrayKeys = function(arr) {
	        var res = [],
	            i = 0, len = arr.length;
	        while(i < len) {
	            res.push(i++);
	        }
	        return res;
	    },
	    getObjectKeys = Object.keys || function(obj) {
	        var res = [];
	        for(var i in obj) {
	            obj.hasOwnProperty(i) && res.push(i);
	        }
	        return res;
	    },
	    defineCustomErrorType = function(name) {
	        var res = function(message) {
	            this.name = name;
	            this.message = message;
	        };

	        res.prototype = new Error();

	        return res;
	    },
	    wrapOnFulfilled = function(onFulfilled, idx) {
	        return function(val) {
	            onFulfilled.call(this, val, idx);
	        };
	    };

	/**
	 * @class Deferred
	 * @exports vow:Deferred
	 * @description
	 * The `Deferred` class is used to encapsulate newly-created promise object along with functions that resolve, reject or notify it.
	 */

	/**
	 * @constructor
	 * @description
	 * You can use `vow.defer()` instead of using this constructor.
	 *
	 * `new vow.Deferred()` gives the same result as `vow.defer()`.
	 */
	var Deferred = function() {
	    this._promise = new Promise();
	};

	Deferred.prototype = /** @lends Deferred.prototype */{
	    /**
	     * Returns the corresponding promise.
	     *
	     * @returns {vow:Promise}
	     */
	    promise : function() {
	        return this._promise;
	    },

	    /**
	     * Resolves the corresponding promise with the given `value`.
	     *
	     * @param {*} value
	     *
	     * @example
	     * ```js
	     * var defer = vow.defer(),
	     *     promise = defer.promise();
	     *
	     * promise.then(function(value) {
	     *     // value is "'success'" here
	     * });
	     *
	     * defer.resolve('success');
	     * ```
	     */
	    resolve : function(value) {
	        this._promise.isResolved() || this._promise._resolve(value);
	    },

	    /**
	     * Rejects the corresponding promise with the given `reason`.
	     *
	     * @param {*} reason
	     *
	     * @example
	     * ```js
	     * var defer = vow.defer(),
	     *     promise = defer.promise();
	     *
	     * promise.fail(function(reason) {
	     *     // reason is "'something is wrong'" here
	     * });
	     *
	     * defer.reject('something is wrong');
	     * ```
	     */
	    reject : function(reason) {
	        if(this._promise.isResolved()) {
	            return;
	        }

	        if(vow.isPromise(reason)) {
	            reason = reason.then(function(val) {
	                var defer = vow.defer();
	                defer.reject(val);
	                return defer.promise();
	            });
	            this._promise._resolve(reason);
	        }
	        else {
	            this._promise._reject(reason);
	        }
	    },

	    /**
	     * Notifies the corresponding promise with the given `value`.
	     *
	     * @param {*} value
	     *
	     * @example
	     * ```js
	     * var defer = vow.defer(),
	     *     promise = defer.promise();
	     *
	     * promise.progress(function(value) {
	     *     // value is "'20%'", "'40%'" here
	     * });
	     *
	     * defer.notify('20%');
	     * defer.notify('40%');
	     * ```
	     */
	    notify : function(value) {
	        this._promise.isResolved() || this._promise._notify(value);
	    }
	};

	var PROMISE_STATUS = {
	    PENDING   : 0,
	    RESOLVED  : 1,
	    FULFILLED : 2,
	    REJECTED  : 3
	};

	/**
	 * @class Promise
	 * @exports vow:Promise
	 * @description
	 * The `Promise` class is used when you want to give to the caller something to subscribe to,
	 * but not the ability to resolve or reject the deferred.
	 */

	/**
	 * @constructor
	 * @param {Function} resolver See https://github.com/domenic/promises-unwrapping/blob/master/README.md#the-promise-constructor for details.
	 * @description
	 * You should use this constructor directly only if you are going to use `vow` as DOM Promises implementation.
	 * In other case you should use `vow.defer()` and `defer.promise()` methods.
	 * @example
	 * ```js
	 * function fetchJSON(url) {
	 *     return new vow.Promise(function(resolve, reject, notify) {
	 *         var xhr = new XMLHttpRequest();
	 *         xhr.open('GET', url);
	 *         xhr.responseType = 'json';
	 *         xhr.send();
	 *         xhr.onload = function() {
	 *             if(xhr.response) {
	 *                 resolve(xhr.response);
	 *             }
	 *             else {
	 *                 reject(new TypeError());
	 *             }
	 *         };
	 *     });
	 * }
	 * ```
	 */
	var Promise = function(resolver) {
	    this._value = undef;
	    this._status = PROMISE_STATUS.PENDING;

	    this._fulfilledCallbacks = [];
	    this._rejectedCallbacks = [];
	    this._progressCallbacks = [];

	    if(resolver) { // NOTE: see https://github.com/domenic/promises-unwrapping/blob/master/README.md
	        var _this = this,
	            resolverFnLen = resolver.length;

	        resolver(
	            function(val) {
	                _this.isResolved() || _this._resolve(val);
	            },
	            resolverFnLen > 1?
	                function(reason) {
	                    _this.isResolved() || _this._reject(reason);
	                } :
	                undef,
	            resolverFnLen > 2?
	                function(val) {
	                    _this.isResolved() || _this._notify(val);
	                } :
	                undef);
	    }
	};

	Promise.prototype = /** @lends Promise.prototype */ {
	    /**
	     * Returns the value of the fulfilled promise or the reason in case of rejection.
	     *
	     * @returns {*}
	     */
	    valueOf : function() {
	        return this._value;
	    },

	    /**
	     * Returns `true` if the promise is resolved.
	     *
	     * @returns {Boolean}
	     */
	    isResolved : function() {
	        return this._status !== PROMISE_STATUS.PENDING;
	    },

	    /**
	     * Returns `true` if the promise is fulfilled.
	     *
	     * @returns {Boolean}
	     */
	    isFulfilled : function() {
	        return this._status === PROMISE_STATUS.FULFILLED;
	    },

	    /**
	     * Returns `true` if the promise is rejected.
	     *
	     * @returns {Boolean}
	     */
	    isRejected : function() {
	        return this._status === PROMISE_STATUS.REJECTED;
	    },

	    /**
	     * Adds reactions to the promise.
	     *
	     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
	     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
	     * @param {Object} [ctx] Context of the callbacks execution
	     * @returns {vow:Promise} A new promise, see https://github.com/promises-aplus/promises-spec for details
	     */
	    then : function(onFulfilled, onRejected, onProgress, ctx) {
	        var defer = new Deferred();
	        this._addCallbacks(defer, onFulfilled, onRejected, onProgress, ctx);
	        return defer.promise();
	    },

	    /**
	     * Adds only a rejection reaction. This method is a shorthand for `promise.then(undefined, onRejected)`.
	     *
	     * @param {Function} onRejected Callback that will be called with a provided 'reason' as argument after the promise has been rejected
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    'catch' : function(onRejected, ctx) {
	        return this.then(undef, onRejected, ctx);
	    },

	    /**
	     * Adds only a rejection reaction. This method is a shorthand for `promise.then(null, onRejected)`. It's also an alias for `catch`.
	     *
	     * @param {Function} onRejected Callback to be called with the value after promise has been rejected
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    fail : function(onRejected, ctx) {
	        return this.then(undef, onRejected, ctx);
	    },

	    /**
	     * Adds a resolving reaction (for both fulfillment and rejection).
	     *
	     * @param {Function} onResolved Callback that will be invoked with the promise as an argument, after the promise has been resolved.
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    always : function(onResolved, ctx) {
	        var _this = this,
	            cb = function() {
	                return onResolved.call(this, _this);
	            };

	        return this.then(cb, cb, ctx);
	    },

	    /**
	     * Adds a progress reaction.
	     *
	     * @param {Function} onProgress Callback that will be called with a provided value when the promise has been notified
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    progress : function(onProgress, ctx) {
	        return this.then(undef, undef, onProgress, ctx);
	    },

	    /**
	     * Like `promise.then`, but "spreads" the array into a variadic value handler.
	     * It is useful with the `vow.all` and the `vow.allResolved` methods.
	     *
	     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
	     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Object} [ctx] Context of the callbacks execution
	     * @returns {vow:Promise}
	     *
	     * @example
	     * ```js
	     * var defer1 = vow.defer(),
	     *     defer2 = vow.defer();
	     *
	     * vow.all([defer1.promise(), defer2.promise()]).spread(function(arg1, arg2) {
	     *     // arg1 is "1", arg2 is "'two'" here
	     * });
	     *
	     * defer1.resolve(1);
	     * defer2.resolve('two');
	     * ```
	     */
	    spread : function(onFulfilled, onRejected, ctx) {
	        return this.then(
	            function(val) {
	                return onFulfilled.apply(this, val);
	            },
	            onRejected,
	            ctx);
	    },

	    /**
	     * Like `then`, but terminates a chain of promises.
	     * If the promise has been rejected, this method throws it's "reason" as an exception in a future turn of the event loop.
	     *
	     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
	     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
	     * @param {Object} [ctx] Context of the callbacks execution
	     *
	     * @example
	     * ```js
	     * var defer = vow.defer();
	     * defer.reject(Error('Internal error'));
	     * defer.promise().done(); // exception to be thrown
	     * ```
	     */
	    done : function(onFulfilled, onRejected, onProgress, ctx) {
	        this
	            .then(onFulfilled, onRejected, onProgress, ctx)
	            .fail(throwException);
	    },

	    /**
	     * Returns a new promise that will be fulfilled in `delay` milliseconds if the promise is fulfilled,
	     * or immediately rejected if the promise is rejected.
	     *
	     * @param {Number} delay
	     * @returns {vow:Promise}
	     */
	    delay : function(delay) {
	        var timer,
	            promise = this.then(function(val) {
	                var defer = new Deferred();
	                timer = setTimeout(
	                    function() {
	                        defer.resolve(val);
	                    },
	                    delay);

	                return defer.promise();
	            });

	        promise.always(function() {
	            clearTimeout(timer);
	        });

	        return promise;
	    },

	    /**
	     * Returns a new promise that will be rejected in `timeout` milliseconds
	     * if the promise is not resolved beforehand.
	     *
	     * @param {Number} timeout
	     * @returns {vow:Promise}
	     *
	     * @example
	     * ```js
	     * var defer = vow.defer(),
	     *     promiseWithTimeout1 = defer.promise().timeout(50),
	     *     promiseWithTimeout2 = defer.promise().timeout(200);
	     *
	     * setTimeout(
	     *     function() {
	     *         defer.resolve('ok');
	     *     },
	     *     100);
	     *
	     * promiseWithTimeout1.fail(function(reason) {
	     *     // promiseWithTimeout to be rejected in 50ms
	     * });
	     *
	     * promiseWithTimeout2.then(function(value) {
	     *     // promiseWithTimeout to be fulfilled with "'ok'" value
	     * });
	     * ```
	     */
	    timeout : function(timeout) {
	        var defer = new Deferred(),
	            timer = setTimeout(
	                function() {
	                    defer.reject(new vow.TimedOutError('timed out'));
	                },
	                timeout);

	        this.then(
	            function(val) {
	                defer.resolve(val);
	            },
	            function(reason) {
	                defer.reject(reason);
	            });

	        defer.promise().always(function() {
	            clearTimeout(timer);
	        });

	        return defer.promise();
	    },

	    _vow : true,

	    _resolve : function(val) {
	        if(this._status > PROMISE_STATUS.RESOLVED) {
	            return;
	        }

	        if(val === this) {
	            this._reject(TypeError('Can\'t resolve promise with itself'));
	            return;
	        }

	        this._status = PROMISE_STATUS.RESOLVED;

	        if(val && !!val._vow) { // shortpath for vow.Promise
	            val.isFulfilled()?
	                this._fulfill(val.valueOf()) :
	                val.isRejected()?
	                    this._reject(val.valueOf()) :
	                    val.then(
	                        this._fulfill,
	                        this._reject,
	                        this._notify,
	                        this);
	            return;
	        }

	        if(isObject(val) || isFunction(val)) {
	            var then;
	            try {
	                then = val.then;
	            }
	            catch(e) {
	                this._reject(e);
	                return;
	            }

	            if(isFunction(then)) {
	                var _this = this,
	                    isResolved = false;

	                try {
	                    then.call(
	                        val,
	                        function(val) {
	                            if(isResolved) {
	                                return;
	                            }

	                            isResolved = true;
	                            _this._resolve(val);
	                        },
	                        function(err) {
	                            if(isResolved) {
	                                return;
	                            }

	                            isResolved = true;
	                            _this._reject(err);
	                        },
	                        function(val) {
	                            _this._notify(val);
	                        });
	                }
	                catch(e) {
	                    isResolved || this._reject(e);
	                }

	                return;
	            }
	        }

	        this._fulfill(val);
	    },

	    _fulfill : function(val) {
	        if(this._status > PROMISE_STATUS.RESOLVED) {
	            return;
	        }

	        this._status = PROMISE_STATUS.FULFILLED;
	        this._value = val;

	        this._callCallbacks(this._fulfilledCallbacks, val);
	        this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
	    },

	    _reject : function(reason) {
	        if(this._status > PROMISE_STATUS.RESOLVED) {
	            return;
	        }

	        this._status = PROMISE_STATUS.REJECTED;
	        this._value = reason;

	        this._callCallbacks(this._rejectedCallbacks, reason);
	        this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
	    },

	    _notify : function(val) {
	        this._callCallbacks(this._progressCallbacks, val);
	    },

	    _addCallbacks : function(defer, onFulfilled, onRejected, onProgress, ctx) {
	        if(onRejected && !isFunction(onRejected)) {
	            ctx = onRejected;
	            onRejected = undef;
	        }
	        else if(onProgress && !isFunction(onProgress)) {
	            ctx = onProgress;
	            onProgress = undef;
	        }

	        var cb;

	        if(!this.isRejected()) {
	            cb = { defer : defer, fn : isFunction(onFulfilled)? onFulfilled : undef, ctx : ctx };
	            this.isFulfilled()?
	                this._callCallbacks([cb], this._value) :
	                this._fulfilledCallbacks.push(cb);
	        }

	        if(!this.isFulfilled()) {
	            cb = { defer : defer, fn : onRejected, ctx : ctx };
	            this.isRejected()?
	                this._callCallbacks([cb], this._value) :
	                this._rejectedCallbacks.push(cb);
	        }

	        if(this._status <= PROMISE_STATUS.RESOLVED) {
	            this._progressCallbacks.push({ defer : defer, fn : onProgress, ctx : ctx });
	        }
	    },

	    _callCallbacks : function(callbacks, arg) {
	        var len = callbacks.length;
	        if(!len) {
	            return;
	        }

	        var isResolved = this.isResolved(),
	            isFulfilled = this.isFulfilled(),
	            isRejected = this.isRejected();

	        nextTick(function() {
	            var i = 0, cb, defer, fn;
	            while(i < len) {
	                cb = callbacks[i++];
	                defer = cb.defer;
	                fn = cb.fn;

	                if(fn) {
	                    var ctx = cb.ctx,
	                        res;
	                    try {
	                        res = ctx? fn.call(ctx, arg) : fn(arg);
	                    }
	                    catch(e) {
	                        defer.reject(e);
	                        continue;
	                    }

	                    isResolved?
	                        defer.resolve(res) :
	                        defer.notify(res);
	                }
	                else if(isFulfilled) {
	                    defer.resolve(arg);
	                }
	                else if(isRejected) {
	                    defer.reject(arg);
	                }
	                else {
	                    defer.notify(arg);
	                }
	            }
	        });
	    }
	};

	/** @lends Promise */
	var staticMethods = {
	    /**
	     * Coerces the given `value` to a promise, or returns the `value` if it's already a promise.
	     *
	     * @param {*} value
	     * @returns {vow:Promise}
	     */
	    cast : function(value) {
	        return vow.cast(value);
	    },

	    /**
	     * Returns a promise, that will be fulfilled only after all the items in `iterable` are fulfilled.
	     * If any of the `iterable` items gets rejected, then the returned promise will be rejected.
	     *
	     * @param {Array|Object} iterable
	     * @returns {vow:Promise}
	     */
	    all : function(iterable) {
	        return vow.all(iterable);
	    },

	    /**
	     * Returns a promise, that will be fulfilled only when any of the items in `iterable` are fulfilled.
	     * If any of the `iterable` items gets rejected, then the returned promise will be rejected.
	     *
	     * @param {Array} iterable
	     * @returns {vow:Promise}
	     */
	    race : function(iterable) {
	        return vow.anyResolved(iterable);
	    },

	    /**
	     * Returns a promise that has already been resolved with the given `value`.
	     * If `value` is a promise, the returned promise will have `value`'s state.
	     *
	     * @param {*} value
	     * @returns {vow:Promise}
	     */
	    resolve : function(value) {
	        return vow.resolve(value);
	    },

	    /**
	     * Returns a promise that has already been rejected with the given `reason`.
	     *
	     * @param {*} reason
	     * @returns {vow:Promise}
	     */
	    reject : function(reason) {
	        return vow.reject(reason);
	    }
	};

	for(var prop in staticMethods) {
	    staticMethods.hasOwnProperty(prop) &&
	        (Promise[prop] = staticMethods[prop]);
	}

	var vow = /** @exports vow */ {
	    Deferred : Deferred,

	    Promise : Promise,

	    /**
	     * Creates a new deferred. This method is a factory method for `vow:Deferred` class.
	     * It's equivalent to `new vow.Deferred()`.
	     *
	     * @returns {vow:Deferred}
	     */
	    defer : function() {
	        return new Deferred();
	    },

	    /**
	     * Static equivalent to `promise.then`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
	     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
	     * @param {Object} [ctx] Context of the callbacks execution
	     * @returns {vow:Promise}
	     */
	    when : function(value, onFulfilled, onRejected, onProgress, ctx) {
	        return vow.cast(value).then(onFulfilled, onRejected, onProgress, ctx);
	    },

	    /**
	     * Static equivalent to `promise.fail`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Function} onRejected Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    fail : function(value, onRejected, ctx) {
	        return vow.when(value, undef, onRejected, ctx);
	    },

	    /**
	     * Static equivalent to `promise.always`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Function} onResolved Callback that will be invoked with the promise as an argument, after the promise has been resolved.
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    always : function(value, onResolved, ctx) {
	        return vow.when(value).always(onResolved, ctx);
	    },

	    /**
	     * Static equivalent to `promise.progress`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Function} onProgress Callback that will be invoked with a provided value after the promise has been notified
	     * @param {Object} [ctx] Context of the callback execution
	     * @returns {vow:Promise}
	     */
	    progress : function(value, onProgress, ctx) {
	        return vow.when(value).progress(onProgress, ctx);
	    },

	    /**
	     * Static equivalent to `promise.spread`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
	     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Object} [ctx] Context of the callbacks execution
	     * @returns {vow:Promise}
	     */
	    spread : function(value, onFulfilled, onRejected, ctx) {
	        return vow.when(value).spread(onFulfilled, onRejected, ctx);
	    },

	    /**
	     * Static equivalent to `promise.done`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
	     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
	     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
	     * @param {Object} [ctx] Context of the callbacks execution
	     */
	    done : function(value, onFulfilled, onRejected, onProgress, ctx) {
	        vow.when(value).done(onFulfilled, onRejected, onProgress, ctx);
	    },

	    /**
	     * Checks whether the given `value` is a promise-like object
	     *
	     * @param {*} value
	     * @returns {Boolean}
	     *
	     * @example
	     * ```js
	     * vow.isPromise('something'); // returns false
	     * vow.isPromise(vow.defer().promise()); // returns true
	     * vow.isPromise({ then : function() { }); // returns true
	     * ```
	     */
	    isPromise : function(value) {
	        return isObject(value) && isFunction(value.then);
	    },

	    /**
	     * Coerces the given `value` to a promise, or returns the `value` if it's already a promise.
	     *
	     * @param {*} value
	     * @returns {vow:Promise}
	     */
	    cast : function(value) {
	        return value && !!value._vow?
	            value :
	            vow.resolve(value);
	    },

	    /**
	     * Static equivalent to `promise.valueOf`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @returns {*}
	     */
	    valueOf : function(value) {
	        return value && isFunction(value.valueOf)? value.valueOf() : value;
	    },

	    /**
	     * Static equivalent to `promise.isFulfilled`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @returns {Boolean}
	     */
	    isFulfilled : function(value) {
	        return value && isFunction(value.isFulfilled)? value.isFulfilled() : true;
	    },

	    /**
	     * Static equivalent to `promise.isRejected`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @returns {Boolean}
	     */
	    isRejected : function(value) {
	        return value && isFunction(value.isRejected)? value.isRejected() : false;
	    },

	    /**
	     * Static equivalent to `promise.isResolved`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @returns {Boolean}
	     */
	    isResolved : function(value) {
	        return value && isFunction(value.isResolved)? value.isResolved() : true;
	    },

	    /**
	     * Returns a promise that has already been resolved with the given `value`.
	     * If `value` is a promise, the returned promise will have `value`'s state.
	     *
	     * @param {*} value
	     * @returns {vow:Promise}
	     */
	    resolve : function(value) {
	        var res = vow.defer();
	        res.resolve(value);
	        return res.promise();
	    },

	    /**
	     * Returns a promise that has already been fulfilled with the given `value`.
	     * If `value` is a promise, the returned promise will be fulfilled with the fulfill/rejection value of `value`.
	     *
	     * @param {*} value
	     * @returns {vow:Promise}
	     */
	    fulfill : function(value) {
	        var defer = vow.defer(),
	            promise = defer.promise();

	        defer.resolve(value);

	        return promise.isFulfilled()?
	            promise :
	            promise.then(null, function(reason) {
	                return reason;
	            });
	    },

	    /**
	     * Returns a promise that has already been rejected with the given `reason`.
	     * If `reason` is a promise, the returned promise will be rejected with the fulfill/rejection value of `reason`.
	     *
	     * @param {*} reason
	     * @returns {vow:Promise}
	     */
	    reject : function(reason) {
	        var defer = vow.defer();
	        defer.reject(reason);
	        return defer.promise();
	    },

	    /**
	     * Invokes the given function `fn` with arguments `args`
	     *
	     * @param {Function} fn
	     * @param {...*} [args]
	     * @returns {vow:Promise}
	     *
	     * @example
	     * ```js
	     * var promise1 = vow.invoke(function(value) {
	     *         return value;
	     *     }, 'ok'),
	     *     promise2 = vow.invoke(function() {
	     *         throw Error();
	     *     });
	     *
	     * promise1.isFulfilled(); // true
	     * promise1.valueOf(); // 'ok'
	     * promise2.isRejected(); // true
	     * promise2.valueOf(); // instance of Error
	     * ```
	     */
	    invoke : function(fn, args) {
	        var len = Math.max(arguments.length - 1, 0),
	            callArgs;
	        if(len) { // optimization for V8
	            callArgs = Array(len);
	            var i = 0;
	            while(i < len) {
	                callArgs[i++] = arguments[i];
	            }
	        }

	        try {
	            return vow.resolve(callArgs?
	                fn.apply(global, callArgs) :
	                fn.call(global));
	        }
	        catch(e) {
	            return vow.reject(e);
	        }
	    },

	    /**
	     * Returns a promise, that will be fulfilled only after all the items in `iterable` are fulfilled.
	     * If any of the `iterable` items gets rejected, the promise will be rejected.
	     *
	     * @param {Array|Object} iterable
	     * @returns {vow:Promise}
	     *
	     * @example
	     * with array:
	     * ```js
	     * var defer1 = vow.defer(),
	     *     defer2 = vow.defer();
	     *
	     * vow.all([defer1.promise(), defer2.promise(), 3])
	     *     .then(function(value) {
	     *          // value is "[1, 2, 3]" here
	     *     });
	     *
	     * defer1.resolve(1);
	     * defer2.resolve(2);
	     * ```
	     *
	     * @example
	     * with object:
	     * ```js
	     * var defer1 = vow.defer(),
	     *     defer2 = vow.defer();
	     *
	     * vow.all({ p1 : defer1.promise(), p2 : defer2.promise(), p3 : 3 })
	     *     .then(function(value) {
	     *          // value is "{ p1 : 1, p2 : 2, p3 : 3 }" here
	     *     });
	     *
	     * defer1.resolve(1);
	     * defer2.resolve(2);
	     * ```
	     */
	    all : function(iterable) {
	        var defer = new Deferred(),
	            isPromisesArray = isArray(iterable),
	            keys = isPromisesArray?
	                getArrayKeys(iterable) :
	                getObjectKeys(iterable),
	            len = keys.length,
	            res = isPromisesArray? [] : {};

	        if(!len) {
	            defer.resolve(res);
	            return defer.promise();
	        }

	        var i = len;
	        vow._forEach(
	            iterable,
	            function(value, idx) {
	                res[keys[idx]] = value;
	                if(!--i) {
	                    defer.resolve(res);
	                }
	            },
	            defer.reject,
	            defer.notify,
	            defer,
	            keys);

	        return defer.promise();
	    },

	    /**
	     * Returns a promise, that will be fulfilled only after all the items in `iterable` are resolved.
	     *
	     * @param {Array|Object} iterable
	     * @returns {vow:Promise}
	     *
	     * @example
	     * ```js
	     * var defer1 = vow.defer(),
	     *     defer2 = vow.defer();
	     *
	     * vow.allResolved([defer1.promise(), defer2.promise()]).spread(function(promise1, promise2) {
	     *     promise1.isRejected(); // returns true
	     *     promise1.valueOf(); // returns "'error'"
	     *     promise2.isFulfilled(); // returns true
	     *     promise2.valueOf(); // returns "'ok'"
	     * });
	     *
	     * defer1.reject('error');
	     * defer2.resolve('ok');
	     * ```
	     */
	    allResolved : function(iterable) {
	        var defer = new Deferred(),
	            isPromisesArray = isArray(iterable),
	            keys = isPromisesArray?
	                getArrayKeys(iterable) :
	                getObjectKeys(iterable),
	            i = keys.length,
	            res = isPromisesArray? [] : {};

	        if(!i) {
	            defer.resolve(res);
	            return defer.promise();
	        }

	        var onResolved = function() {
	                --i || defer.resolve(iterable);
	            };

	        vow._forEach(
	            iterable,
	            onResolved,
	            onResolved,
	            defer.notify,
	            defer,
	            keys);

	        return defer.promise();
	    },

	    allPatiently : function(iterable) {
	        return vow.allResolved(iterable).then(function() {
	            var isPromisesArray = isArray(iterable),
	                keys = isPromisesArray?
	                    getArrayKeys(iterable) :
	                    getObjectKeys(iterable),
	                rejectedPromises, fulfilledPromises,
	                len = keys.length, i = 0, key, promise;

	            if(!len) {
	                return isPromisesArray? [] : {};
	            }

	            while(i < len) {
	                key = keys[i++];
	                promise = iterable[key];
	                if(vow.isRejected(promise)) {
	                    rejectedPromises || (rejectedPromises = isPromisesArray? [] : {});
	                    isPromisesArray?
	                        rejectedPromises.push(promise.valueOf()) :
	                        rejectedPromises[key] = promise.valueOf();
	                }
	                else if(!rejectedPromises) {
	                    (fulfilledPromises || (fulfilledPromises = isPromisesArray? [] : {}))[key] = vow.valueOf(promise);
	                }
	            }

	            if(rejectedPromises) {
	                throw rejectedPromises;
	            }

	            return fulfilledPromises;
	        });
	    },

	    /**
	     * Returns a promise, that will be fulfilled if any of the items in `iterable` is fulfilled.
	     * If all of the `iterable` items get rejected, the promise will be rejected (with the reason of the first rejected item).
	     *
	     * @param {Array} iterable
	     * @returns {vow:Promise}
	     */
	    any : function(iterable) {
	        var defer = new Deferred(),
	            len = iterable.length;

	        if(!len) {
	            defer.reject(Error());
	            return defer.promise();
	        }

	        var i = 0, reason;
	        vow._forEach(
	            iterable,
	            defer.resolve,
	            function(e) {
	                i || (reason = e);
	                ++i === len && defer.reject(reason);
	            },
	            defer.notify,
	            defer);

	        return defer.promise();
	    },

	    /**
	     * Returns a promise, that will be fulfilled only when any of the items in `iterable` is fulfilled.
	     * If any of the `iterable` items gets rejected, the promise will be rejected.
	     *
	     * @param {Array} iterable
	     * @returns {vow:Promise}
	     */
	    anyResolved : function(iterable) {
	        var defer = new Deferred(),
	            len = iterable.length;

	        if(!len) {
	            defer.reject(Error());
	            return defer.promise();
	        }

	        vow._forEach(
	            iterable,
	            defer.resolve,
	            defer.reject,
	            defer.notify,
	            defer);

	        return defer.promise();
	    },

	    /**
	     * Static equivalent to `promise.delay`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Number} delay
	     * @returns {vow:Promise}
	     */
	    delay : function(value, delay) {
	        return vow.resolve(value).delay(delay);
	    },

	    /**
	     * Static equivalent to `promise.timeout`.
	     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
	     *
	     * @param {*} value
	     * @param {Number} timeout
	     * @returns {vow:Promise}
	     */
	    timeout : function(value, timeout) {
	        return vow.resolve(value).timeout(timeout);
	    },

	    _forEach : function(promises, onFulfilled, onRejected, onProgress, ctx, keys) {
	        var len = keys? keys.length : promises.length,
	            i = 0;

	        while(i < len) {
	            vow.when(
	                promises[keys? keys[i] : i],
	                wrapOnFulfilled(onFulfilled, i),
	                onRejected,
	                onProgress,
	                ctx);
	            ++i;
	        }
	    },

	    TimedOutError : defineCustomErrorType('TimedOut')
	};

	var defineAsGlobal = true;
	if(typeof module === 'object' && typeof module.exports === 'object') {
	    module.exports = vow;
	    defineAsGlobal = false;
	}

	if(typeof modules === 'object' && isFunction(modules.define)) {
	    modules.define('vow', function(provide) {
	        provide(vow);
	    });
	    defineAsGlobal = false;
	}

	if(true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	        module.exports = vow;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    defineAsGlobal = false;
	}

	defineAsGlobal && (global.vow = vow);

	})(typeof window !== 'undefined'? window : global);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(51).setImmediate, __webpack_require__(25)))

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(25).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51).setImmediate, __webpack_require__(51).clearImmediate))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows curly braces after statements.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted keywords or `true` to disallow curly braces after the following keywords:
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowCurlyBraces": [
	 *     "if",
	 *     "else",
	 *     "while",
	 *     "for",
	 *     "do",
	 *     "with"
	 * ]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * if (x) x++;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (x) {
	 *     x++;
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);
	var defaultKeywords = __webpack_require__(49).curlyBracedKeywords;

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(statementTypes) {
	        assert(
	            Array.isArray(statementTypes) || statementTypes === true,
	            this.getOptionName() + ' option requires array or true value'
	        );

	        if (statementTypes === true) {
	            statementTypes = defaultKeywords;
	        }

	        this._typeIndex = {};
	        statementTypes.forEach(function(type) {
	            this._typeIndex[type] = true;
	        }.bind(this));
	    },

	    getOptionName: function() {
	        return 'disallowCurlyBraces';
	    },

	    check: function(file, errors) {

	        function isSingleBlockStatement(node) {
	            return node && node.type === 'BlockStatement' &&
	            node.body.length === 1;
	        }

	        function addError(typeString, entity) {
	            errors.add(
	                typeString + ' statement with extra curly braces',
	                entity.loc.start.line,
	                entity.loc.start.column
	            );
	        }

	        function checkBody(type, typeString) {
	            file.iterateNodesByType(type, function(node) {
	                if (isSingleBlockStatement(node.body)) {
	                    addError(typeString, node);
	                }
	            });
	        }

	        var typeIndex = this._typeIndex;

	        if (typeIndex['if'] || typeIndex['else']) {
	            file.iterateNodesByType('IfStatement', function(node) {
	                if (typeIndex['if'] && isSingleBlockStatement(node.consequent)) {
	                    addError('If', node);
	                }
	                if (typeIndex['else'] && isSingleBlockStatement(node.alternate)) {
	                    addError('Else', file.getPrevToken(file.getFirstNodeToken(node.alternate)));
	                }
	            });
	        }

	        if (typeIndex['while']) {
	            checkBody('WhileStatement', 'While');
	        }

	        if (typeIndex['for']) {
	            checkBody('ForStatement', 'For');
	            checkBody('ForInStatement', 'For in');
	        }

	        if (typeIndex['do']) {
	            checkBody('DoWhileStatement', 'Do while');
	        }

	        if (typeIndex['with']) {
	            checkBody('WithStatement', 'With');
	        }
	    }

	};


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires multiple `var` declaration.
	 *
	 * Types: `Boolean` or `String`
	 *
	 * Values: `true` or `"onevar"`
	 *
	 * if `requireMultipleVarDecl` defined as a `true` value, it will report only consecutive vars, if, on the other hand,
	 * value equals to `"onevar"` string, `requireMultipleVarDecl` will allow only one `var` per function scope.
	 *
	 * JSHint: [`onevar`](http://jshint.com/docs/options/#onevar)
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireMultipleVarDecl": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = 1,
	 *     y = 2;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = 1;
	 * var y = 2;
	 * ```
	 */

	var assert = __webpack_require__(23);

	function consecutive(file, errors) {
	    file.iterateNodesByType('VariableDeclaration', function(node) {
	        var pos = node.parentCollection.indexOf(node);
	        if (pos < node.parentCollection.length - 1) {
	            var sibling = node.parentCollection[pos + 1];
	            if (sibling.type === 'VariableDeclaration' && sibling.kind === node.kind) {
	                errors.add(
	                    node.kind[0].toUpperCase() + node.kind.slice(1) + ' declarations should be joined',
	                    sibling.loc.start
	                );
	            }
	        }
	    });
	}

	function onevar(file, errors) {
	    file.iterateNodesByType(['Program', 'FunctionDeclaration', 'FunctionExpression'], function(node) {
	        var firstVar = true;
	        var firstConst = true;
	        var firstParent = true;

	        file.iterate(function(node) {
	            var type = node.type;
	            var kind = node.kind;

	            // Don't go in nested scopes
	            if (!firstParent && ['FunctionDeclaration', 'FunctionExpression'].indexOf(type) > -1) {
	                return false;
	            }

	            if (firstParent) {
	                firstParent = false;
	            }

	            if (type === 'VariableDeclaration') {
	                if (kind === 'var') {
	                    if (!firstVar) {
	                        errors.add(
	                            'Var declarations should be joined',
	                            node.loc.start
	                        );
	                    } else {
	                        firstVar = false;
	                    }
	                }

	                if (kind === 'const') {
	                    if (!firstConst) {
	                        errors.add(
	                            'Const declarations should be joined',
	                            node.loc.start
	                        );
	                    } else {
	                        firstConst = false;
	                    }
	                }
	            }
	        }, node);
	    });
	}

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true || options === 'onevar',
	            this.getOptionName() + ' option requires a true value or `onevar`'
	        );

	        this._check = typeof options === 'string' ? onevar : consecutive;
	    },

	    getOptionName: function() {
	        return 'requireMultipleVarDecl';
	    },

	    check: function() {
	        return this._check.apply(this, arguments);
	    }
	};


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows multiple `var` declaration (except for-loop).
	 *
	 * Types: `Boolean` or `String`
	 *
	 * Values:
	 *
	 * - `true` disallows multiple variable declarations except within a for loop
	 * - `'strict'` disallows all multiple variable declarations
	 * - `'exceptUndefined'` allows declarations where all variables are not defined
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowMultipleVarDecl": true
	 * ```
	 *
	 * ##### Valid for `true`
	 *
	 * ```js
	 * var x = 1;
	 * var y = 2;
	 *
	 * for (var i = 0, j = arr.length; i < j; i++) {}
	 * ```
	 *
	 * ##### Valid for `strict`
	 *
	 * ```js
	 * var x = 1;
	 * var y = 2;
	 * ```
	 *
	 * ##### Valid for `exceptUndefined`
	 *
	 * ```js
	 * var a, b;
	 * var x = 1;
	 * var y = 2;
	 *
	 * for (var i = 0, j = arr.length; i < j; i++) {}
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = 1,
	 *     y = 2;
	 *
	 * var x, y = 2, z;
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true ||
	            options === 'strict' ||
	            options === 'exceptUndefined',
	            this.getOptionName() + ' option requires a true value, "strict", or "exceptUndefined"'
	        );

	        this.strictMode = options === 'strict';
	        this.exceptUndefined = options === 'exceptUndefined';
	    },

	    getOptionName: function() {
	        return 'disallowMultipleVarDecl';
	    },

	    check: function(file, errors) {
	        var inStrictMode = this.strictMode;
	        var exceptUndefined = this.exceptUndefined;

	        file.iterateNodesByType('VariableDeclaration', function(node) {
	            var hasDefinedVariables = node.declarations.some(function(declaration) {
	                return !!declaration.init;
	            });

	            var isForStatement = node.parentNode.type === 'ForStatement';

	            // allow single var declarations
	            if (node.declarations.length === 1 ||
	                // allow multiple var declarations in for statement unless we're in strict mode
	                // for (var i = 0, j = myArray.length; i < j; i++) {}
	                !inStrictMode && isForStatement ||
	                // allow multiple var declarations with all undefined variables in exceptUndefined mode
	                // var a, b, c
	                exceptUndefined && !hasDefinedVariables) {
	                return;
	            }

	            errors.add('Multiple var declaration', node.loc.start);
	        });
	    }

	};


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows empty blocks (except for catch blocks).
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * JSHint: [`noempty`](http://jshint.com/docs/options/#noempty)
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowEmptyBlocks": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * if ( a == b ) { c = d; }
	 * try { a = b; } catch( e ){}
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if ( a == b ) { } else { c = d; }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowEmptyBlocks';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('BlockStatement', function(node) {
	            if (node.body.length === 0 &&
	                node.parentNode.type !== 'CatchClause' &&
	                node.parentNode.type !== 'FunctionDeclaration' &&
	                node.parentNode.type !== 'FunctionExpression') {
	                errors.add('Empty block found', node.loc.end);
	            }
	        });
	    }

	};


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space after keyword.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted keywords or `true` to require all of the keywords below to have a space afterward.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpaceAfterKeywords": [
	 *     "do",
	 *     "for",
	 *     "if",
	 *     "else",
	 *     "switch",
	 *     "case",
	 *     "try",
	 *     "catch",
	 *     "void",
	 *     "while",
	 *     "with",
	 *     "return",
	 *     "typeof",
	 *     "function"
	 * ]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * return true;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if(x) {
	 *     x++;
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	var defaultKeywords = __webpack_require__(49).spacedKeywords;

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(keywords) {
	        assert(
	            Array.isArray(keywords) || keywords === true,
	            this.getOptionName() + ' option requires array or true value');

	        if (keywords === true) {
	            keywords = defaultKeywords;
	        }

	        this._keywords = keywords;
	    },

	    getOptionName: function() {
	        return 'requireSpaceAfterKeywords';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
	            var nextToken = file.getNextToken(token, {includeComments: true});

	            if (nextToken.type === 'Punctuator' && nextToken.value === ';') {
	                return;
	            }

	            errors.assert.spacesBetween({
	                token: token,
	                nextToken: nextToken,
	                exactly: 1,
	                message: 'One space required after "' + token.value + '" keyword'
	            });
	        });
	    }

	};


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space before keyword.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted keywords or `true` to require all possible keywords to have a preceding space.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpaceBeforeKeywords": [
	 *     "else",
	 *     "while",
	 *     "catch"
	 * ]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * } else {
	 *     x++;
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * }else {
	 *     x++;
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	var defaultKeywords = __webpack_require__(49).spacedKeywords;

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(keywords) {
	        assert(
	            Array.isArray(keywords) || keywords === true,
	            this.getOptionName() + ' option requires array or true value');

	        if (keywords === true) {
	            keywords = defaultKeywords;
	        }

	        this._keywords = keywords;
	    },

	    getOptionName: function() {
	        return 'requireSpaceBeforeKeywords';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
	            var prevToken = file.getPrevToken(token, {includeComments: true});
	            if (!prevToken || prevToken.isComment) {
	                return;
	            }

	            if (prevToken.type !== 'Punctuator' || prevToken.value !== ';') {
	                errors.assert.whitespaceBetween({
	                    token: prevToken,
	                    nextToken: token,
	                    message: 'Missing space before "' + token.value + '" keyword'
	                });
	            }
	        });
	    }

	};


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space after keyword.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted keywords or `true` to disallow spaces after all possible keywords.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpaceAfterKeywords": [
	 *     "if",
	 *     "else",
	 *     "for",
	 *     "while",
	 *     "do",
	 *     "switch",
	 *     "try",
	 *     "catch"
	 * ]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * if(x > y) {
	 *     y++;
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (x > y) {
	 *     y++;
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);
	var defaultKeywords = __webpack_require__(49).spacedKeywords;

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(keywords) {
	        assert(
	            Array.isArray(keywords) || keywords === true,
	            this.getOptionName() + ' option requires array or true value'
	        );

	        if (keywords === true) {
	            keywords = defaultKeywords;
	        }

	        this._keywords = keywords;
	    },

	    getOptionName: function() {
	        return 'disallowSpaceAfterKeywords';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
	            errors.assert.noWhitespaceBetween({
	                token: token,
	                nextToken: file.getNextToken(token)
	            });
	        });
	    }

	};


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space before keyword.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted keywords or `true` to disallow spaces before all possible keywords.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpaceBeforeKeywords": [
	 *     "else",
	 *     "catch"
	 * ]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * }else {
	 *     y--;
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * } else {
	 *     y--;
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	var defaultKeywords = __webpack_require__(49).spacedKeywords;

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(keywords) {
	        assert(
	            Array.isArray(keywords) || keywords === true,
	            this.getOptionName() + ' option requires array or true value');

	        if (keywords === true) {
	            keywords = defaultKeywords;
	        }

	        this._keywords = keywords;
	    },

	    getOptionName: function() {
	        return 'disallowSpaceBeforeKeywords';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
	            var prevToken = file.getPrevToken(token, {includeComments: true});
	            if (!prevToken || prevToken.isComment) {
	                return;
	            }

	            if (prevToken.type !== 'Keyword' && prevToken.value !== ';') {
	                errors.assert.noWhitespaceBetween({
	                    token: prevToken,
	                    nextToken: token,
	                    message: 'Illegal space before "' + token.value + '" keyword'
	                });
	            }
	        });
	    }

	};


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires parentheses around immediately invoked function expressions.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * JSHint: [`immed`](http://www.jshint.com/docs/options/#immed)
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireParenthesesAroundIIFE": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var a = (function(){ return 1; })();
	 * var b = (function(){ return 2; }());
	 * var c = (function(){ return 3; }).call(this, arg1);
	 * var d = (function(){ return 3; }.call(this, arg1));
	 * var e = (function(){ return d; }).apply(this, args);
	 * var f = (function(){ return d; }.apply(this, args));
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var a = function(){ return 1; }();
	 * var c = function(){ return 3; }.call(this, arg1);
	 * var d = function(){ return d; }.apply(this, args);
	 * ```
	 */

	var assert = __webpack_require__(23);
	var utils = __webpack_require__(49);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireParenthesesAroundIIFE';
	    },

	    check: function(file, errors) {

	        function isWrapped(node) {
	            var openParensToken = file.getPrevToken(file.getFirstNodeToken(node));

	            var closingParensToken = file.getNextToken(file.getLastNodeToken(node));
	            var closingTokenValue = closingParensToken ? closingParensToken.value : '';

	            return openParensToken.value + closingTokenValue === '()';
	        }

	        file.iterateNodesByType('CallExpression', function(node) {
	            var inner = utils.getFunctionNodeFromIIFE(node);

	            if (inner && !isWrapped(inner) && !isWrapped(node)) {
	                errors.add(
	                    'Wrap immediately invoked function expressions in parentheses',
	                    node.loc.start.line,
	                    node.loc.start.column
	                );

	            }
	        });
	    }

	};


/***/ },
/* 61 */
/***/ function(module, exports) {

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function() {},

	    getOptionName: function() {
	        return 'requireLeftStickedOperators';
	    },

	    check: function(file, errors) {
	        errors.add(
	            'The requireLeftStickedOperators rule is no longer supported.' +
	            '\nPlease use the following rules instead:' +
	            '\n' +
	            '\ndisallowSpaceBeforeBinaryOperators' +
	            '\ndisallowSpaceBeforePostfixUnaryOperators' +
	            '\ndisallowSpacesInConditionalExpression',
	            1,
	            0
	        );
	    }

	};


/***/ },
/* 62 */
/***/ function(module, exports) {

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function() {},

	    getOptionName: function() {
	        return 'disallowLeftStickedOperators';
	    },

	    check: function(file, errors) {
	        errors.add(
	            'The disallowLeftStickedOperators rule is no longer supported.' +
	            '\nPlease use the following rules instead:' +
	            '\n' +
	            '\nrequireSpaceBeforeBinaryOperators' +
	            '\nrequireSpaceBeforePostfixUnaryOperators' +
	            '\nrequireSpacesInConditionalExpression',
	            1,
	            0
	        );
	    }

	};


/***/ },
/* 63 */
/***/ function(module, exports) {

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function() {},

	    getOptionName: function() {
	        return 'requireRightStickedOperators';
	    },

	    check: function(file, errors) {
	        errors.add(
	            'The requireRightStickedOperators rule is no longer supported.' +
	            '\nPlease use the following rules instead:' +
	            '\n' +
	            '\ndisallowSpaceAfterBinaryOperators' +
	            '\ndisallowSpaceAfterPrefixUnaryOperators' +
	            '\ndisallowSpacesInConditionalExpression',
	            1,
	            0
	        );
	    }

	};


/***/ },
/* 64 */
/***/ function(module, exports) {

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function() {},

	    getOptionName: function() {
	        return 'disallowRightStickedOperators';
	    },

	    check: function(file, errors) {
	        errors.add(
	            'The disallowRightStickedOperators rule is no longer supported.' +
	            '\nPlease use the following rules instead:' +
	            '\n' +
	            '\nrequireSpaceAfterBinaryOperators' +
	            '\nrequireSpaceAfterPrefixUnaryOperators' +
	            '\nrequireSpacesInConditionalExpression',
	            1,
	            0
	        );
	    }

	};


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(typeof options === 'object', this.getOptionName() + ' option requires object value');
	        this._options = options;
	    },

	    getOptionName: function() {
	        return 'validateJSDoc';
	    },

	    check: function(file, errors) {
	        var options = this._options;
	        var comments = file.getComments();
	        file.iterateNodesByType(['FunctionDeclaration', 'FunctionExpression'], function(node) {
	            var jsDoc = getJsDocForLine(node.loc.start.line);
	            if (jsDoc) {
	                var jsDocData = jsDoc.value;
	                var jsDocLines = jsDocData.split('\n');
	                var paramIndex = 0;
	                if (options.checkParamNames || options.checkRedundantParams || options.requireParamTypes) {
	                    for (var i = 0, l = jsDocLines.length; i < l; i++) {
	                        var line = jsDocLines[i].trim();
	                        if (line.charAt(0) === '*') {
	                            line = line.substr(1).trim();
	                            if (line.indexOf('@param') === 0) {
	                                var match = line.match(/^@param\s+(?:{(.+?)})?\s*(?:\[)?([a-zA-Z0-9_\.\$]+)/);
	                                if (match) {
	                                    var jsDocParamType = match[1];
	                                    var jsDocParamName = match[2];
	                                    if (options.requireParamTypes && !jsDocParamType) {
	                                        errors.add(
	                                            'Missing JSDoc @param type',
	                                            jsDoc.loc.start.line + i,
	                                            jsDocLines[i].indexOf('@param')
	                                        );
	                                    }
	                                    if (jsDocParamName.indexOf('.') === -1) {
	                                        var param = node.params[paramIndex];
	                                        if (param) {
	                                            if (jsDocParamName !== param.name) {
	                                                if (options.checkParamNames) {
	                                                    errors.add(
	                                                        'Invalid JSDoc @param argument name',
	                                                        jsDoc.loc.start.line + i,
	                                                        jsDocLines[i].indexOf('@param')
	                                                    );
	                                                }
	                                            }
	                                        } else {
	                                            if (options.checkRedundantParams) {
	                                                errors.add(
	                                                    'Redundant JSDoc @param',
	                                                    jsDoc.loc.start.line + i,
	                                                    jsDocLines[i].indexOf('@param')
	                                                );
	                                            }
	                                        }
	                                        paramIndex++;
	                                    }
	                                } else {
	                                    errors.add(
	                                        'Invalid JSDoc @param',
	                                        jsDoc.loc.start.line + i,
	                                        jsDocLines[i].indexOf('@param')
	                                    );
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        });

	        function getJsDocForLine(line) {
	            line--;
	            for (var i = 0, l = comments.length; i < l; i++) {
	                var comment = comments[i];
	                if (comment.loc.end.line === line && comment.type === 'Block' && comment.value.charAt(0) === '*') {
	                    return comment;
	                }
	            }
	            return null;
	        }
	    }

	};


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires operators to appear before line breaks and not after.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted operators or `true` to require all possible binary operators to appear before line breaks
	 *
	 * JSHint: [`laxbreak`](http://www.jshint.com/docs/options/#laxbreak)
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireOperatorBeforeLineBreak": [
	 *     "?",
	 *     "=",
	 *     "+",
	 *     "-",
	 *     "/",
	 *     "*",
	 *     "==",
	 *     "===",
	 *     "!=",
	 *     "!==",
	 *     ">",
	 *     ">=",
	 *     "<",
	 *     "<="
	 * ]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * x = y ? 1 : 2;
	 * x = y ?
	 *     1 : 2;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * x = y
	 *     ? 1 : 2;
	 * ```
	 */

	var assert = __webpack_require__(23);
	var defaultOperators = __webpack_require__(49).binaryOperators.slice();

	defaultOperators.push('?');

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(operators) {
	        var isTrue = operators === true;

	        assert(
	            Array.isArray(operators) || isTrue,
	            this.getOptionName() + ' option requires array value or true value'
	        );

	        if (isTrue) {
	            operators = defaultOperators;
	        }

	        this._operatorIndex = {};
	        for (var i = 0, l = operators.length; i < l; i++) {
	            this._operatorIndex[operators[i]] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'requireOperatorBeforeLineBreak';
	    },

	    check: function(file, errors) {
	        var operators = this._operatorIndex;
	        var throughTokens = ['?', ','];

	        function errorIfApplicable(operatorToken) {
	            errors.assert.sameLine({
	                token: file.getPrevToken(operatorToken),
	                nextToken: operatorToken,
	                message: 'Operator ' + operatorToken.value + ' should not be on a new line',
	                stickToPreviousToken: true
	            });
	        }

	        throughTokens = throughTokens.filter(function(operator) {
	            return operators[operator];
	        });

	        if (throughTokens.length) {
	            file.iterateTokensByType('Punctuator', function(token) {
	                var operator = token.value;

	                if (throughTokens.every(function() {
	                    return throughTokens.indexOf(operator) >= 0;
	                })) {
	                    errorIfApplicable(token);
	                }
	            });
	        }

	        file.iterateNodesByType(
	            ['BinaryExpression', 'AssignmentExpression', 'LogicalExpression'],
	            function(node) {
	                var operator = node.operator;

	                if (!operators[operator]) {
	                    return;
	                }

	                var nextToken = file.getFirstNodeToken(node.argument || node.right);
	                var token = file.findPrevOperatorToken(nextToken, operator);

	                errorIfApplicable(token);
	            }
	        );
	    }
	};


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires putting certain operators on the next line rather than on the current line before a line break.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of operators to apply to or `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowOperatorBeforeLineBreak": ["+", "."]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * $el.on( 'click', fn )
	 * 	.appendTo( 'body' );
	 *
	 * var x = 4 + 5
	 * 	+ 12 + 13;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * $el.on( 'click', fn ).
	 * 	appendTo( 'body' );
	 *
	 * var x = 4 + 5 +
	 * 	12 + 13;
	 * ```
	 */

	var assert = __webpack_require__(23);
	var defaultOperators = __webpack_require__(49).binaryOperators.slice().concat(['.']);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(operators) {
	        assert(Array.isArray(operators) || operators === true,
	            this.getOptionName() + ' option requires array or true value');

	        if (operators === true) {
	            operators = defaultOperators;
	        }
	        this._operators = operators;
	    },

	    getOptionName: function() {
	        return 'disallowOperatorBeforeLineBreak';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByTypeAndValue('Punctuator', this._operators, function(token) {
	            errors.assert.sameLine({
	                token: token,
	                nextToken: file.getNextToken(token),
	                message: 'Operator needs to either be on the same line or after a line break.'
	            });
	        });
	    }
	};


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows implicit type conversion.
	 *
	 * Type: `Array`
	 *
	 * Values: Array of quoted types
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowImplicitTypeConversion": ["numeric", "boolean", "binary", "string"]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * x = Boolean(y);
	 * x = Number(y);
	 * x = String(y);
	 * x = s.indexOf('.') !== -1;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * x = !!y;
	 * x = +y;
	 * x = '' + y;
	 * x = ~s.indexOf('.');
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(types) {
	        assert(Array.isArray(types), this.getOptionName() + ' option requires array value');
	        this._typeIndex = {};
	        for (var i = 0, l = types.length; i < l; i++) {
	            this._typeIndex[types[i]] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'disallowImplicitTypeConversion';
	    },

	    check: function(file, errors) {
	        var types = this._typeIndex;
	        if (types.numeric || types.boolean || types.binary) {
	            file.iterateNodesByType('UnaryExpression', function(node) {
	                if (types.numeric && node.operator === '+') {
	                    errors.add('Implicit numeric conversion', node.loc.start);
	                }
	                if (types.binary && node.operator === '~') {
	                    errors.add('Implicit binary conversion', node.loc.start);
	                }
	                if (types.boolean &&
	                    node.operator === '!' &&
	                    node.argument.type === 'UnaryExpression' &&
	                    node.argument.operator === '!'
	                ) {
	                    errors.add('Implicit boolean conversion', node.loc.start);
	                }
	            });
	        }
	        if (types.string) {
	            file.iterateNodesByType('BinaryExpression', function(node) {
	                if (node.operator === '+' && (
	                        (node.left.type === 'Literal' && node.left.value === '') ||
	                        (node.right.type === 'Literal' && node.right.value === '')
	                    )
	                ) {
	                    errors.add('Implicit string conversion', node.loc.start);
	                }
	            });
	        }
	    }

	};


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires identifiers to be camelCased or UPPERCASE_WITH_UNDERSCORES
	 *
	 * Types: `Boolean` or `String`
	 *
	 * Values:
	 *
	 * - `true`
	 * - `"ignoreProperties"` allows an exception for object property names.
	 *
	 * JSHint: [`camelcase`](http://jshint.com/docs/options/#camelcase)
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireCamelCaseOrUpperCaseIdentifiers": true
	 * ```
	 *
	 * ##### Valid for mode `true`
	 *
	 * ```js
	 * var camelCase = 0;
	 * var CamelCase = 1;
	 * var _camelCase = 2;
	 * var camelCase_ = 3;
	 * var UPPER_CASE = 4;
	 * ```
	 *
	 * ##### Invalid for mode `true`
	 *
	 * ```js
	 * var lower_case = 1;
	 * var Mixed_case = 2;
	 * var mixed_Case = 3;
	 * ```
	 *
	 * ##### Valid for mode `ignoreProperties`
	 *
	 * ```js
	 * var camelCase = 0;
	 * var CamelCase = 1;
	 * var _camelCase = 2;
	 * var camelCase_ = 3;
	 * var UPPER_CASE = 4;
	 * var obj.snake_case = 5;
	 * var camelCase = { snake_case: 6 };
	 * ```
	 *
	 * ##### Invalid for mode `ignoreProperties`
	 *
	 * ```js
	 * var lower_case = 1;
	 * var Mixed_case = 2;
	 * var mixed_Case = 3;
	 * var snake_case = { snake_case: 6 };
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true || options === 'ignoreProperties',
	            this.getOptionName() + ' option requires a true value or `ignoreProperties`'
	        );

	        this._ignoreProperties = (options === 'ignoreProperties');
	    },

	    getOptionName: function() {
	        return 'requireCamelCaseOrUpperCaseIdentifiers';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByType('Identifier', function(token) {
	            var value = token.value;
	            if (value.replace(/^_+|_+$/g, '').indexOf('_') === -1 || value.toUpperCase() === value) {
	                return;
	            }
	            if (this._ignoreProperties) {
	                var nextToken = file.getNextToken(token);
	                var prevToken = file.getPrevToken(token);

	                if (nextToken && nextToken.value === ':') {
	                    return;
	                }

	                if (prevToken && (prevToken.value === '.' ||
	                    prevToken.value === 'get' || prevToken.value === 'set')) {
	                    return;
	                }
	            }
	            errors.add(
	                'All identifiers must be camelCase or UPPER_CASE',
	                token.loc.start.line,
	                token.loc.start.column
	            );
	        }.bind(this));
	    }

	};


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows usage of specified keywords.
	 *
	 * Type: `Array`
	 *
	 * Values: Array of quoted keywords
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowKeywords": ["with"]
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * with (x) {
	 *     prop++;
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(keywords) {
	        assert(Array.isArray(keywords), this.getOptionName() + ' option requires array value');
	        this._keywords = keywords;
	    },

	    getOptionName: function() {
	        return 'disallowKeywords';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
	            errors.add(
	                'Illegal keyword: ' + token.value,
	                token.loc.start
	            );
	        });
	    }

	};


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows multiple blank lines in a row.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowMultipleLineBreaks": true
	 * ```
	 *
	 * ##### Valid
	 * ```js
	 * var x = 1;
	 *
	 * x++;
	 * ```
	 *
	 * ##### Invalid
	 * ```js
	 * var x = 1;
	 *
	 *
	 * x++;
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowMultipleLineBreaks';
	    },

	    check: function(file, errors) {
	        // Iterate over all tokens (including comments)
	        file.getTokens().forEach(function(token, index, tokens) {
	            // If there are no trailing tokens, exit early
	            var nextToken = tokens[index + 1];
	            if (!nextToken) {
	                return;
	            }

	            errors.assert.linesBetween({
	                token: token,
	                nextToken: nextToken,
	                atMost: 2,
	            });
	        });
	    }

	};


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows strings that span multiple lines without using concatenation.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * JSHint: [`multistr`](http://www.jshint.com/docs/options/#multistr)
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowMultipleLineStrings": true
	 * ```
	 *
	 * ##### Valid
	 * ```js
	 * var x = "multi" +
	 *         "line";
	 * var y = "single line";
	 * ```
	 *
	 * ##### Invalid
	 * ```js
	 * var x = "multi \
	 *         line";
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowMultipleLineStrings';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByType('String', function(token) {
	            if (token.loc.start.line !== token.loc.end.line) {
	                errors.add(
	                    'Multiline strings are disallowed.',
	                    token.loc.start.line,
	                    token.loc.start.column
	                );
	            }
	        });
	    }

	};


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows multiple indentation characters (tabs or spaces) between identifiers, keywords, and any other token
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowMultipleSpaces": true
	 * ```
	 *
	 * ##### Valid
	 * ```js
	 * var x = "hello";
	 * function y() {}
	 * ```
	 *
	 * ##### Invalid
	 * ```js
	 * var x  = "hello";
	 * function  y() {}
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true ||
	            typeof options === 'object' &&
	            options.allowEOLComments === true,
	            this.getOptionName() + ' option requires true value ' +
	            'or an object with `allowEOLComments` property'
	        );

	        this.allowEOLComments = options.allowEOLComments;
	    },

	    getOptionName: function() {
	        return 'disallowMultipleSpaces';
	    },

	    check: function(file, errors) {
	        // Iterate over all tokens (including comments)
	        var _this = this;
	        file.getTokens().forEach(function(token, index, tokens) {
	            // If there are no trailing tokens, exit early
	            var nextToken = tokens[index + 1];
	            if (!nextToken) {
	                return;
	            }

	            // If we are allowing EOL comments and the next token is an EOL comment skip it
	            // We don't need to check the current token since EOL comments must be on separate lines from the next one
	            if (_this.allowEOLComments && nextToken.type === 'Line') {
	                return;
	            }

	            // Verify we have at most 1 space between this token and the next (won't fail for different lines)
	            errors.assert.spacesBetween({
	                token: token,
	                nextToken: nextToken,
	                atMost: 1,
	            });
	        });
	    }

	};


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Option to check line break characters
	 *
	 * Type: `String`
	 *
	 * Values: `"CR"`, `"LF"`, `"CRLF"`
	 *
	 * #### Example
	 *
	 * ```js
	 * "validateLineBreaks": "LF"
	 * ```
	 *
	 * ##### Valid
	 * ```js
	 * var x = 1;<LF>
	 * x++;
	 * ```
	 *
	 * ##### Invalid
	 * ```js
	 * var x = 1;<CRLF>
	 * x++;
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            typeof options === 'string' || typeof options === 'object',
	            this.getOptionName() + ' option requires string or object value'
	        );

	        if (typeof options === 'string') {
	            options = { character: options };
	        }

	        var lineBreaks = {
	            CR: '\r',
	            LF: '\n',
	            CRLF: '\r\n'
	        };
	        this._allowedLineBreak = lineBreaks[options.character];

	        this._reportOncePerFile = options.reportOncePerFile !== false;
	    },

	    getOptionName: function() {
	        return 'validateLineBreaks';
	    },

	    check: function(file, errors) {
	        var lines = file.getLines();
	        if (lines.length < 2) {
	            return;
	        }

	        file.getLineBreaks().some(function(lineBreak, i) {
	            if (lineBreak !== this._allowedLineBreak) {
	                errors.add('Invalid line break', i + 1, lines[i].length);
	                return this._reportOncePerFile;
	            }
	        }, this);
	    }

	};


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires all quote marks to be either the supplied value, or consistent if `true`
	 *
	 * Types: `Boolean`, `String` or `Object`
	 *
	 * Values:
	 *  - `"\""`: all strings require double quotes
	 *  - `"'"`: all strings require single quotes
	 *  - `true`: all strings require the quote mark first encountered in the source code
	 *  - `Object`:
	 *     - `escape`: allow the "other" quote mark to be used, but only to avoid having to escape
	 *     - `mark`: the same effect as the non-object values
	 *
	 * JSHint: [`quotmark`](http://jshint.com/docs/options/#quotmark)
	 *
	 * #### Example
	 *
	 * ```js
	 * "validateQuoteMarks": "\""
	 * ```
	 * ```js
	 * "validateQuoteMarks": { "mark": "\"", "escape": true }
	 * ```
	 *
	 * ##### Valid example for mode `{ "mark": "\"", "escape": true }`
	 *
	 * ```js
	 * var x = "x";
	 * var y = '"x"';
	 * ```
	 * ##### Invalid example for mode `{ "mark": "\"", "escape": true }`
	 *
	 * ```js
	 * var x = "x";
	 * var y = 'x';
	 * ```
	 *
	 * ##### Valid example for mode `"\""` or mode `true`
	 *
	 * ```js
	 * var x = "x";
	 * ```
	 *
	 * ##### Valid example for mode `"'"` or mode `true`
	 *
	 * ```js
	 * var x = 'x';
	 * ```
	 *
	 * ##### Invalid example for mode `true`
	 *
	 * ```js
	 * var x = "x", y = 'y';
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(quoteMark) {
	        this._allowEscape = false;

	        if (typeof quoteMark === 'object') {
	            assert(
	                typeof quoteMark.escape === 'boolean' && quoteMark.mark !== undefined,
	                this.getOptionName() + ' option requires the "escape" and "mark" property to be defined'
	            );
	            this._allowEscape = quoteMark.escape;
	            quoteMark = quoteMark.mark;
	        }

	        assert(
	            quoteMark === '"' || quoteMark === '\'' || quoteMark === true,
	            this.getOptionName() + ' option requires \'"\', "\'", or boolean true'
	        );

	        this._quoteMark = quoteMark;
	    },

	    getOptionName: function() {
	        return 'validateQuoteMarks';
	    },

	    check: function(file, errors) {
	        var quoteMark = this._quoteMark;
	        var allowEscape = this._allowEscape;
	        var opposite = {
	            '"': '\'',
	            '\'': '"'
	        };

	        file.iterateTokensByType('String', function(token) {
	            var str = token.value;
	            var mark = str[0];
	            var stripped = str.substring(1, str.length - 1);

	            if (quoteMark === true) {
	                quoteMark = mark;
	            }

	            if (mark !== quoteMark) {
	                if (allowEscape && stripped.indexOf(opposite[mark]) > -1) {
	                    return;
	                }

	                errors.add(
	                    'Invalid quote mark found',
	                    token.loc.start.line,
	                    token.loc.start.column
	                );
	            }
	        });
	    }

	};


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Validates indentation for switch statements and block statements
	 *
	 * Types: `Integer`, `String` or `Object`
	 *
	 * Values:
	 *  - `Integer`: A positive number of spaces
	 *  - `String`: `"\t"` for tab indentation
	 *  - `Object`:
	 *     - `value`: (required) the same effect as the non-object values
	 *     - `includeEmptyLines`: (default: `false`) require empty lines to be indented
	 *
	 * JSHint: [`indent`](http://jshint.com/docs/options/#indent)
	 *
	 * #### Example
	 *
	 * ```js
	 * "validateIndentation": "\t"
	 * ```
	 *
	 * ##### Valid example for mode `2`
	 *
	 * ```js
	 * if (a) {
	 *   b=c;
	 *   function(d) {
	 *     e=f;
	 *   }
	 * }
	 * ```
	 *
	 * ##### Invalid example for mode `2`
	 *
	 * ```js
	 * if (a) {
	 *    b=c;
	 * function(d) {
	 *        e=f;
	 * }
	 * }
	 * ```
	 *
	 * ##### Valid example for mode `"\t"`
	 *
	 * ```js
	 * if (a) {
	 *     b=c;
	 *     function(d) {
	 *         e=f;
	 *     }
	 * }
	 * ```
	 *
	 * ##### Invalid example for mode `"\t"`
	 *
	 * ```js
	 * if (a) {
	 *      b=c;
	 * function(d) {
	 *            e=f;
	 *  }
	 * }
	 * ```
	 *
	 * ##### Valid example for mode `{ "value": "\t", "includeEmptyLines": true }`
	 * ```js
	 * if (a) {
	 *     b=c;
	 *     function(d) {
	 *         e=f;
	 *     }
	 *
	 * } // single tab character on previous line
	 * ```
	 *
	 * ##### Invalid example for mode `{ "value": "\t", "includeEmptyLines": true }`
	 * ```js
	 * if (a) {
	 *     b=c;
	 *     function(d) {
	 *         e=f;
	 *     }
	 *
	 * } // no tab character on previous line
	 * ```
	 */

	var assert = __webpack_require__(23);
	var utils = __webpack_require__(49);

	var blockParents = [
	    'IfStatement',
	    'WhileStatement',
	    'DoWhileStatement',
	    'ForStatement',
	    'ForInStatement',
	    'ForOfStatement',
	    'FunctionDeclaration',
	    'FunctionExpression',
	    'ArrowExpression',
	    'CatchClause',
	];

	var indentableNodes = {
	    BlockStatement: 'body',
	    Program: 'body',
	    ObjectExpression: 'properties',
	    ArrayExpression: 'elements',
	    SwitchStatement: 'cases',
	    SwitchCase: 'consequent'
	};

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        this._includeEmptyLines = false;

	        if (typeof options === 'object') {
	            this._includeEmptyLines = (options.includeEmptyLines === true);
	            options = options.value;
	        }

	        assert(
	            options === '\t' ||
	                (typeof options === 'number' && options > 0),
	            this.getOptionName() + ' option requires a positive number of spaces or "\\t"' +
	            ' or options object with "value" property'
	        );

	        if (typeof options === 'number') {
	            this._indentChar = ' ';
	            this._indentSize = options;
	        } else {
	            this._indentChar = '\t';
	            this._indentSize = 1;
	        }

	        this._breakIndents = null;
	        this._moduleIndents = null;
	    },

	    getOptionName: function() {
	        return 'validateIndentation';
	    },

	    check: function(file, errors) {
	        function markCheckLine(line) {
	            linesToCheck[line].check = true;
	        }

	        function markCheck(node) {
	            markCheckLine(node.loc.start.line - 1);
	        }

	        function markEndCheck(node) {
	            markCheckLine(node.loc.end.line - 1);
	        }

	        function markPush(node, indents) {
	            linesToCheck[node.loc.start.line - 1].push.push(indents);
	        }

	        function markPop(node, outdents) {
	            linesToCheck[node.loc.end.line - 1].pop.push(outdents);
	        }

	        function markPushAlt(node) {
	            linesToCheck[node.loc.start.line - 1].pushAltLine.push(node.loc.end.line - 1);
	        }

	        function markCase(caseNode, children) {
	            var outdentNode = getCaseOutdent(children);

	            if (outdentNode) {
	                // If a case statement has a `break` as a direct child and it is the
	                // first one encountered, use it as the example for all future case indentation
	                if (_this._breakIndents === null) {
	                    _this._breakIndents = (caseNode.loc.start.column === outdentNode.loc.start.column) ? 1 : 0;
	                }
	                markPop(outdentNode, _this._breakIndents);
	            } else {
	                markPop(caseNode, 0);
	            }
	        }

	        function markChildren(node) {
	            getChildren(node).forEach(function(childNode) {
	                if (childNode.loc.start.line !== node.loc.start.line) {
	                    markCheck(childNode);
	                }
	            });
	        }

	        function markKeyword(node) {
	            if (node) {
	                markCheck(file.getPrevToken(file.getFirstNodeToken(node)));
	            }
	        }

	        function isMultiline(node) {
	            return node.loc.start.line !== node.loc.end.line;
	        }

	        function getCaseOutdent(caseChildren) {
	            var outdentNode;
	            caseChildren.some(function(node) {
	                if (node.type === 'BreakStatement') {
	                    outdentNode = node;
	                    return true;
	                }
	            });

	            return outdentNode;
	        }

	        function getBlockNodeToPush(node) {
	            var parent = node.parentNode;

	            // The parent of an else is the entire if/else block. To avoid over indenting
	            // in the case of a non-block if with a block else, mark push where the else starts,
	            // not where the if starts!
	            if (parent.type === 'IfStatement' && parent.alternate === node) {
	                return node;
	            }

	            // The end line to check of a do while statement needs to be the location of the
	            // closing curly brace, not the while statement, to avoid marking the last line of
	            // a multiline while as a line to check.
	            if (parent.type === 'DoWhileStatement') {
	                return node;
	            }

	            // Detect bare blocks: a block whose parent doesn't expect blocks in its syntax specifically.
	            if (blockParents.indexOf(parent.type) === -1) {
	                return node;
	            }

	            return parent;
	        }

	        function getChildren(node) {
	            var childrenProperty = indentableNodes[node.type];
	            return node[childrenProperty];
	        }

	        function getIndentationFromLine(line) {
	            var rNotIndentChar = new RegExp('[^' + indentChar + ']');
	            var firstContent = line.search(rNotIndentChar);
	            if (firstContent === -1) {
	                firstContent = line.length;
	            }
	            return firstContent;
	        }

	        function checkIndentations() {
	            var lineAugment = 0;

	            linesToCheck.forEach(function(line, i) {
	                var lineNumber = i + 1;
	                var actualIndentation = line.indentation;
	                var expectedIndentation = getExpectedIndentation(line, actualIndentation);

	                // do not augment this line considering this line changes indentation
	                if (line.pop.length || line.push.length) {
	                    lineAugment = 0;
	                }

	                if (line.check) {
	                    errors.assert.indentation({
	                        lineNumber: lineNumber,
	                        actual: actualIndentation,
	                        expected: expectedIndentation,
	                        indentChar: indentChar
	                    });

	                    // for multiline statements, we need move subsequent lines over the correct
	                    // number of spaces to match the change made to the first line of the statement.
	                    lineAugment = expectedIndentation - actualIndentation;

	                    // correct the indentation so that future lines can be validated appropriately
	                    actualIndentation = expectedIndentation;
	                } else if (!line.empty) {
	                    // in the case that we moved a previous line over a certain number spaces,
	                    // we need to move this line over as well, but technically, it's not an error
	                    errors.assert.indentation({
	                        lineNumber: lineNumber,
	                        actual: actualIndentation,
	                        // Avoid going negative in the case that a previous line was overindented,
	                        // and now outdenting a line that is already at column zero.
	                        expected: Math.max(actualIndentation + lineAugment, 0),
	                        indentChar: indentChar,
	                        silent: true
	                    });
	                }

	                if (line.push.length) {
	                    pushExpectedIndentations(line, actualIndentation);
	                }
	            });
	        }

	        function getExpectedIndentation(line, actual) {
	            var outdent = indentSize * Math.max.apply(null, line.pop);

	            var idx = indentStack.length - 1;
	            var expected = indentStack[idx];

	            if (!Array.isArray(expected)) {
	                expected = [expected];
	            }

	            expected = expected.map(function(value) {
	                if (line.pop.length) {
	                    value -= outdent;
	                }

	                return value;
	            }).reduce(function(previous, current) {
	                // when the expected is an array, resolve the value
	                // back into a Number by checking both values are the actual indentation
	                return actual === current ? current : previous;
	            });

	            indentStack[idx] = expected;

	            line.pop.forEach(function() {
	                indentStack.pop();
	            });

	            return expected;
	        }

	        function pushExpectedIndentations(line, actualIndentation) {
	            var indents = Math.max.apply(null, line.push);

	            var expected = actualIndentation + (indentSize * indents);

	            // when a line has alternate indentations, push an array of possible values
	            // on the stack, to be resolved when checked against an actual indentation
	            if (line.pushAltLine.length) {
	                expected = [expected];
	                line.pushAltLine.forEach(function(altLine) {
	                    expected.push(linesToCheck[altLine].indentation + (indentSize * indents));
	                });
	            }

	            line.push.forEach(function() {
	                indentStack.push(expected);
	            });
	        }

	        function setModuleBody(node) {
	            if (node.body.length !== 1 || node.body[0].type !== 'ExpressionStatement' ||
	                node.body[0].expression.type !== 'CallExpression') {
	                return;
	            }

	            var callExpression = node.body[0].expression;
	            var callee = callExpression.callee;
	            var callArgs = callExpression.arguments;
	            var iffeFunction = utils.getFunctionNodeFromIIFE(callExpression);

	            if (iffeFunction) {
	                if (callArgs.length === 1 && callArgs[0].type === 'FunctionExpression') {
	                    // detect UMD Shim, where the file body is the body of the factory,
	                    // which is the sole argument to the IIFE
	                    moduleBody = callArgs[0].body;
	                } else {
	                    // full file IIFE
	                    moduleBody = iffeFunction.body;
	                }
	            }

	            // detect require/define
	            if (callee.type === 'Identifier' && callee.name.match(/^(require|define)$/)) {
	                // the define callback is the *first* functionExpression encountered,
	                // as it can be the first, second, or third argument.
	                callArgs.some(function(argument) {
	                    if (argument.type === 'FunctionExpression') {
	                        moduleBody = argument.body;
	                        return true;
	                    }
	                });
	            }

	            // set number of indents for modules by detecting
	            // whether the first statement is indented or not
	            if (moduleBody && moduleBody.body.length) {
	                _this._moduleIndents = moduleBody.body[0].loc.start.column > 0 ? 1 : 0;
	            }
	        }

	        function generateIndentations() {
	            file.iterateNodesByType('Program', function(node) {
	                if (!isMultiline(node)) {
	                    return;
	                }

	                setModuleBody(node);
	                markChildren(node);
	            });

	            file.iterateNodesByType('BlockStatement', function(node) {
	                if (!isMultiline(node)) {
	                    return;
	                }

	                var indents = node === moduleBody ? _this._moduleIndents : 1;

	                markChildren(node);
	                markPop(node, indents);
	                markPush(getBlockNodeToPush(node), indents);
	                markEndCheck(node);
	            });

	            file.iterateNodesByType('ObjectExpression', function(node) {
	                if (!isMultiline(node)) {
	                    return;
	                }

	                var children = getChildren(node);

	                // only check objects that have children and that look like they are trying to adhere
	                // to an indentation strategy, i.e. objects that have curly braces on their own lines.
	                if (!children.length || node.loc.start.line === children[0].loc.start.line ||
	                    node.loc.end.line === children[children.length - 1].loc.end.line) {
	                    return;
	                }

	                markChildren(node);
	                markPop(node, 1);
	                markPush(node, 1);
	                markEndCheck(node);
	                markPushAlt(node);
	            });

	            file.iterateNodesByType('IfStatement', function(node) {
	                markKeyword(node.alternate);
	            });

	            file.iterateNodesByType('TryStatement', function(node) {
	                if (!isMultiline(node)) {
	                    return;
	                }

	                var handler = node.handlers && node.handlers.length ? node.handlers[0] : node.handler;
	                if (handler) {
	                    markCheck(handler);
	                }
	                markKeyword(node.finalizer);
	            });

	            file.iterateNodesByType('SwitchStatement', function(node) {
	                if (!isMultiline(node)) {
	                    return;
	                }

	                var indents = 1;
	                var children = getChildren(node);

	                if (node.loc.start.column === children[0].loc.start.column) {
	                    indents = 0;
	                }

	                markChildren(node);
	                markPop(node, indents);
	                markPush(node, indents);
	                markEndCheck(node);
	            });

	            file.iterateNodesByType('SwitchCase', function(node) {
	                if (!isMultiline(node)) {
	                    return;
	                }

	                var children = getChildren(node);

	                if (children.length === 1 && children[0].type === 'BlockStatement') {
	                    return;
	                }

	                markPush(node, 1);
	                markCheck(node);
	                markChildren(node);

	                markCase(node, children);
	            });

	            // indentations inside of function expressions can be offset from
	            // either the start of the function or the end of the function, therefore
	            // mark all starting lines of functions as potential indentations
	            file.iterateNodesByType(['FunctionDeclaration', 'FunctionExpression'], function(node) {
	                markPushAlt(node);
	            });

	            if (_this._includeEmptyLines) {
	                linesToCheck.forEach(function(line) {
	                    if (line.empty) {
	                        line.check = true;
	                    }
	                });
	            }

	            // starting from the bottom, which allows back to back comments to be checked, mark comments
	            file.getComments().concat().reverse().forEach(function(node) {
	                var startLine = node.loc.start.line;
	                var firstToken = file.getFirstTokenOnLine(startLine, {includeComments: true});

	                var nextToken = file.getNextToken(firstToken, {includeComments: true});
	                var nextStartLine = nextToken.loc.start.line;

	                var nextLine = linesToCheck[nextStartLine - 1];

	                // ignore if not the only token on the line, or not right above another checked line
	                if (firstToken !== node || startLine === nextStartLine || !nextLine.check) {
	                    return;
	                }

	                // ignore if next line is a case statement, which is kind of hacky, but avoids
	                // additional complexity for what qualifies as an outdent
	                if (nextToken && nextToken.type === 'Keyword' &&
	                    (nextToken.value === 'case' || nextToken.value === 'default')) {
	                    return;
	                }

	                // ignore if above a line that both introduces and ends an ident,
	                // which catches cases like a comment above an `else if`, but not nested ifs.
	                if (nextLine.push.length && nextLine.pop.length) {
	                    return;
	                }

	                markCheck(node);
	            });
	        }

	        var _this = this;

	        var moduleBody;

	        var indentChar = this._indentChar;
	        var indentSize = this._indentSize;

	        var indentStack = [0];
	        var linesToCheck = file.getLines().map(function(line) {
	            return {
	                push: [],
	                pushAltLine: [],
	                pop: [],
	                check: false,
	                indentation: getIndentationFromLine(line),
	                empty: line.match(/^\s*$/)
	            };
	        });

	        generateIndentations();
	        checkIndentations();
	    }

	};


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires all lines to end on a non-whitespace character
	 *
	 * Types: `Boolean` or `String`
	 *
	 * Values:
	 *  - `true`
	 *  - `"ignoreEmptyLines"`: (default: `false`) allow whitespace on empty lines
	 *
	 * JSHint: [`trailing`](http://jshint.com/docs/options/#trailing)
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowTrailingWhitespace": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var foo = "blah blah";
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var foo = "blah blah"; //<-- whitespace character here
	 * ```
	 *
	 * ##### Valid for `true`
	 *
	 * ```js
	 * foo = 'bar';
	 *
	 * foo = 'baz';
	 * ```
	 *
	 * ##### Invalid for `true` but Valid for `ignoreEmptyLines`
	 *
	 * ```js
	 * foo = 'bar';
	 * \t
	 * foo = 'baz';
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true || options === 'ignoreEmptyLines',
	            this.getOptionName() + ' option requires a true value or "ignoreEmptyLines"'
	        );
	        this._ignoreEmptyLines = options === 'ignoreEmptyLines';
	    },

	    getOptionName: function() {
	        return 'disallowTrailingWhitespace';
	    },

	    check: function(file, errors) {
	        var ignoreEmptyLines = this._ignoreEmptyLines;

	        var lines = file.getLines();
	        for (var i = 0, l = lines.length; i < l; i++) {
	            if (lines[i].match(/\s$/) && !(ignoreEmptyLines && lines[i].match(/^\s*$/))) {
	                errors.add('Illegal trailing whitespace', i + 1, lines[i].length);
	            }
	        }
	    }

	};


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires lines to not contain both spaces and tabs consecutively,
	 * or spaces after tabs only for alignment if "smart"
	 *
	 * Types: `Boolean` or `String`
	 *
	 * Values: `true` or `"smart"`
	 *
	 * JSHint: [`smarttabs`](http://www.jshint.com/docs/options/#smarttabs)
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowMixedSpacesAndTabs": true
	 * ```
	 *
	 * ##### Valid example for mode `true`
	 *
	 * ```js
	 * \tvar foo = "blah blah";
	 * \s\s\s\svar foo = "blah blah";
	 * \t/**
	 * \t\s*
	 * \t\s*\/ //a single space to align the star in a multi-line comment is allowed
	 * ```
	 *
	 * ##### Invalid example for mode `true`
	 *
	 * ```js
	 * \t\svar foo = "blah blah";
	 * \s\tsvar foo = "blah blah";
	 * ```
	 *
	 * ##### Valid example for mode `"smart"`
	 *
	 * ```js
	 * \tvar foo = "blah blah";
	 * \t\svar foo = "blah blah";
	 * \s\s\s\svar foo = "blah blah";
	 * \t/**
	 * \t\s*
	 * \t\s*\/ //a single space to align the star in a multi-line comment is allowed
	 * ```
	 *
	 * ##### Invalid example for mode `"smart"`
	 *
	 * ```js
	 * \s\tsvar foo = "blah blah";
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true || options === 'smart',
	            this.getOptionName() + ' option requires a true value or "smart"'
	        );

	        this._options = options;
	    },

	    getOptionName: function() {
	        return 'disallowMixedSpacesAndTabs';
	    },

	    check: function(file, errors) {
	        var test = this._options === true ?
	            (/ \t|\t [^\*]|\t $/) :
	            (/ \t/);

	        file.getLinesWithCommentsRemoved().forEach(function(line, i) {
	            if (line.match(test)) {
	                errors.add('Mixed spaces and tabs found', i + 1, 0);
	            }
	        });
	    }

	};


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires placing keywords on a new line.
	 *
	 * Type: `Array`
	 *
	 * Values: Array of quoted keywords
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireKeywordsOnNewLine": ["else"]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * if (x < 0) {
	 *     x++;
	 * }
	 * else {
	 *     x--;
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (x < 0) {
	 *     x++;
	 * } else {
	 *     x--;
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(keywords) {
	        assert(Array.isArray(keywords), this.getOptionName() + ' option requires array value');
	        this._keywords = keywords;
	    },

	    getOptionName: function() {
	        return 'requireKeywordsOnNewLine';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
	            errors.assert.differentLine({
	                token: file.getPrevToken(token),
	                nextToken: token
	            });
	        });
	    }

	};


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows placing keywords on a new line.
	 *
	 * Type: `Array`
	 *
	 * Values: Array of quoted keywords
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowKeywordsOnNewLine": ["else"]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * if (x < 0) {
	 *     x++;
	 * } else {
	 *     x--;
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (x < 0) {
	 *     x++;
	 * }
	 * else {
	 *     x--;
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(keywords) {
	        assert(Array.isArray(keywords), this.getOptionName() + ' option requires array value');
	        this._keywords = keywords;
	    },

	    getOptionName: function() {
	        return 'disallowKeywordsOnNewLine';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
	            var prevToken = file.getPrevToken(token);

	            // Special case for #905, even though it contradicts rule meaning,
	            // it makes more sense that way.
	            if (token.value === 'else' && prevToken.value !== '}') {
	                return;
	            }

	            // Special cases for #885, using while as the keyword contradicts rule meaning
	            // but it is more efficient and reduces complexity of the code in this rule
	            if (token.value === 'while') {
	                var nodes = file.getNodesByFirstToken(token);

	                if (nodes.length === 0) {
	                    // "while" that is part of a do will not return nodes as it is not a start token
	                    if (prevToken.value !== '}') {
	                        // allow "while" that is part of a "do while" with no braces to succeed
	                        return;
	                    }
	                } else {
	                    // it is a "while" statement that is not part of a "do while"
	                    // , allow it to succeed even though it contradicts rule meaning
	                    return;
	                }
	            }

	            errors.assert.sameLine({
	                token: prevToken,
	                nextToken: token
	            });
	        });
	    }

	};


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires placing line feed at file end.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireLineFeedAtFileEnd": true
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireLineFeedAtFileEnd';
	    },

	    check: function(file, errors) {
	        var lastToken = file.getLastToken();
	        var prevToken = file.getPrevToken(lastToken, {includeComments: true});
	        errors.assert.differentLine({
	            token: prevToken,
	            nextToken: lastToken,
	            message: 'Missing line feed at file end'
	        });
	    }

	};


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires all lines to be at most the number of characters specified
	 *
	 * Types: `Integer` or `Object`
	 *
	 * Values:
	 *  - `Integer`: lines should be at most the number of characters specified
	 *  - `Object`:
	 *     - `value`: (required) lines should be at most the number of characters specified
	 *     - `tabSize`: (default: `1`) considered the tab character as number of specified spaces
	 *     - `allowComments`: (default: `false`) allows comments to break the rule
	 *     - `allowUrlComments`: (default: `false`) allows comments with long urls to break the rule
	 *     - `allowRegex`: (default: `false`) allows regular expression literals to break the rule
	 *
	 * JSHint: [`maxlen`](http://jshint.com/docs/options/#maxlen)
	 *
	 * #### Example
	 *
	 * ```js
	 * "maximumLineLength": 40
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var aLineOf40Chars = 123456789012345678;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var aLineOf41Chars = 1234567890123456789;
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(maximumLineLength) {
	        this._tabSize = '';
	        this._allowRegex = false;
	        this._allowComments = false;
	        this._allowUrlComments = false;

	        if (typeof maximumLineLength === 'object') {
	            assert(
	                typeof maximumLineLength.value === 'number',
	                this.getOptionName() + ' option requires the "value" property to be defined'
	            );

	            this._maximumLineLength = maximumLineLength.value;
	            var tabSize = maximumLineLength.tabSize || 0;

	            while (tabSize--) {
	                this._tabSize += ' ';
	            }

	            this._allowRegex = (maximumLineLength.allowRegex === true);
	            this._allowComments = (maximumLineLength.allowComments === true);
	            this._allowUrlComments = (maximumLineLength.allowUrlComments === true);
	        } else {
	            assert(
	                typeof maximumLineLength === 'number',
	                this.getOptionName() + ' option requires number value or options object'
	            );

	            this._maximumLineLength = maximumLineLength;
	        }
	    },

	    getOptionName: function() {
	        return 'maximumLineLength';
	    },

	    check: function(file, errors) {
	        var maximumLineLength = this._maximumLineLength;

	        var line;
	        var lines = this._allowComments ?
	            file.getLinesWithCommentsRemoved() : file.getLines();

	        // This check should not be destructive
	        lines = lines.slice();

	        if (this._allowRegex) {
	            file.iterateTokensByType('RegularExpression', function(token) {
	                for (var i = token.loc.start.line; i <= token.loc.end.line; i++) {
	                    lines[i - 1] = '';
	                }
	            });
	        }

	        if (this._allowUrlComments) {
	            file.iterateTokensByType(['Line', 'Block'], function(comment) {
	                for (var i = comment.loc.start.line; i <= comment.loc.end.line; i++) {
	                    lines[i - 1] = lines[i - 1].replace(/(http|https|ftp):\/\/[^\s$]+/, '');
	                }
	            });
	        }

	        for (var i = 0, l = lines.length; i < l; i++) {
	            line = this._tabSize ? lines[i].replace(/\t/g, this._tabSize) : lines[i];

	            if (line.length > maximumLineLength) {
	                errors.add(
	                    'Line must be at most ' + maximumLineLength + ' characters',
	                    i + 1,
	                    lines[i].length
	                );
	            }
	        }
	    }

	};


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires the variable to be the right hand operator when doing a boolean comparison
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireYodaConditions": true
	 * ```
	 *
	 * ##### Valid
	 * ```js
	 * if (1 == a) {
	 *     return
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (a == 1) {
	 *     return
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	        this._operatorIndex = {
	            '==': true,
	            '===': true,
	            '!=': true,
	            '!==': true,
	            '>': true,
	            '<': true,
	            '>=': true,
	            '<=': true
	        };
	    },

	    getOptionName: function() {
	        return 'requireYodaConditions';
	    },

	    check: function(file, errors) {
	        var operators = this._operatorIndex;
	        file.iterateNodesByType('BinaryExpression', function(node) {
	            if (operators[node.operator]) {
	                if (node.right.type === 'Literal' ||
	                    (node.right.type === 'Identifier' && node.right.name === 'undefined')
	                ) {
	                    errors.add('Not yoda condition', node.left.loc.start);
	                }
	            }
	        });
	    }

	};


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires the variable to be the left hand operator when doing a boolean comparison
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowYodaConditions": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * if (a == 1) {
	 *     return
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (1 == a) {
	 *     return
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	        this._operatorIndex = {
	            '==': true,
	            '===': true,
	            '!=': true,
	            '!==': true,
	            '>': true,
	            '<': true,
	            '>=': true,
	            '<=': true
	        };
	    },

	    getOptionName: function() {
	        return 'disallowYodaConditions';
	    },

	    check: function(file, errors) {
	        var operators = this._operatorIndex;
	        file.iterateNodesByType('BinaryExpression', function(node) {
	            if (operators[node.operator]) {
	                if (node.left.type === 'Literal' ||
	                    (node.left.type === 'Identifier' && node.left.name === 'undefined')
	                ) {
	                    errors.add('Yoda condition', node.left.loc.start);
	                }
	            }
	        });
	    }

	};


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space after opening square bracket and before closing.
	 *
	 * Types: `Boolean` or `Object`
	 *
	 * Values: `true` for strict mode, or `"allExcept": [ "[", "]"]`
	 * ignores closing brackets in a row.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpacesInsideBrackets": true
	 *
	 * // or
	 *
	 * "requireSpacesInsideBrackets": {
	 *     "allExcept": [ "[", "]", "{", "}" ]
	 * }
	 * ```
	 *
	 * ##### Valid for mode `true`
	 *
	 * ```js
	 * var x = [ 1 ];
	 * ```
	 *
	 * ##### Valid for mode `{ allExcept": [ "[", "]", "{", "}" ] }`
	 *
	 * ```js
	 * var x = [[ 1 ], [ 2 ]];
	 * var x = [{ a: 1 }, { b: 2}];
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = [1];
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        var isObject = typeof value === 'object';

	        var error = this.getOptionName() + ' rule requires string value true or object';

	        if (isObject) {
	            assert('allExcept' in value, error);
	        } else {
	            assert(value === true, error);
	        }

	        this._exceptions = {};

	        if (isObject) {
	            (value.allExcept || []).forEach(function(value) {
	                this._exceptions[value] = true;
	            }, this);
	        }
	    },

	    getOptionName: function() {
	        return 'requireSpacesInsideBrackets';
	    },

	    check: function(file, errors) {
	        var exceptions = this._exceptions;

	        file.iterateTokenByValue('[', function(token) {
	            var nextToken = file.getNextToken(token);
	            var value = nextToken.value;

	            if (value in exceptions) {
	                return;
	            }

	            // Skip for empty array brackets
	            if (value === ']') {
	                return;
	            }

	            errors.assert.spacesBetween({
	                token: token,
	                nextToken: nextToken,
	                exactly: 1,
	                message: 'One space required after opening bracket'
	            });
	        });

	        file.iterateTokenByValue(']', function(token) {
	            var prevToken = file.getPrevToken(token);
	            var value = prevToken.value;

	            if (value in exceptions) {
	                return;
	            }

	            // Skip for empty array brackets
	            if (value === '[') {
	                return;
	            }

	            errors.assert.spacesBetween({
	                token: prevToken,
	                nextToken: token,
	                exactly: 1,
	                message: 'One space required before closing bracket'
	            });
	        });
	    }
	};


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space after opening object curly brace and before closing.
	 *
	 * Types: `Object` or `String`
	 *
	 * Values: `"all"` for strict mode, `"allButNested"` (*deprecated* use `"allExcept": ['}']`)
	 * ignores closing brackets in a row.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpacesInsideObjectBrackets": {
	 *     "allExcept": [ "}", ")" ]
	 * }
	 *
	 * // or
	 * "requireSpacesInsideObjectBrackets": true | "all" | "allButNested"
	 * ```
	 *
	 * ##### Valid for mode `"all"`
	 *
	 * ```js
	 * var x = { a: { b: 1 } };
	 * ```
	 *
	 * ##### Valid for mode `"allButNested"`
	 *
	 * ```js
	 * var x = { a: { b: 1 }};
	 * ```
	 *
	 * ##### Valid for mode `"allExcept": [ "}", ")" ]`
	 *
	 * ```js
	 * var x = { a: (b ? 1 : 2)};
	 * var x = { a: { b: 1 }};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = {a: 1};
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        var mode;
	        var modes = {
	            'all': true,
	            'allButNested': true
	        };
	        var isObject = typeof value === 'object';

	        var error = this.getOptionName() + ' rule' +
	        ' requires string value \'all\' or \'allButNested\' or object';

	        if (typeof value === 'string') {
	            assert(modes[value], error);

	        } else if (isObject) {
	            assert('allExcept' in value, error);
	        } else {
	            assert(false, error);
	        }

	        this._exceptions = {};

	        if (isObject) {
	            (value.allExcept || []).forEach(function(value) {
	                this._exceptions[value] = true;
	            }, this);

	        } else {
	            mode = value;
	        }

	        if (mode === 'allButNested') {
	            this._exceptions['}'] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'requireSpacesInsideObjectBrackets';
	    },

	    check: function(file, errors) {
	        var exceptions = this._exceptions;

	        file.iterateNodesByType('ObjectExpression', function(node) {
	            var openingBracket = file.getFirstNodeToken(node);
	            var nextToken = file.getNextToken(openingBracket);

	            // Don't check empty object
	            if (nextToken.value === '}') {
	                return;
	            }

	            errors.assert.spacesBetween({
	                token: openingBracket,
	                nextToken: nextToken,
	                exactly: 1,
	                message: 'One space required after opening curly brace'
	            });

	            var closingBracket = file.getLastNodeToken(node);
	            var prevToken = file.getPrevToken(closingBracket);

	            if (prevToken.value in exceptions) {
	                return;
	            }

	            errors.assert.spacesBetween({
	                token: prevToken,
	                nextToken: closingBracket,
	                exactly: 1,
	                message: 'One space required before closing curly brace'
	            });
	        });
	    }
	};


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space after opening array square bracket and before closing.
	 *
	 * Types: `String` or `Object`
	 *
	 * Values: `"all"` for strict mode, `"allButNested"` (*deprecated* use `"allExcept": [ "[", "]"]`)
	 * ignores closing brackets in a row.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpacesInsideArrayBrackets": "all"
	 *
	 * // or
	 *
	 * "requireSpacesInsideArrayBrackets": {
	 *     "allExcept": [ "[", "]", "{", "}" ]
	 * }
	 * ```
	 *
	 * ##### Valid for mode `"all"`
	 *
	 * ```js
	 * var x = [ 1 ];
	 * ```
	 *
	 * ##### Valid for mode `"allButNested"`
	 *
	 * ```js
	 * var x = [[ 1 ], [ 2 ]];
	 * ```
	 *
	 * ##### Valid for mode `"allExcept"`
	 *
	 * ```js
	 * var x = [[ 1 ], [ 2 ]];
	 * var x = [{ a: 1 }, { b: 2}];
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = [1];
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        var mode;
	        var modes = {
	            'all': true,
	            'allButNested': true
	        };
	        var isObject = typeof value === 'object';

	        var error = this.getOptionName() + ' rule' +
	        ' requires string value "all" or "allButNested" or object';

	        if (typeof value === 'string') {
	            assert(modes[value], error);

	        } else if (isObject) {
	            assert('allExcept' in value, error);
	        } else {
	            assert(false, error);
	        }

	        this._exceptions = {};

	        if (isObject) {
	            (value.allExcept || []).forEach(function(value) {
	                this._exceptions[value] = true;
	            }, this);

	        } else {
	            mode = value;
	        }

	        if (mode === 'allButNested') {
	            this._exceptions['['] = this._exceptions[']'] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'requireSpacesInsideArrayBrackets';
	    },

	    check: function(file, errors) {
	        var exceptions = this._exceptions;

	        file.iterateNodesByType('ArrayExpression', function(node) {
	            var openBracket = file.getFirstNodeToken(node);
	            var afterOpen = file.getNextToken(openBracket, {includeComments: true});
	            var closeBracket = file.getLastNodeToken(node);
	            var beforeClose = file.getPrevToken(closeBracket, {includeComments: true});

	            // Skip for empty array brackets
	            if (afterOpen.value === ']') {
	                return;
	            }

	            if (!(afterOpen.value in exceptions)) {
	                errors.assert.spacesBetween({
	                    token: openBracket,
	                    nextToken: afterOpen,
	                    exactly: 1,
	                    message: 'One space required after opening bracket'
	                });
	            }

	            if (!(beforeClose.value in exceptions)) {
	                errors.assert.spacesBetween({
	                    token: beforeClose,
	                    nextToken: closeBracket,
	                    exactly: 1,
	                    message: 'One space required before closing bracket'
	                });
	            }
	        });
	    }
	};


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space after opening round bracket and before closing.
	 *
	 * Types: `Object` or `String`
	 *
	 * Values: `"all"` for strict mode, `"allButNested"`
	 * (*deprecated* use `"except": ['(', ')']`) ignores nested brackets in a row, you could also specify token exceptions.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpacesInsideParentheses": {
	 *     "all": true,
	 *     "except": [ "{", "}" ]
	 * }
	 * ```
	 *
	 * ##### Valid for mode `"all"`
	 *
	 * ```js
	 * var x = Math.pow( ( 1 + 2 ), ( 3 + 4 ) );
	 * ```
	 *
	 * ##### Valid for mode `"allButNested"`
	 *
	 * ```js
	 * var x = Math.pow(( 1 + 2 ), ( 3 + 4 ));
	 * ```
	 *
	 * ##### Valid for mode `"all"` with `except`
	 *
	 * ```js
	 * var x = Math.pow( foo({ test: 1 }) );
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = Math.pow(1 + 2, 3 + 4);
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        var mode;
	        var modes = {
	            'all': true,
	            'allButNested': true
	        };
	        var isObject = typeof value === 'object';

	        var error = this.getOptionName() + ' rule' +
	        ' requires string value \'all\' or \'allButNested\' or object';

	        if (typeof value === 'string') {
	            assert(modes[value], error);

	        } else if (isObject) {
	            assert(
	                'all' in value || 'allButNested' in value,
	                error
	            );
	        } else {
	            assert(false, error);
	        }

	        this._exceptions = {};

	        if (isObject) {
	            mode = 'all' in value ? 'all' : 'allButNested';

	            (value.except || []).forEach(function(value) {
	                this._exceptions[value] = true;
	            }, this);

	        } else {
	            mode = value;
	        }

	        if (mode === 'allButNested') {
	            this._exceptions[')'] = this._exceptions['('] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'requireSpacesInsideParentheses';
	    },

	    check: function(file, errors) {
	        var exceptions = this._exceptions;

	        file.iterateTokenByValue('(', function(token) {
	            var nextToken = file.getNextToken(token, {includeComments: true});
	            var value = nextToken.value;

	            if (value in exceptions) {
	                return;
	            }

	            // Skip for empty parentheses
	            if (value === ')') {
	                return;
	            }

	            errors.assert.whitespaceBetween({
	                token: token,
	                nextToken: nextToken,
	                message: 'Missing space after opening round bracket'
	            });
	        });

	        file.iterateTokenByValue(')', function(token) {
	            var prevToken = file.getPrevToken(token, {includeComments: true});
	            var value = prevToken.value;

	            if (value in exceptions) {

	                // Special case - foo( object[i] )
	                if (!(
	                    value === ']' &&
	                    file.getNodeByRange(token.range[0] - 1).type === 'MemberExpression'
	                )) {
	                    return;
	                }
	            }

	            // Skip for empty parentheses
	            if (value === '(') {
	                return;
	            }

	            errors.assert.whitespaceBetween({
	                token: prevToken,
	                nextToken: token,
	                message: 'Missing space before closing round bracket'
	            });
	        });
	    }
	};


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space after opening square bracket and before closing.
	 *
	 * Types: `Boolean` or `Object`
	 *
	 * Values: `true` for strict mode, or `"allExcept": [ "[", "]" ]`
	 * ignores closing brackets in a row.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpacesInsideBrackets": true
	 *
	 * // or
	 *
	 * "disallowSpacesInsideBrackets": {
	 *     "allExcept": [ "[", "]", "{", "}" ]
	 * }
	 * ```
	 *
	 * ##### Valid for mode `true`
	 *
	 * ```js
	 * var x = [[1]];
	 * ```
	 *
	 * ##### Valid for mode `{ allExcept": [ "[", "]", "{", "}" ] }`
	 *
	 * ```js
	 * var x = [ [1] ];
	 * var x = [ { a: 1 } ];
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = [ [ 1 ] ];
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        var isObject = typeof value === 'object';

	        var error = this.getOptionName() + ' rule requires string value true or object';

	        if (isObject) {
	            assert('allExcept' in value, error);
	        } else {
	            assert(value === true, error);
	        }

	        this._exceptions = {};

	        if (isObject) {
	            (value.allExcept || []).forEach(function(value) {
	                this._exceptions[value] = true;
	            }, this);
	        }
	    },

	    getOptionName: function() {
	        return 'disallowSpacesInsideBrackets';
	    },

	    check: function(file, errors) {
	        var exceptions = this._exceptions;

	        file.iterateTokenByValue('[', function(token) {
	            var nextToken = file.getNextToken(token);
	            var value = nextToken.value;

	            if (value in exceptions) {
	                return;
	            }

	            // Skip for empty array brackets
	            if (value === ']') {
	                return;
	            }

	            errors.assert.noWhitespaceBetween({
	                token: token,
	                nextToken: nextToken,
	                message: 'Illegal space after opening bracket'
	            });
	        });

	        file.iterateTokenByValue(']', function(token) {
	            var prevToken = file.getPrevToken(token);
	            var value = prevToken.value;

	            if (value in exceptions) {
	                return;
	            }

	            // Skip for empty array brackets
	            if (value === '[') {
	                return;
	            }

	            errors.assert.noWhitespaceBetween({
	                token: prevToken,
	                nextToken: token,
	                message: 'Illegal space before closing bracket'
	            });
	        });
	    }
	};


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space after opening object curly brace and before closing.
	 *
	 * Types: `Object`, `Boolean` or `String`
	 *
	 * Values: `"all"` or `true` for strict mode, `"nested"` (*deprecated* use `"allExcept": ['}']`)
	 * ignores closing brackets in a row.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpacesInsideObjectBrackets": {
	 *     "allExcept": [ "}", ")" ]
	 * }
	 *
	 * // or
	 * "disallowSpacesInsideObjectBrackets": true | "all" | "nested"
	 * ```
	 *
	 * ##### Valid for mode `"all"`
	 *
	 * ```js
	 * var x = {a: {b: 1}};
	 * ```
	 *
	 * ##### Valid for mode `"nested"`
	 *
	 * ```js
	 * var x = {a: {b: 1} };
	 * ```
	 *
	 * ##### Valid for mode `"allExcept": ["}"]`
	 *
	 * ```js
	 * var x = {a: {b: 1} };
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = { a: { b: 1 } };
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        var mode;
	        var modes = {
	            'all': true,
	            'nested': true
	        };
	        var isObject = typeof value === 'object';

	        var error = this.getOptionName() + ' rule' +
	        ' requires string "all" or "nested", true value or object';

	        if (typeof value === 'string' || value === true) {
	            assert(modes[value === true ? 'all' : value], error);

	        } else if (isObject) {
	            assert('allExcept' in value, error);
	        } else {
	            assert(false, error);
	        }

	        this._exceptions = {};

	        if (isObject) {
	            (value.allExcept || []).forEach(function(value) {
	                this._exceptions[value] = true;
	            }, this);

	        } else {
	            mode = value;
	        }

	        if (mode === 'nested') {
	            this._exceptions['}'] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'disallowSpacesInsideObjectBrackets';
	    },

	    check: function(file, errors) {
	        var exceptions = this._exceptions;

	        file.iterateNodesByType('ObjectExpression', function(node) {
	            var openingBracket = file.getFirstNodeToken(node);
	            var nextToken = file.getNextToken(openingBracket);

	            errors.assert.noWhitespaceBetween({
	                token: openingBracket,
	                nextToken: nextToken,
	                message: 'Illegal space after opening curly brace'
	            });

	            var closingBracket = file.getLastNodeToken(node);
	            var prevToken = file.getPrevToken(closingBracket);

	            if (prevToken.value in exceptions) {
	                return;
	            }

	            errors.assert.noWhitespaceBetween({
	                token: prevToken,
	                nextToken: closingBracket,
	                message: 'Illegal space before closing curly brace'
	            });
	        });
	    }
	};


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space after opening array square bracket and before closing.
	 *
	 * Types: `Boolean`, `String` or `Object`
	 *
	 * Values: `"all"` or `true` for strict mode, `"nested"` (*deprecated* use `"allExcept": [ "[", "]" ]`)
	 * ignores closing brackets in a row.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpacesInsideArrayBrackets": "all"
	 *
	 * // or
	 *
	 * "disallowSpacesInsideArrayBrackets": {
	 *     "allExcept": [ "[", "]", "{", "}" ]
	 * }
	 * ```
	 *
	 * ##### Valid for mode `"all"`
	 *
	 * ```js
	 * var x = [[1]];
	 * ```
	 *
	 *
	 * ##### Valid for mode `"nested"`
	 *
	 * ```js
	 * var x = [ [1] ];
	 * ```
	 *
	 * ##### Valid for mode `"allExcept"`
	 *
	 * ```js
	 * var x = [ [1] ];
	 * var x = [ { a: 1 } ];
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = [ [ 1 ] ];
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        var mode;
	        var modes = {
	            'all': true,
	            'nested': true
	        };
	        var isObject = typeof value === 'object';

	        var error = this.getOptionName() + ' rule' +
	        ' requires string value "all" or "nested" or object';

	        if (typeof value === 'string' || value === true) {
	            assert(modes[value === true ? 'all' : value], error);

	        } else if (isObject) {
	            assert('allExcept' in value, error);
	        } else {
	            assert(false, error);
	        }

	        this._exceptions = {};

	        if (isObject) {
	            (value.allExcept || []).forEach(function(value) {
	                this._exceptions[value] = true;
	            }, this);

	        } else {
	            mode = value;
	        }

	        if (mode === 'nested') {
	            this._exceptions['['] = this._exceptions[']'] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'disallowSpacesInsideArrayBrackets';
	    },

	    check: function(file, errors) {
	        var exceptions = this._exceptions;

	        file.iterateNodesByType('ArrayExpression', function(node) {
	            var openBracket = file.getFirstNodeToken(node);
	            var afterOpen = file.getNextToken(openBracket, {includeComments: true});
	            var closeBracket = file.getLastNodeToken(node);
	            var beforeClose = file.getPrevToken(closeBracket, {includeComments: true});

	            // Skip for empty array brackets
	            if (afterOpen.value === ']') {
	                return;
	            }

	            if (!(afterOpen.value in exceptions)) {
	                errors.assert.noWhitespaceBetween({
	                    token: openBracket,
	                    nextToken: afterOpen,
	                    message: 'Illegal space after opening bracket'
	                });
	            }

	            if (!(beforeClose.value in exceptions)) {
	                errors.assert.noWhitespaceBetween({
	                    token: beforeClose,
	                    nextToken: closeBracket,
	                    message: 'Illegal space before closing bracket'
	                });
	            }
	        });
	    }
	};


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space after opening round bracket and before closing.
	 *
	 * Types: `Object` or `Boolean`
	 *
	 * Values: Either `true` or Object with `"only"` property as an array of tokens
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpacesInsideParentheses": true
	 * ```
	 *
	 * ##### Valid for `true` value
	 *
	 * ```js
	 * var x = (1 + 2) * 3;
	 * ```
	 *
	 * ##### Valid for `only` value
	 *
	 * ```js
	 * "disallowSpacesInsideParentheses": { "only": [ "{", "}" ] }
	 * ```
	 *
	 * ```js
	 * var x = ( 1 + 2 );
	 * var x = foo({});
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = foo( {} );
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(option) {
	        var isObject = typeof option === 'object';

	        var error = this.getOptionName() + ' option requires' +
	            ' true or object value with "only" properties ';

	        // backcompat for 1.10: {all: true} #1027
	        if (isObject && option.all === true) {
	            option = true;
	        }

	        if (typeof option === 'boolean') {
	            assert(option === true, error);
	        } else if (isObject) {
	            assert('only' in option, error);
	        } else {
	            assert(false, error);
	        }

	        if (option.only) {
	            this._only = {};
	            (option.only).forEach(function(value) {
	                this._only[value] = true;
	            }, this);
	        } else {
	            this._only = null;
	        }
	    },

	    getOptionName: function() {
	        return 'disallowSpacesInsideParentheses';
	    },

	    check: function(file, errors) {
	        var only = this._only;

	        file.iterateTokenByValue('(', function(token) {
	            var nextToken = file.getNextToken(token, {includeComments: true});
	            var value = nextToken.value;

	            if (only && !(value in only)) {
	                return;
	            }

	            errors.assert.noWhitespaceBetween({
	                token: token,
	                nextToken: nextToken,
	                message: 'Illegal space after opening round bracket'
	            });
	        });

	        file.iterateTokenByValue(')', function(token) {
	            var prevToken = file.getPrevToken(token, {includeComments: true});
	            var value = prevToken.value;

	            if (only) {
	                if (!(value in only)) {
	                    return;
	                }

	                if (
	                    value === ']' &&
	                    file.getNodeByRange(prevToken.range[0]).type === 'MemberExpression'
	                ) {
	                    return;
	                }
	            }

	            errors.assert.noWhitespaceBetween({
	                token: prevToken,
	                nextToken: token,
	                message: 'Illegal space before closing round bracket'
	            });
	        });
	    }

	};


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires blocks to begin and end with a newline
	 *
	 * Types: `Boolean` or `Integer`
	 *
	 * Values: `true` validates all non-empty blocks,
	 * `Integer` specifies a minimum number of statements in the block before validating.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireBlocksOnNewline": true
	 * ```
	 *
	 * ##### Valid for mode `true`
	 *
	 * ```js
	 * if (true) {
	 *     doSomething();
	 * }
	 * var abc = function() {};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (true) {doSomething();}
	 * ```
	 *
	 * ##### Valid for mode `1`
	 *
	 * ```js
	 * if (true) {
	 *     doSomething();
	 *     doSomethingElse();
	 * }
	 * if (true) { doSomething(); }
	 * var abc = function() {};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (true) { doSomething(); doSomethingElse(); }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true || typeof options === 'number',
	            this.getOptionName() + ' option requires the value true or an Integer'
	        );

	        this._minStatements = options === true ? 0 : options;
	    },

	    getOptionName: function() {
	        return 'requireBlocksOnNewline';
	    },

	    check: function(file, errors) {
	        var minStatements = this._minStatements;

	        file.iterateNodesByType('BlockStatement', function(node) {
	            if (node.body.length <= minStatements) {
	                return;
	            }

	            var openingBracket = file.getFirstNodeToken(node);
	            var nextToken = file.getNextToken(openingBracket);

	            errors.assert.differentLine({
	                token: openingBracket,
	                nextToken: nextToken,
	                message: 'Missing newline after opening curly brace'
	            });

	            var closingBracket = file.getLastNodeToken(node);
	            var prevToken = file.getPrevToken(closingBracket);

	            errors.assert.differentLine({
	                token: prevToken,
	                nextToken: closingBracket,
	                message: 'Missing newline before closing curly brace'
	            });
	        });
	    }

	};


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space after object keys.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpaceAfterObjectKeys": true
	 * ```
	 *
	 * ##### Valid
	 * ```js
	 * var x = {a : 1};
	 * ```
	 * ##### Invalid
	 * ```js
	 * var x = {a: 1};
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireSpaceAfterObjectKeys';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('ObjectExpression', function(node) {
	            node.properties.forEach(function(property) {
	                if (property.shorthand || property.method || property.kind !== 'init') {
	                    return;
	                }

	                var token = file.getFirstNodeToken(property.key);
	                errors.assert.whitespaceBetween({
	                    token: token,
	                    nextToken: file.getNextToken(token),
	                    message: 'Missing space after key'
	                });
	            });
	        });
	    }

	};


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space after object keys.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpaceBeforeObjectValues": true
	 * ```
	 *
	 * ##### Valid
	 * ```js
	 * var x = {a: 1};
	 * ```
	 * ##### Invalid
	 * ```js
	 * var x = {a:1};
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireSpaceBeforeObjectValues';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('ObjectExpression', function(node) {
	            node.properties.forEach(function(property) {
	                if (property.shorthand || property.method || property.kind !== 'init') {
	                    return;
	                }

	                var keyToken = file.getFirstNodeToken(property.key);
	                var colon = file.findNextToken(keyToken, 'Punctuator', ':');

	                errors.assert.whitespaceBetween({
	                    token: colon,
	                    nextToken: file.getNextToken(colon),
	                    message: 'Missing space after key colon'
	                });
	            });
	        });
	    }

	};


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space after object keys.
	 *
	 * Types: `Boolean` or `String`
	 *
	 * Values:
	 *  - `true`
	 *  - `"ignoreSingleLine"` ignores objects if the object only takes up a single line
	 *  - `"ignoreMultiLine"` ignores objects if the object takes up multiple lines
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpaceAfterObjectKeys": true
	 * ```
	 *
	 * ##### Valid
	 * ```js
	 * var x = {a: 1};
	 * ```
	 * ##### Invalid
	 * ```js
	 * var x = {a : 1};
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(disallow) {
	        var modes = {
	            'ignoreSingleLine': 'ignoreSingleLine',
	            'ignoreMultiLine': 'ignoreMultiLine'
	        };
	        assert(
	            disallow === true || typeof disallow === 'string' && modes[disallow],
	            this.getOptionName() +
	            ' option requires true value requires one of the following values: ' +
	            Object.keys(modes).join(', ')
	        );
	        this._mode = disallow === true ? true : modes[disallow];
	    },

	    getOptionName: function() {
	        return 'disallowSpaceAfterObjectKeys';
	    },

	    check: function(file, errors) {
	        var mode = this._mode;
	        file.iterateNodesByType('ObjectExpression', function(node) {
	            node.properties.forEach(function(property) {
	                if (property.shorthand || property.method || property.kind !== 'init') {
	                    return;
	                }
	                if (mode === 'ignoreSingleLine' && node.loc.start.line === node.loc.end.line) {
	                    return;
	                }
	                if (mode === 'ignoreMultiLine' && node.loc.start.line !== node.loc.end.line) {
	                    return;
	                }

	                var token = file.getFirstNodeToken(property.key);
	                errors.assert.noWhitespaceBetween({
	                    token: token,
	                    nextToken: file.getNextToken(token),
	                    message: 'Illegal space after key',
	                    disallowNewLine: true
	                });
	            });
	        });
	    }

	};


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space after object keys.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpaceBeforeObjectValues": true
	 * ```
	 *
	 * ##### Valid
	 * ```js
	 * var x = {a:1};
	 * ```
	 * ##### Invalid
	 * ```js
	 * var x = {a: 1};
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(disallow) {
	        assert(
	            disallow === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowSpaceBeforeObjectValues';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('ObjectExpression', function(node) {
	            node.properties.forEach(function(property) {
	                if (property.shorthand || property.method || property.kind !== 'init') {
	                    return;
	                }

	                var keyToken = file.getFirstNodeToken(property.key);
	                var colon = file.findNextToken(keyToken, 'Punctuator', ':');

	                errors.assert.noWhitespaceBetween({
	                    token: colon,
	                    nextToken: file.getNextToken(colon),
	                    message: 'Illegal space after key colon'
	                });
	            });
	        });
	    }

	};


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows quoted keys in object if possible.
	 *
	 * Types: `String` or `Boolean`
	 *
	 * Values:
	 *
	 *  - `true` for strict mode
	 *  - `"allButReserved"` allows ES3+ reserved words to remain quoted which is helpful
	 *    when using this option with JSHint's `es3` flag.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowQuotedKeysInObjects": true
	 * ```
	 *
	 * ##### Valid for mode `true`
	 *
	 * ```js
	 * var x = { a: { default: 1 } };
	 * ```
	 *
	 * ##### Valid for mode `"allButReserved"`
	 *
	 * ```js
	 * var x = {a: 1, 'default': 2};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = {'a': 1};
	 * ```
	 */

	var assert = __webpack_require__(23);
	var utils = __webpack_require__(49);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true || options === 'allButReserved',
	            this.getOptionName() + ' option requires a true value or "allButReserved"'
	        );

	        this._mode = options;
	    },

	    getOptionName: function() {
	        return 'disallowQuotedKeysInObjects';
	    },

	    check: function(file, errors) {
	        var KEY_NAME_RE = /^(0|[1-9][0-9]*|[a-zA-Z_$]+[\w$]*)$/; // number or identifier
	        var mode = this._mode;

	        file.iterateNodesByType('ObjectExpression', function(node) {
	            node.properties.forEach(function(prop) {
	                var key = prop.key;
	                if (key.type === 'Literal' &&
	                    typeof key.value === 'string' &&
	                    KEY_NAME_RE.test(key.value)
	                ) {
	                    if (mode === 'allButReserved' &&
	                        (utils.isEs3Keyword(key.value) || utils.isEs3FutureReservedWord(key.value))
	                    ) {
	                        return;
	                    }
	                    errors.add('Extra quotes for key', prop.loc.start);
	                }
	            });
	        });
	    }

	};


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires quoted keys in objects.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireQuotedKeysInObjects": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	  * var x = { 'a': { "default": 1 } };
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = { a: 1 };
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() { };

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireQuotedKeysInObjects';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('ObjectExpression', function(node) {
	            node.properties.forEach(function(prop) {
	                if (prop.shorthand || prop.method || prop.kind !== 'init') {
	                    return;
	                }

	                var key = prop.key;
	                if (!(typeof key.value === 'string' && key.type === 'Literal')) {
	                    errors.add('Object key without surrounding quotes', prop.loc.start);
	                }
	            });
	        });
	    }
	};


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows identifiers that start or end in `_`. Some popular identifiers are automatically listed as exceptions:
	 *
	 *  - `__proto__` (javascript)
	 *  - `_` (underscore.js)
	 *  - `__filename` (node.js global)
	 *  - `__dirname` (node.js global)
	 *  - `super_` (node.js, used by
	 *    [`util.inherits`](http://nodejs.org/docs/latest/api/util.html#util_util_inherits_constructor_superconstructor))
	 *
	 * Types: `Boolean` or `Object`
	 *
	 * Values:
	 *  - `true`
	 *  - `Object`:
	 *     - `allExcept`: array of quoted identifiers
	 *
	 * JSHint: [`nomen`](http://www.jshint.com/docs/options/#nomen)
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowDanglingUnderscores": { "allExcept": ["_exception"] }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = 1;
	 * var o = obj.__proto__;
	 * var y = _.extend;
	 * var z = __dirname;
	 * var w = __filename;
	 * var x_y = 1;
	 * var v = _exception;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var _x = 1;
	 * var x_ = 1;
	 * var x_y_ = 1;
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(identifiers) {
	        assert(
	            identifiers === true ||
	            typeof identifiers === 'object',
	            this.getOptionName() + ' option requires the value `true` ' +
	            'or an object with String[] `allExcept` property'
	        );

	        // verify first item in `allExcept` property in object (if it's an object)
	        assert(
	            typeof identifiers !== 'object' ||
	            Array.isArray(identifiers.allExcept) &&
	            typeof identifiers.allExcept[0] === 'string',
	            'Property `allExcept` in ' + this.getOptionName() + ' should be an array of strings'
	        );

	        var isTrue = identifiers === true;
	        var defaultIdentifiers = [
	            '__proto__',
	            '_',
	            '__dirname',
	            '__filename',
	            'super_'
	        ];

	        if (isTrue) {
	            identifiers = defaultIdentifiers;
	        } else {
	            identifiers = (identifiers.allExcept).concat(defaultIdentifiers);
	        }

	        this._identifierIndex = {};
	        for (var i = 0, l = identifiers.length; i < l; i++) {
	            this._identifierIndex[identifiers[i]] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'disallowDanglingUnderscores';
	    },

	    check: function(file, errors) {
	        var allowedIdentifiers = this._identifierIndex;

	        file.iterateTokensByType('Identifier', function(token) {
	            var value = token.value;
	            if ((value[0] === '_' || value.slice(-1) === '_') &&
	                !allowedIdentifiers[value]
	            ) {
	                errors.add(
	                    'Invalid dangling underscore found',
	                    token.loc.start.line,
	                    token.loc.start.column
	                );
	            }
	        });
	    }

	};


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires proper alignment in object literals.
	 *
	 * Type: `String`
	 *
	 * Values:
	 *  - `"all"` for strict mode,
	 *  - `"ignoreFunction"` ignores objects if one of the property values is a function expression,
	 *  - `"ignoreLineBreak"` ignores objects if there are line breaks between properties
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireAlignedObjectValues": "all"
	 * ```
	 *
	 * ##### Valid
	 * ```js
	 * var x = {
	 *     a   : 1,
	 *     bcd : 2,
	 *     ef  : 'str'
	 * };
	 * ```
	 * ##### Invalid
	 * ```js
	 * var x = {
	 *     a : 1,
	 *     bcd : 2,
	 *     ef : 'str'
	 * };
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(mode) {
	        var modes = {
	            'all': 'all',
	            'ignoreFunction': 'ignoreFunction',
	            'ignoreLineBreak': 'ignoreLineBreak',
	            'skipWithFunction': 'ignoreFunction',
	            'skipWithLineBreak': 'ignoreLineBreak'
	        };
	        assert(
	            typeof mode === 'string' && modes[mode],
	            this.getOptionName() + ' requires one of the following values: ' + Object.keys(modes).join(', ')
	        );
	        this._mode = modes[mode];
	    },

	    getOptionName: function() {
	        return 'requireAlignedObjectValues';
	    },

	    check: function(file, errors) {
	        var mode = this._mode;

	        file.iterateNodesByType('ObjectExpression', function(node) {
	            if (node.loc.start.line === node.loc.end.line || node.properties < 2) {
	                return;
	            }

	            var maxKeyEndPos = 0;
	            var skip = node.properties.some(function(property, index) {
	                if (property.shorthand || property.method || property.kind !== 'init') {
	                    return true;
	                }

	                maxKeyEndPos = Math.max(maxKeyEndPos, property.key.loc.end.column);

	                if (mode === 'ignoreFunction' && property.value.type === 'FunctionExpression') {
	                    return true;
	                }

	                if (mode === 'ignoreLineBreak' && index > 0 &&
	                     node.properties[index - 1].loc.end.line !== property.loc.start.line - 1) {
	                    return true;
	                }
	            });

	            if (skip) {
	                return;
	            }

	            node.properties.forEach(function(property) {
	                var keyToken = file.getFirstNodeToken(property.key);
	                var colon = file.getNextToken(keyToken);
	                errors.assert.spacesBetween({
	                    token: keyToken,
	                    nextToken: colon,
	                    exactly: maxKeyEndPos - keyToken.loc.end.column + 1,
	                    message: 'Alignment required'
	                });
	            });
	        });
	    }

	};


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Validates proper alignment of function parameters.
	 *
	 * Type: `Object` or `Boolean`
	 *
	 * Values: `"lineBreakAfterOpeningBraces"`, `"lineBreakBeforeClosingBraces"` as child properties or `true`.
	 *
	 * #### Example
	 *
	 * ```js
	 * "validateAlignedFunctionParameters": {
	 *   "lineBreakAfterOpeningBraces": true,
	 *   "lineBreakBeforeClosingBraces": true
	 * }
	 * ```
	 *
	 * ##### Valid
	 * ```js
	 * function (
	 *   thisIs,
	 *   theLongestList,
	 *   ofParametersEverWritten
	 * ) {}
	 * ```
	 * ##### Invalid
	 * ```js
	 * function (thisIs,
	 *           theLongestList,
	 *           ofParametersEverWritten) {}
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        var validProperties = [
	            'lineBreakAfterOpeningBrace',
	            'lineBreakBeforeClosingBrace'
	        ];
	        var optionName = this.getOptionName();

	        assert(
	            typeof options === 'object' || options === true,
	            optionName + ' option must be an object or boolean true'
	        );

	        if (typeof options === 'object') {
	            validProperties.forEach(function(key) {
	                var isPresent = key in options;

	                if (isPresent) {
	                    assert(
	                        options[key] === true,
	                        optionName + '.' + key + ' property requires true value or should be removed'
	                    );
	                }
	            });

	            validProperties.forEach(function(property) {
	                this['_' + property] = Boolean(options[property]);
	            }.bind(this));
	        }
	    },

	    getOptionName: function() {
	        return 'validateAlignedFunctionParameters';
	    },

	    check: function(file, errors) {
	        var lineBreakAfterOpeningBrace = this._lineBreakAfterOpeningBrace;
	        var lineBreakBeforeClosingBrace = this._lineBreakBeforeClosingBrace;

	        file.iterateNodesByType(['FunctionDeclaration', 'FunctionExpression'], function(node) {

	            // ignore this rule if there are no parameters
	            if (!(node.params && node.params.length > 0)) {
	                return;
	            }

	            // ignore this rule if the parameters are not multi-line
	            var firstParameter = file.getFirstNodeToken(node.params[0]);
	            var lastParameter = node.params[node.params.length - 1];
	            if (firstParameter.loc.start.line === lastParameter.loc.end.line) {
	                return;
	            }

	            // look for the furthest parameter start position
	            var maxParamStartPos = 0;
	            node.params.forEach(function(parameter) {
	                maxParamStartPos = Math.max(maxParamStartPos, parameter.loc.start.column);
	            });

	            // make sure all parameters are lined up
	            node.params.forEach(function(parameter) {
	                if (parameter.loc.start.column !== maxParamStartPos) {
	                    errors.add('Multi-line parameters are not aligned.', parameter.loc.start);
	                }
	            });

	            // make sure the first parameter is on a new line
	            if (lineBreakAfterOpeningBrace) {
	                var openingBrace = file.getPrevToken(firstParameter);
	                errors.assert.differentLine({
	                    token: openingBrace,
	                    nextToken: firstParameter,
	                    message: 'There is no line break after the opening brace'
	                });
	            }

	            // make sure the closing brace is on a new line
	            if (lineBreakBeforeClosingBrace) {
	                var bodyToken = file.getFirstNodeToken(node.body);
	                var closingBrace = file.getPrevToken(bodyToken);
	                errors.assert.differentLine({
	                    token: lastParameter,
	                    nextToken: closingBrace,
	                    message: 'There is no line break before the closing brace'
	                });
	            }

	        });
	    }

	};


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallow a newline after blocks
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowPaddingNewLinesAfterBlocks": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	  * function () {
	 *     for (var i = 0; i < 2; i++) {
	 *         if (true) {
	 *             return false;
	 *         }
	 *         continue;
	 *     }
	 *     var obj = {
	 *         foo: function() {
	 *             return 1;
	 *         },
	 *         bar: function() {
	 *             return 2;
	 *         }
	 *     };
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * function () {
	 *     for (var i = 0; i < 2; i++) {
	 *         if (true) {
	 *             return false;
	 *         }
	 *
	 *         continue;
	 *     }
	 *
	 *     var obj = {
	 *         foo: function() {
	 *             return 1;
	 *         },
	 *
	 *         bar: function() {
	 *             return 2;
	 *         }
	 *     };
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        assert(
	            value === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowPaddingNewLinesAfterBlocks';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('BlockStatement', function(node) {
	            var closingBracket = file.getLastNodeToken(node);
	            var nextToken = file.getNextToken(closingBracket);

	            while (nextToken.type !== 'EOF') {
	                if (closingBracket.loc.end.line === nextToken.loc.start.line) {
	                    nextToken = file.getNextToken(nextToken);
	                    continue;
	                }

	                errors.assert.linesBetween({
	                    token: closingBracket,
	                    nextToken: nextToken,
	                    atMost: 1,
	                    message: 'Extra newline after closing curly brace'
	                });

	                return;
	            }
	        });
	    }
	};


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires newline after blocks
	 *
	 * Type: `Boolean` or `Object`
	 *
	 * Values:
	 * - `true`: always require a newline after blocks
	 * - `Object`:
	 *      - `"allExcept"`: `Array`
	 *          - `"inCallExpressions"` Blocks don't need a line of padding in argument lists
	 *          - `"inArrayExpressions"` Blocks don't need a line of padding in arrays
	 *          - `"inProperties"` Blocks don't need a line of padding as object properties
	 *
	 * #### Example
	 *
	 * ```js
	 * "requirePaddingNewLinesAfterBlocks": true
	 * "requirePaddingNewLinesAfterBlocks": {
	 *     "allExcept": ["inCallExpressions", "inArrayExpressions", "inProperties"]
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * function () {
	 *     for (var i = 0; i < 2; i++) {
	 *         if (true) {
	 *             return false;
	 *         }
	 *
	 *         continue;
	 *     }
	 *
	 *     var obj = {
	 *         foo: function() {
	 *             return 1;
	 *         },
	 *
	 *         bar: function() {
	 *             return 2;
	 *         }
	 *     };
	 *
	 *     func(
	 *          function() {
	 *          }
	 *
	 *     );
	 *
	 *     var a = [
	 *         function() {
	 *         }
	 *
	 *     ]
	 *
	 * }
	 * ```
	 *
	 * ##### Valid for `{ "allExcept": ["inCallExpressions"] }`
	 *
	 * ```js
	 * func(
	 *     2,
	 *     3,
	 *     function() {
	 *     }
	 * );
	 * ```
	 *
	 * ##### Valid for `{ "allExcept": ["inArrayExpressions"] }`
	 *
	 * ```js
	 * var foo = [
	 *     2,
	 *     3,
	 *     function() {
	 *     }
	 * ];
	 * ```
	* ##### Valid for `{ "allExcept": ["inProperties"] }`
	 *
	 * ```js
	 * var foo = {
	 *     a: 2,
	 *     b: function() {
	 *     },
	 *     c: 3
	 * ];
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * function () {
	 *     for (var i = 0; i < 2; i++) {
	 *         if (true) {
	 *             return false;
	 *         }
	 *         continue;
	 *     }
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	var excludes = {
	    'IfStatement': ['else'],
	    'DoWhileStatement': ['while'],
	    'TryStatement': ['catch', 'finally'],
	    'CatchClause': ['finally'],
	    'FunctionExpression': ['.'],
	};

	var exceptions = {
	    'CallExpression': false,
	    'ArrayExpression': false,
	    'Property': false
	};

	function isException(parent) {
	    var grandpa = parent.parentNode;

	    // Check if this block is used in call or array expression
	    if (exceptions[grandpa.type]) {
	        if (grandpa.arguments) {
	            return grandpa.arguments.indexOf(parent) > -1;
	        } else {
	            return true;
	        }
	    }

	    return false;
	}

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        var optionName = this.getOptionName();

	        if (typeof value === 'object') {
	            assert(Array.isArray(value.allExcept), optionName + ' option requires "allExcept" ' +
	                'to be an array');
	            assert(value.allExcept.length > 0, optionName + ' option requires "allExcept" ' +
	                'to have at least one item or be set to `true`');

	            value.allExcept.forEach(function(except) {
	                if (except === 'inCallExpressions') {
	                    exceptions.CallExpression = true;
	                } else if (except === 'inArrayExpressions') {
	                    exceptions.ArrayExpression = true;
	                } else if (except === 'inProperties') {
	                    exceptions.Property = true;
	                } else {
	                    assert(false, optionName + ' option requires "allExcept" to only have ' +
	                        '"inCallExpressions" or "inArrayExpressions"');
	                }
	            });
	        } else {
	            assert(value === true,
	                optionName + ' option requires true value or object'
	            );
	        }
	    },

	    getOptionName: function() {
	        return 'requirePaddingNewLinesAfterBlocks';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('BlockStatement', function(node) {

	            var closingBracket = file.getLastNodeToken(node);
	            var parentNode = node.parentNode;

	            if (isException(parentNode)) {
	                return;
	            }

	            var nextToken = file.getNextToken(closingBracket);

	            while (nextToken.type !== 'EOF') {
	                var excludeValues = excludes[parentNode.type];
	                if (excludeValues && excludeValues.indexOf(nextToken.value) !== -1) {
	                    return;
	                }

	                if (closingBracket.loc.end.line === nextToken.loc.start.line) {
	                    nextToken = file.getNextToken(nextToken);
	                    continue;
	                }

	                if (nextToken.type === 'Punctuator' && nextToken.value === '}') {
	                    return;
	                }

	                errors.assert.linesBetween({
	                    token: closingBracket,
	                    nextToken: nextToken,
	                    atLeast: 2,
	                    message: 'Missing newline after block'
	                });

	                return;
	            }
	        });
	    }
	};


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows blocks from beginning or ending with 2 newlines.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true` validates all non-empty blocks.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowPaddingNewlinesInBlocks": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * if (true) {
	 *     doSomething();
	 * }
	 * if (true) {doSomething();}
	 * var abc = function() {};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (true) {
	 *
	 *     doSomething();
	 *
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowPaddingNewlinesInBlocks';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('BlockStatement', function(node) {
	            var openingBracket = file.getFirstNodeToken(node);

	            errors.assert.linesBetween({
	                token: openingBracket,
	                nextToken: file.getNextToken(openingBracket, {includeComments: true}),
	                atMost: 1,
	                message: 'Expected no padding newline after opening curly brace'
	            });

	            var closingBracket = file.getLastNodeToken(node);

	            errors.assert.linesBetween({
	                token: file.getPrevToken(closingBracket, {includeComments: true}),
	                nextToken: closingBracket,
	                atMost: 1,
	                message: 'Expected no padding newline before closing curly brace'
	            });
	        });
	    }

	};


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires blocks to begin and end with 2 newlines
	 *
	 * Types: `Boolean` or `Integer`
	 *
	 * Values: `true` validates all non-empty blocks,
	 * `Integer` specifies a minimum number of statements in the block before validating.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requirePaddingNewlinesInBlocks": true
	 * ```
	 *
	 * ##### Valid for mode `true`
	 *
	 * ```js
	 * if (true) {
	 *
	 *     doSomething();
	 *
	 * }
	 * var abc = function() {};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (true) {doSomething();}
	 * if (true) {
	 *     doSomething();
	 * }
	 * ```
	 *
	 * ##### Valid for mode `1`
	 *
	 * ```js
	 * if (true) {
	 *
	 *     doSomething();
	 *     doSomethingElse();
	 *
	 * }
	 * if (true) {
	 *     doSomething();
	 * }
	 * if (true) { doSomething(); }
	 * var abc = function() {};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (true) { doSomething(); doSomethingElse(); }
	 * if (true) {
	 *     doSomething();
	 *     doSomethingElse();
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true || typeof options === 'number',
	            this.getOptionName() + ' option requires the value true or an Integer'
	        );

	        this._minStatements = options === true ? 0 : options;
	    },

	    getOptionName: function() {
	        return 'requirePaddingNewlinesInBlocks';
	    },

	    check: function(file, errors) {
	        var minStatements = this._minStatements;

	        file.iterateNodesByType('BlockStatement', function(node) {
	            if (node.body.length <= minStatements) {
	                return;
	            }

	            var openingBracket = file.getFirstNodeToken(node);

	            errors.assert.linesBetween({
	                token: openingBracket,
	                nextToken: file.getNextToken(openingBracket, {includeComments: true}),
	                atLeast: 2,
	                message: 'Expected a padding newline after opening curly brace'
	            });

	            var closingBracket = file.getLastNodeToken(node);

	            errors.assert.linesBetween({
	                token: file.getPrevToken(closingBracket, {includeComments: true}),
	                nextToken: closingBracket,
	                atLeast: 2,
	                message: 'Expected a padding newline before closing curly brace'
	            });
	        });
	    }

	};


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires newline inside curly braces of all objects.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requirePaddingNewLinesInObjects": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = {
	 *     a: 1
	 * };
	 * foo({
	 *     a: {
	 *         b: 1
	 *     }
	 * });
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = { a: 1 };
	 * foo({a:{b:1}});
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        assert(
	            value === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requirePaddingNewLinesInObjects';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('ObjectExpression', function(node) {
	            var openingBracket = file.getFirstNodeToken(node);
	            var nextToken = file.getNextToken(openingBracket);

	            if (nextToken.type === 'Punctuator' && nextToken.value === '}') {
	                return;
	            }

	            errors.assert.differentLine({
	                token: openingBracket,
	                nextToken: nextToken,
	                message: 'Missing newline after opening curly brace'
	            });

	            var closingBracket = file.getLastNodeToken(node);

	            errors.assert.differentLine({
	                token: file.getPrevToken(closingBracket),
	                nextToken: closingBracket,
	                message: 'Missing newline before closing curly brace'
	            });
	        });
	    }

	};


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows newline inside curly braces of all objects.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowPaddingNewLinesInObjects": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = { a: 1 };
	 * foo({a: {b: 1}});
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = {
	 *     a: 1
	 * };
	 * foo({
	 *     a: {
	 *         b: 1
	 *     }
	 * });
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        assert(
	            value === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowPaddingNewLinesInObjects';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('ObjectExpression', function(node) {
	            var openingBracket = file.getFirstNodeToken(node);
	            var nextToken = file.getNextToken(openingBracket);

	            if (nextToken.type === 'Punctuator' && nextToken.value === '}') {
	                return;
	            }

	            errors.assert.sameLine({
	                token: openingBracket,
	                nextToken: nextToken,
	                message: 'Illegal newline after opening curly brace'
	            });

	            var closingBracket = file.getLastNodeToken(node);

	            errors.assert.sameLine({
	                token: file.getPrevToken(closingBracket),
	                nextToken: closingBracket,
	                message: 'Illegal newline before closing curly brace'
	            });
	        });
	    }

	};


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires newline before opening curly brace of all block statements.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireNewlineBeforeBlockStatements": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * function good()
	 * {
	 *     var obj =
	 *     {
	 *         val: true
	 *     };
	 *
	 *     return {
	 *         data: obj
	 *     };
	 * }
	 *
	 * if (cond)
	 * {
	 *     foo();
	 * }
	 *
	 * for (var e in elements)
	 * {
	 *     bar(e);
	 * }
	 *
	 * while (cond)
	 * {
	 *     foo();
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * function bad(){
	 *     var obj = {
	 *         val: true
	 *     };
	 *
	 *     return {
	 *         data: obj
	 *     };
	 * }
	 *
	 * if (cond){
	 *     foo();
	 * }
	 *
	 * for (var e in elements){
	 *     bar(e);
	 * }
	 *
	 * while (cond){
	 *     foo();
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireNewlineBeforeBlockStatements';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('BlockStatement', function(node) {
	            var openingBrace = file.getFirstNodeToken(node);
	            var prevToken = file.getPrevToken(openingBrace);

	            errors.assert.differentLine({
	                token: prevToken,
	                nextToken: openingBrace,
	                message: 'Missing newline before curly brace for block statement'
	            });
	        });
	    }
	};


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows newline before opening curly brace of all block statements.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowNewlineBeforeBlockStatements": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * function good(){
	 *     var obj = {
	 *         val: true
	 *     };
	 *
	 *     return {
	 *         data: obj
	 *     };
	 * }
	 *
	 * if (cond){
	 *     foo();
	 * }
	 *
	 * for (var e in elements){
	 *     bar(e);
	 * }
	 *
	 * while (cond){
	 *     foo();
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * function bad()
	 * {
	 *     var obj =
	 *     {
	 *         val: true
	 *     };
	 *
	 *     return {
	 *         data: obj
	 *     };
	 * }
	 *
	 * if (cond)
	 * {
	 *     foo();
	 * }
	 *
	 * for (var e in elements)
	 * {
	 *     bar(e);
	 * }
	 *
	 * while (cond)
	 * {
	 *     foo();
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowNewlineBeforeBlockStatements';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('BlockStatement', function(node) {
	            var openingBrace = file.getFirstNodeToken(node);
	            var prevToken = file.getPrevToken(openingBrace);

	            errors.assert.sameLine({
	                token: prevToken,
	                nextToken: openingBrace,
	                message: 'Newline before curly brace for block statement is disallowed'
	            });
	        });
	    }
	};


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires an empty line above the specified keywords unless the keyword is the first expression in a block.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted types or `true` to require padding new lines before all of the keywords below.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requirePaddingNewlinesBeforeKeywords": [
	 *     "do",
	 *     "for",
	 *     "if",
	 *     "else",
	 *     "switch",
	 *     "case",
	 *     "try",
	 *     "catch",
	 *     "void",
	 *     "while",
	 *     "with",
	 *     "return",
	 *     "typeof",
	 *     "function"
	 * ]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * function(a) {
	 *     if (!a) {
	 *         return false;
	 *     }
	 *
	 *     for (var i = 0; i < b; i++) {
	 *         if (!a[i]) {
	 *             return false;
	 *         }
	 *     }
	 *
	 *     return true;
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * function(a) {
	 *     if (!a) {
	 *         return false;
	 *     }
	 *     for (var i = 0; i < b; i++) {
	 *         if (!a[i]) {
	 *             return false;
	 *         }
	 *     }
	 *     return true;
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);
	var defaultKeywords = __webpack_require__(49).spacedKeywords;

	module.exports = function() { };

	module.exports.prototype = {

	    configure: function(keywords) {
	        assert(Array.isArray(keywords) || keywords === true,
	            this.getOptionName() + ' option requires array or true value');

	        if (keywords === true) {
	            keywords = defaultKeywords;
	        }

	        this._keywords = keywords;
	    },

	    getOptionName: function() {
	        return 'requirePaddingNewlinesBeforeKeywords';
	    },

	    check: function(file, errors) {
	        var excludedTokens = [':', ',', '(', '='];

	        file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
	            var prevToken = file.getPrevToken(token);

	            // Handle special case of 'else if' construct.
	            if (token.value === 'if' && prevToken && prevToken.value === 'else') {
	                return;
	            // Handling for special cases.
	            } else if (prevToken && excludedTokens.indexOf(prevToken.value) > -1) {
	                return;
	            }

	            // Handle all other cases
	            // The { character is there to handle the case of a matching token which happens to be the first
	            //   statement in a block
	            // The ) character is there to handle the case of `if (...) matchingKeyword` in which case
	            //   requiring padding would break the statement
	            if (prevToken && prevToken.value !== '{' && prevToken.value !== ')') {

	                errors.assert.linesBetween({
	                    token: prevToken,
	                    nextToken: token,
	                    atLeast: 2,
	                    message: 'Keyword `' + token.value + '` should have an empty line above it'
	                });
	            }
	        });
	    }
	};


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallow an empty line above the specified keywords.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted types or `true` to disallow padding new lines after all of the keywords below.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowPaddingNewlinesBeforeKeywords": [
	 *     "do",
	 *     "for",
	 *     "if",
	 *     "else",
	 *     "switch",
	 *     "case",
	 *     "try",
	 *     "catch",
	 *     "void",
	 *     "while",
	 *     "with",
	 *     "return",
	 *     "typeof",
	 *     "function"
	 * ]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * function(a) {
	 *     if (!a) {
	 *         return false;
	 *     }
	 *     for (var i = 0; i < b; i++) {
	 *         if (!a[i]) {
	 *             return false;
	 *         }
	 *     }
	 *     return true;
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * function(a) {
	 *     if (!a) {
	 *
	 *         return false;
	 *     }
	 *
	 *     for (var i = 0; i < b; i++) {
	 *         if (!a[i]) {
	 *
	 *             return false;
	 *         }
	 *     }
	 *
	 *     return true;
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);
	var defaultKeywords = __webpack_require__(49).spacedKeywords;

	module.exports = function() { };

	module.exports.prototype = {

	    configure: function(keywords) {
	        assert(Array.isArray(keywords) || keywords === true,
	            this.getOptionName() + ' option requires array or true value');

	        if (keywords === true) {
	            keywords = defaultKeywords;
	        }

	        this._keywords = keywords;
	    },

	    getOptionName: function() {
	        return 'disallowPaddingNewlinesBeforeKeywords';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByTypeAndValue('Keyword', this._keywords, function(token) {
	            errors.assert.linesBetween({
	                token: file.getPrevToken(token),
	                nextToken: token,
	                atMost: 1,
	                message: 'Keyword `' + token.value + '` should not have an empty line above it'
	            });
	        });
	    }
	};


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows newline before line comments
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowPaddingNewLinesBeforeLineComments": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var a = 2;
	 * // comment
	 * return a;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var a = 2;
	 *
	 * //comment
	 * return a;
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        assert(
	            value === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowPaddingNewLinesBeforeLineComments';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByType('Line', function(comment) {
	            if (comment.loc.start.line === 1) {
	                return;
	            }

	            errors.assert.linesBetween({
	                token: file.getPrevToken(comment, {includeComments: true}),
	                nextToken: comment,
	                atMost: 1,
	                message: 'Line comments must not be preceded with a blank line'
	            });
	        });
	    }
	};


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires newline before line comments
	 *
	 * Types: `Boolean` or `Object`
	 *
	 * Values:
	 * - `true`: always require a newline before line comments
	 * - `Object`:
	 *      - `"allExcept"`: `"firstAfterCurly"` Comments may be first line of block without extra padding
	 *
	 * #### Examples
	 * ```js
	 * "requirePaddingNewLinesBeforeLineComments": true
	 * "requirePaddingNewLinesBeforeLineComments": { "allExcept": "firstAfterCurly" }
	 * ```
	 *
	 * ##### Valid for `true`
	 *
	 * ```js
	 * var a = 2;
	 * var b = 3; // comment
	 *
	 * // comment
	 * return a;
	 *
	 * function() {
	 *
	 *   // comment
	 * }
	 * ```
	 *
	 * ##### Valid for `{ "allExcept": "firstAfterCurly" }`
	 *
	 * ```js
	 * var a = 2;
	 *
	 * // comment
	 * return a;
	 *
	 * function() {
	 *   // comment
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var a = 2;
	 * //comment
	 * return a;
	 *
	 * function() {
	 *   // comment
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        this._allowFirstAfterCurly = false;

	        if (typeof value === 'object') {
	            assert(typeof value.allExcept === 'string' && value.allExcept === 'firstAfterCurly',
	                this.getOptionName() + ' option requires the "allExcept" ' +
	                 'property to equal "firstAfterCurly"');
	            this._allowFirstAfterCurly = true;
	        } else {
	            assert(value === true,
	                this.getOptionName() + ' option requires true value or object'
	            );
	        }
	    },

	    getOptionName: function() {
	        return 'requirePaddingNewLinesBeforeLineComments';
	    },

	    check: function(file, errors) {
	        var allowFirstAfterCurly = this._allowFirstAfterCurly;

	        file.iterateTokensByType('Line', function(comment) {
	            if (comment.loc.start.line === 1) {
	                return;
	            }

	            var firstToken = file.getFirstTokenOnLine(comment.loc.start.line);

	            // Should not consider code and comment on the same line (#1194)
	            if (firstToken !== undefined && firstToken.type !== 'EOF') {
	                return;
	            }

	            var prevToken = file.getPrevToken(comment, {includeComments: true});

	            if (prevToken.type === 'Line') {
	                return;
	            }

	            if (allowFirstAfterCurly && prevToken.type === 'Punctuator' && prevToken.value === '{') {
	                return;
	            }

	            errors.assert.linesBetween({
	                token: prevToken,
	                nextToken: comment,
	                atLeast: 2,
	                message: 'Line comments must be preceded with a blank line'
	            });
	        });
	    }
	};


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows an extra comma following the final element of an array or object literal.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * JSHint: [`es3`](http://jshint.com/docs/options/#es3)
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowTrailingComma": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var foo = [1, 2, 3];
	 * var bar = {a: "a", b: "b"}
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var foo = [1, 2, 3, ];
	 * var bar = {a: "a", b: "b", }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowTrailingComma';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType(['ObjectExpression', 'ArrayExpression'], function(node) {
	            var closingToken = file.getLastNodeToken(node);

	            errors.assert.noTokenBefore({
	                token: closingToken,
	                expectedTokenBefore: {type: 'Punctuator', value: ','},
	                message: 'Extra comma following the final element of an array or object literal'
	            });
	        });
	    }

	};


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires an extra comma following the final element of an array or object literal.
	 *
	 * Types: `Boolean` or `Object`
	 *
	 * Values:
	 *
	 * - `true`: validates all arrays and objects
	 * - `Object`:
	 *     - `ignoreSingleValue`: allows single property objects and single element arrays to not require a trailing comma
	 *     - `ignoreSingleLine`: allows objects and arrays on a single line to not require a trailing comma
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireTrailingComma": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var foo = [1, 2, 3,];
	 * var bar = {a: "a", b: "b",}
	 * ```
	 *
	 * ##### Valid with ignoreSingleValue
	 *
	 * ```js
	 * var car = [1];
	 * var dar = {a: "a"};
	 * ```
	 *
	 * ##### Valid with ignoreSingleLine
	 *
	 * ```js
	 * var car = [1, 2, 3];
	 * var dar = {a: "a", b: "b"};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var foo = [1, 2, 3];
	 * var bar = {a: "a", b: "b"}
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {

	        if (typeof options === 'object') {
	            if ('ignoreSingleValue' in options) {
	                assert(
	                    options.ignoreSingleValue === true,
	                    this.getOptionName() + ' option ignoreSingleValue requires true value or should be removed'
	                );
	                this._ignoreSingleValue = true;
	            }
	            if ('ignoreSingleLine' in options) {
	                assert(
	                    options.ignoreSingleLine === true,
	                    this.getOptionName() + ' option ignoreSingleLine requires true value or should be removed'
	                );
	                this._ignoreSingleLine = true;
	            }
	        } else {
	            assert(
	                options === true,
	                this.getOptionName() + ' option requires a true value or should be removed'
	            );
	        }
	    },

	    getOptionName: function() {
	        return 'requireTrailingComma';
	    },

	    check: function(file, errors) {
	        var _this = this;

	        file.iterateNodesByType(['ObjectExpression', 'ArrayExpression'], function(node) {
	            var isObject = node.type === 'ObjectExpression';
	            var entities = isObject ? node.properties : node.elements;

	            if (entities.length === 0) {
	                return;
	            }

	            if (_this._ignoreSingleValue && entities.length === 1) {
	                return;
	            }

	            if (_this._ignoreSingleLine && node.loc.start.line === node.loc.end.line) {
	                return;
	            }

	            var closingToken = file.getLastNodeToken(node);

	            errors.assert.tokenBefore({
	                token: closingToken,
	                expectedTokenBefore: {type: 'Punctuator', value: ','},
	                message: 'Missing comma before closing ' + (isObject ? ' curly brace' : ' bracket')
	            });
	        });
	    }

	};


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Require a $ before variable names that are jquery assignments.
	 *
	 * Types: `Boolean` or `String`
	 *
	 * Values: `true` or `"ignoreProperties"`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireDollarBeforejQueryAssignment": true
	 * ```
	 *
	 * ##### Valid example for mode `true`
	 *
	 * ```js
	 * var $x = $(".foo");
	 * var y = {
	 *   $x: $(".bar")
	 * };
	 * ```
	 *
	 * ##### Invalid example for mode `true`
	 *
	 * ```js
	 * var x = $(".foo");
	 * var y = {
	 *   x: $(".bar")
	 * };
	 * ```
	 *
	 * ##### Valid example for mode `ignoreProperties`
	 *
	 * ```js
	 * var $x = $(".foo");
	 * var y = {
	 *   x: $(".bar")
	 * };
	 * ```
	 *
	 * ##### Invalid example for mode `ignoreProperties`
	 *
	 * ```js
	 * var x = $(".foo");
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    _ignoreProperties : false,

	    configure: function(options) {
	        assert(
	            options === true || options === 'ignoreProperties',
	            this.getOptionName() + ' option requires true or "ignoreProperties" value, or should be removed'
	        );

	        this._ignoreProperties = (options === 'ignoreProperties');
	    },

	    getOptionName: function() {
	        return 'requireDollarBeforejQueryAssignment';
	    },

	    check: function(file, errors) {
	        var ignoreProperties = this._ignoreProperties;

	        file.iterateNodesByType(['VariableDeclarator', 'AssignmentExpression', 'ObjectExpression'], function(token) {
	            var type = token.type;
	            var left;
	            var varName;
	            var right;

	            if (type === 'VariableDeclarator') {
	                left = token.id;
	                varName = left.name;
	                right = token.init;

	            } else if (ignoreProperties) {
	                return;

	            } else if (type === 'AssignmentExpression') {
	                left = token.left;
	                if (left.computed) {
	                    return;
	                }

	                varName = left.name || left.property.name;
	                right = token.right;

	            } else {// type === 'ObjectExpression'
	                var props = token.properties[0];

	                if (!props) {
	                    return;
	                }

	                left = props.key;

	                if (!left.name) {
	                    return;
	                }

	                varName = left.name;
	                right = props.value;
	            }

	            if (varName.indexOf('$') === 0 || varName.indexOf('_$') === 0) {
	                return;
	            }

	            if (!right || right.type !== 'CallExpression') {
	                return;
	            }

	            var nextToken = file.getTokenByRangeStart(right.callee.range[0]);
	            if (nextToken.value !== '$') {
	                return;
	            }

	            nextToken = file.getNextToken(nextToken);
	            if (nextToken.value !== '(') {
	                return;
	            }

	            while (!(nextToken.type === 'Punctuator' && nextToken.value === ')')) {
	                nextToken = file.getNextToken(nextToken);
	            }

	            nextToken = file.getNextToken(nextToken);

	            if (!nextToken || !(nextToken.type === 'Punctuator' && nextToken.value === '.')) {
	                errors.add(
	                    'jQuery identifiers must start with a $',
	                    left.loc.start.line,
	                    left.loc.start.column
	                );
	            }
	        });
	    }
	};


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows commas as last token on a line in lists.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * JSHint: [`laxcomma`](http://www.jshint.com/docs/options/#laxcomma)
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowCommaBeforeLineBreak": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = {
	 *     one: 1
	 *     , two: 2
	 * };
	 * var y = { three: 3, four: 4};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = {
	 *     one: 1,
	 *     two: 2
	 * };
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowCommaBeforeLineBreak';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
	            errors.assert.sameLine({
	                token: token,
	                nextToken: file.getNextToken(token),
	                message: 'Commas should be placed on new line'
	            });
	        });
	    }

	};


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires commas as last token on a line in lists.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * JSHint: [`laxcomma`](http://www.jshint.com/docs/options/#laxcomma)
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireCommaBeforeLineBreak": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = {
	 *     one: 1,
	 *     two: 2
	 * };
	 * var y = { three: 3, four: 4};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = {
	 *     one: 1
	 *     , two: 2
	 * };
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireCommaBeforeLineBreak';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
	            errors.assert.sameLine({
	                token: file.getPrevToken(token),
	                nextToken: token,
	                message: 'Commas should not be placed on new line'
	            });
	        });
	    }

	};


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space before block statements (for loops, control structures).
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpaceBeforeBlockStatements": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * if (cond){
	 *     foo();
	 * } else{
	 *    bar();
	 * }
	 *
	 * for (var e in elements){
	 *     bar(e);
	 * }
	 *
	 * while (cond){
	 *     foo();
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (cond) {
	 *     foo();
	 * } else {
	 *    bar();
	 * }
	 *
	 * for (var e in elements) {
	 *     bar(e);
	 * }
	 *
	 * while (cond) {
	 *     foo();
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowSpaceBeforeBlockStatements';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('BlockStatement', function(node) {
	            var first = file.getFirstNodeToken(node);

	            errors.assert.noWhitespaceBetween({
	                token: file.getPrevToken(first),
	                nextToken: first,
	                disallowNewLine: true,
	                message: 'Extra space before opening curly brace for block expressions'
	            });
	        });
	    }
	};


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space(s) before block statements (for loops, control structures).
	 *
	 * Type: `Boolean` or `Integer`
	 *
	 * Values:
	 *
	 * - `true` require a single space
	 * - `Integer` require *at least* specified number of spaces
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpaceBeforeBlockStatements": 1
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * if (cond) {
	 *     foo();
	 * } else {
	 *     bar();
	 * }
	 *
	 * for (var e in elements) {
	 *     bar(e);
	 * }
	 *
	 * while (cond) {
	 *     foo();
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (cond){
	 *     foo();
	 * } else{
	 *     bar();
	 * }
	 *
	 * for (var e in elements){
	 *     bar(e);
	 * }
	 *
	 * while (cond){
	 *     foo();
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(requireSpaceBeforeBlockStatements) {
	        assert(
	            typeof requireSpaceBeforeBlockStatements === 'boolean' ||
	            typeof requireSpaceBeforeBlockStatements === 'number',
	            this.getOptionName() + ' option requires number or bolean'
	        );
	        assert(
	            requireSpaceBeforeBlockStatements >= 1,
	            this.getOptionName() +
	              ' option requires true value or a number greater than equal to 1 or should be removed'
	        );
	        this._count = +requireSpaceBeforeBlockStatements;
	    },

	    getOptionName: function() {
	        return 'requireSpaceBeforeBlockStatements';
	    },

	    check: function(file, errors) {
	        var count = this._count;
	        file.iterateNodesByType('BlockStatement', function(node) {
	            var first = file.getFirstNodeToken(node);

	            errors.assert.spacesBetween({
	                token: file.getPrevToken(first),
	                nextToken: first,
	                atLeast: count,
	                disallowNewLine: true,
	                message: 'One (or more) spaces required before opening brace for block expressions'
	            });
	        });
	    }

	};


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires sticking unary operators to the left.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted operators or `true` to disallow space before postfix for all unary operators
	 * (i.e. increment/decrement operators)
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpaceBeforePostfixUnaryOperators": ["++", "--"]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * x = y++; y = z--;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * x = y ++; y = z --;
	 * ```
	 */

	var assert = __webpack_require__(23);
	var defaultOperators = __webpack_require__(49).incrementAndDecrementOperators;

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(operators) {
	        var isTrue = operators === true;

	        assert(
	            Array.isArray(operators) || isTrue,
	            this.getOptionName() + ' option requires array or true value'
	        );

	        if (isTrue) {
	            operators = defaultOperators;
	        }

	        this._operatorIndex = {};
	        for (var i = 0, l = operators.length; i < l; i++) {
	            this._operatorIndex[operators[i]] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'disallowSpaceBeforePostfixUnaryOperators';
	    },

	    check: function(file, errors) {
	        var operatorIndex = this._operatorIndex;

	        // 'UpdateExpression' involve only ++ and -- operators
	        file.iterateNodesByType('UpdateExpression', function(node) {
	            // "!node.prefix" means postfix type of (inc|dec)rement
	            if (!node.prefix && operatorIndex[node.operator]) {
	                var operatorToken = file.getLastNodeToken(node);
	                errors.assert.noWhitespaceBetween({
	                    token: file.getPrevToken(operatorToken),
	                    nextToken: operatorToken,
	                    message: 'Operator ' + node.operator + ' should stick to operand'
	                });
	            }
	        });
	    }
	};


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows sticking unary operators to the left.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted operators or `true` to require space before postfix for all unary operators
	 * (i.e. increment/decrement operators).
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpaceBeforePostfixUnaryOperators": ["++", "--"]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * x = y ++; y = z --;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * x = y++; y = z--;
	 * ```
	 */

	var assert = __webpack_require__(23);
	var defaultOperators = __webpack_require__(49).incrementAndDecrementOperators;

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(operators) {
	        var isTrue = operators === true;

	        assert(
	            Array.isArray(operators) || isTrue,
	            this.getOptionName() + ' option requires array or true value'
	        );

	        if (isTrue) {
	            operators = defaultOperators;
	        }

	        this._operatorIndex = {};
	        for (var i = 0, l = operators.length; i < l; i++) {
	            this._operatorIndex[operators[i]] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'requireSpaceBeforePostfixUnaryOperators';
	    },

	    check: function(file, errors) {
	        var operatorIndex = this._operatorIndex;

	        // 'UpdateExpression' involve only ++ and -- operators
	        file.iterateNodesByType('UpdateExpression', function(node) {
	            // "!node.prefix" means postfix type of (inc|dec)rement
	            if (!node.prefix && operatorIndex[node.operator]) {
	                var operatorToken = file.getLastNodeToken(node);

	                errors.assert.whitespaceBetween({
	                    token: file.getPrevToken(operatorToken),
	                    nextToken: operatorToken,
	                    message: 'Operator ' + node.operator + ' should not stick to operand'
	                });
	            }
	        });
	    }
	};


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires sticking unary operators to the right.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted operators or `true` to disallow space after prefix for all unary operators
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpaceAfterPrefixUnaryOperators": ["++", "--", "+", "-", "~", "!"]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * x = !y; y = ++z;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * x = ! y; y = ++ z;
	 * ```
	 */

	var assert = __webpack_require__(23);
	var defaultOperators = __webpack_require__(49).unaryOperators;

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(operators) {
	        var isTrue = operators === true;

	        assert(
	            Array.isArray(operators) || isTrue,
	            this.getOptionName() + ' option requires array or true value'
	        );

	        if (isTrue) {
	            operators = defaultOperators;
	        }

	        this._operatorIndex = {};
	        for (var i = 0, l = operators.length; i < l; i++) {
	            this._operatorIndex[operators[i]] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'disallowSpaceAfterPrefixUnaryOperators';
	    },

	    check: function(file, errors) {
	        var operatorIndex = this._operatorIndex;

	        file.iterateNodesByType(['UnaryExpression', 'UpdateExpression'], function(node) {
	            // Check "node.prefix" for prefix type of (inc|dec)rement
	            if (node.prefix && operatorIndex[node.operator]) {
	                var operatorToken = file.getFirstNodeToken(node);
	                errors.assert.noWhitespaceBetween({
	                    token: operatorToken,
	                    nextToken: file.getNextToken(operatorToken),
	                    message: 'Operator ' + node.operator + ' should stick to operand'
	                });
	            }
	        });
	    }
	};


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows sticking unary operators to the right.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted operators or `true` to require space after prefix for all unary operators
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpaceAfterPrefixUnaryOperators": ["++", "--", "+", "-", "~", "!"]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * x = ! y; y = ++ z;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * x = !y; y = ++z;
	 * ```
	 */

	var assert = __webpack_require__(23);
	var defaultOperators = __webpack_require__(49).unaryOperators;

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(operators) {
	        var isTrue = operators === true;

	        assert(
	            Array.isArray(operators) || isTrue,
	            this.getOptionName() + ' option requires array or true value'
	        );

	        if (isTrue) {
	            operators = defaultOperators;
	        }

	        this._operatorIndex = {};
	        for (var i = 0, l = operators.length; i < l; i++) {
	            this._operatorIndex[operators[i]] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'requireSpaceAfterPrefixUnaryOperators';
	    },

	    check: function(file, errors) {
	        var operatorIndex = this._operatorIndex;

	        file.iterateNodesByType(['UnaryExpression', 'UpdateExpression'], function(node) {
	            // Check "node.prefix" for prefix type of (inc|dec)rement
	            if (node.prefix && operatorIndex[node.operator]) {
	                var argument = node.argument.type;
	                var operatorToken = file.getFirstNodeToken(node);
	                var nextToken = file.getNextToken(operatorToken);

	                // Do not report consecutive operators (#405)
	                if (
	                    argument === 'UnaryExpression' || argument === 'UpdateExpression' &&
	                    nextToken.value !== '('
	                ) {
	                    return;
	                }

	                errors.assert.whitespaceBetween({
	                    token: operatorToken,
	                    nextToken: nextToken,
	                    message: 'Operator ' + node.operator + ' should not stick to operand'
	                });
	            }
	        });
	    }
	};


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires sticking binary operators to the left.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted operators or `true` to disallow space before all possible binary operators
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpaceBeforeBinaryOperators": [
	 *     "=",
	 *     ",",
	 *     "+",
	 *     "-",
	 *     "/",
	 *     "*",
	 *     "==",
	 *     "===",
	 *     "!=",
	 *     "!=="
	 *     // etc
	 * ]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * x+ y;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * x + y;
	 * ```
	 */

	var assert = __webpack_require__(23);
	var allOperators = __webpack_require__(49).binaryOperators;

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(operators) {
	        var isTrue = operators === true;

	        assert(
	            Array.isArray(operators) || isTrue,
	            this.getOptionName() + ' option requires array or true value'
	        );

	        if (isTrue) {
	            operators = allOperators;
	        }

	        this._operatorIndex = {};
	        for (var i = 0, l = operators.length; i < l; i++) {
	            this._operatorIndex[operators[i]] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'disallowSpaceBeforeBinaryOperators';
	    },

	    check: function(file, errors) {
	        var operators = this._operatorIndex;

	        // Comma
	        if (operators[',']) {
	            file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
	                errors.assert.noWhitespaceBetween({
	                    token: file.getPrevToken(token, {includeComments: true}),
	                    nextToken: token,
	                    message: 'Operator , should stick to previous expression'
	                });
	            });
	        }

	        // For everything else
	        file.iterateNodesByType(
	            ['BinaryExpression', 'AssignmentExpression', 'VariableDeclarator', 'LogicalExpression'],
	            function(node) {
	                var operator;
	                var expression;

	                if (node.type === 'VariableDeclarator') {
	                    expression = node.init;
	                    operator = '=';
	                } else {
	                    operator = node.operator;
	                    expression = node.right;
	                }

	                if (expression === null) {
	                    return;
	                }

	                var operatorToken = file.findPrevOperatorToken(
	                    file.getFirstNodeToken(expression),
	                    operator
	                );

	                var prevToken = file.getPrevToken(operatorToken, {includeComments: true});

	                if (operators[operator]) {
	                    errors.assert.noWhitespaceBetween({
	                        token: prevToken,
	                        nextToken: operatorToken,
	                        message: 'Operator ' + node.operator + ' should stick to previous expression'
	                    });
	                }
	            }
	        );
	    }

	};


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows sticking binary operators to the left.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted operators or `true` to require space before all possible binary operators
	 * without comma operator, since it's rarely used with this rule
	 *
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpaceBeforeBinaryOperators": [
	 *     "=",
	 *     ",",
	 *     "+",
	 *     "-",
	 *     "/",
	 *     "*",
	 *     "==",
	 *     "===",
	 *     "!=",
	 *     "!=="
	 *     // etc
	 * ]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * x !== y;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * x!== y;
	 * ```
	 */

	var assert = __webpack_require__(23);
	var allOperators = __webpack_require__(49).binaryOperators.filter(function(operator) {
	    return operator !== ',';
	});

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(operators) {
	        var isTrue = operators === true;

	        assert(
	            Array.isArray(operators) || isTrue,
	            this.getOptionName() + ' option requires array or true value'
	        );

	        if (isTrue) {
	            operators = allOperators;
	        }

	        this._operatorIndex = {};
	        for (var i = 0, l = operators.length; i < l; i++) {
	            this._operatorIndex[operators[i]] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'requireSpaceBeforeBinaryOperators';
	    },

	    check: function(file, errors) {
	        var operators = this._operatorIndex;

	        // Comma
	        if (operators[',']) {
	            file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
	                errors.assert.whitespaceBetween({
	                    token: file.getPrevToken(token),
	                    nextToken: token,
	                    message: 'Operator , should not stick to preceding expression'
	                });
	            });
	        }

	        // For everything else
	        file.iterateNodesByType(
	            ['BinaryExpression', 'AssignmentExpression', 'VariableDeclarator', 'LogicalExpression'],
	            function(node) {
	                var operator;
	                var expression;

	                if (node.type === 'VariableDeclarator') {
	                    expression = node.init;
	                    operator = '=';
	                } else {
	                    operator = node.operator;
	                    expression = node.right;
	                }

	                if (expression === null) {
	                    return;
	                }

	                var operatorToken = file.findPrevOperatorToken(
	                    file.getFirstNodeToken(expression),
	                    operator
	                );

	                var prevToken = file.getPrevToken(operatorToken);

	                if (operators[operator]) {
	                    errors.assert.whitespaceBetween({
	                        token: prevToken,
	                        nextToken: operatorToken,
	                        message: 'Operator ' + node.operator + ' should not stick to preceding expression'
	                    });
	                }
	            }
	        );
	    }

	};


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires sticking binary operators to the right.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted operators or `true` to disallow space after all possible binary operators
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpaceAfterBinaryOperators": [
	 *     "=",
	 *     ",",
	 *     "+",
	 *     "-",
	 *     "/",
	 *     "*",
	 *     "==",
	 *     "===",
	 *     "!=",
	 *     "!=="
	 *     // etc
	 * ]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * x +y;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * x+ y;
	 * ```
	 */

	var assert = __webpack_require__(23);
	var allOperators = __webpack_require__(49).binaryOperators;

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(operators) {
	        var isTrue = operators === true;

	        assert(
	            Array.isArray(operators) || isTrue,
	            this.getOptionName() + ' option requires array or true value'
	        );

	        if (isTrue) {
	            operators = allOperators;
	        }

	        this._operatorIndex = {};
	        for (var i = 0, l = operators.length; i < l; i++) {
	            this._operatorIndex[operators[i]] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'disallowSpaceAfterBinaryOperators';
	    },

	    check: function(file, errors) {
	        var operators = this._operatorIndex;

	        // Comma
	        if (operators[',']) {
	            file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
	                errors.assert.noWhitespaceBetween({
	                    token: token,
	                    nextToken: file.getNextToken(token),
	                    message: 'Operator , should stick to following expression'
	                });
	            });
	        }

	        // For everything else
	        file.iterateNodesByType(
	            ['BinaryExpression', 'AssignmentExpression', 'VariableDeclarator', 'LogicalExpression'],
	            function(node) {
	                var operator;
	                var expression;

	                if (node.type === 'VariableDeclarator') {
	                    expression = node.init;
	                    operator = '=';
	                } else {
	                    operator = node.operator;
	                    expression = node.right;
	                }

	                if (expression === null) {
	                    return;
	                }

	                var operatorToken = file.findPrevOperatorToken(
	                    file.getFirstNodeToken(expression),
	                    operator
	                );

	                var nextToken = file.getNextToken(operatorToken);

	                if (operators[operator]) {
	                    errors.assert.noWhitespaceBetween({
	                        token: operatorToken,
	                        nextToken: nextToken,
	                        message: 'Operator ' + operator + ' should stick to following expression'
	                    });
	                }
	            }
	        );
	    }

	};


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows sticking binary operators to the right.
	 *
	 * Types: `Array` or `Boolean`
	 *
	 * Values: Array of quoted operators or `true` to require space after all possible binary operators
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpaceAfterBinaryOperators": [
	 *     "=",
	 *     ",",
	 *     "+",
	 *     "-",
	 *     "/",
	 *     "*",
	 *     "==",
	 *     "===",
	 *     "!=",
	 *     "!=="
	 *     // etc
	 * ]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * x + y;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * x +y;
	 * ```
	 */

	var assert = __webpack_require__(23);
	var allOperators = __webpack_require__(49).binaryOperators;

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(operators) {
	        var isTrue = operators === true;

	        assert(
	            Array.isArray(operators) || isTrue,
	            this.getOptionName() + ' option requires array or true value'
	        );

	        if (isTrue) {
	            operators = allOperators;
	        }

	        this._operatorIndex = {};
	        for (var i = 0, l = operators.length; i < l; i++) {
	            this._operatorIndex[operators[i]] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'requireSpaceAfterBinaryOperators';
	    },

	    check: function(file, errors) {
	        var operators = this._operatorIndex;

	        // Comma
	        if (operators[',']) {
	            file.iterateTokensByTypeAndValue('Punctuator', ',', function(token) {
	                errors.assert.whitespaceBetween({
	                    token: token,
	                    nextToken: file.getNextToken(token),
	                    message: 'Operator , should not stick to following expression'
	                });
	            });
	        }

	        // For everything else
	        file.iterateNodesByType(
	            ['BinaryExpression', 'AssignmentExpression', 'VariableDeclarator', 'LogicalExpression'],
	            function(node) {
	                var operator;
	                var expression;

	                if (node.type === 'VariableDeclarator') {
	                    expression = node.init;
	                    operator = '=';
	                } else {
	                    operator = node.operator;
	                    expression = node.right;
	                }

	                if (expression === null) {
	                    return;
	                }

	                var operatorToken = file.findPrevOperatorToken(
	                    file.getFirstNodeToken(expression),
	                    operator
	                );

	                var nextToken = file.getNextToken(operatorToken);

	                if (operators[operator]) {
	                    errors.assert.whitespaceBetween({
	                        token: operatorToken,
	                        nextToken: nextToken,
	                        message: 'Operator ' + operator + ' should not stick to following expression'
	                    });
	                }
	            }
	        );
	    }

	};


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space before and/or after `?` or `:` in conditional expressions.
	 *
	 * Types: `Object` or `Boolean`
	 *
	 * Values: `"afterTest"`, `"beforeConsequent"`, `"afterConsequent"`, `"beforeAlternate"` as child properties,
	 * or `true` to set all properties to `true`. Child properties must be set to `true`.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpacesInConditionalExpression": {
	 *     "afterTest": true,
	 *     "beforeConsequent": true,
	 *     "afterConsequent": true,
	 *     "beforeAlternate": true
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var a = b ? c : d;
	 * var a= b ? c : d;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var a = b? c : d;
	 * var a = b ?c : d;
	 * var a = b ? c: d;
	 * var a = b ? c :d;
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        var validProperties = [
	            'afterTest',
	            'beforeConsequent',
	            'afterConsequent',
	            'beforeAlternate'
	        ];
	        var optionName = this.getOptionName();

	        if (options === true) {
	            options = {
	                'afterTest': true,
	                'beforeConsequent': true,
	                'afterConsequent': true,
	                'beforeAlternate': true
	            };
	        }

	        assert(
	            typeof options === 'object',
	            optionName + ' option requires a true value or an object'
	        );

	        var isProperlyConfigured = validProperties.some(function(key) {
	            var isPresent = key in options;

	            if (isPresent) {
	                assert(
	                    options[key] === true,
	                    optionName + '.' + key + ' property requires true value or should be removed'
	                );
	            }

	            return isPresent;
	        });

	        assert(
	            isProperlyConfigured,
	            optionName + ' must have at least 1 of the following properties: ' + validProperties.join(', ')
	        );

	        validProperties.forEach(function(property) {
	            this['_' + property] = Boolean(options[property]);
	        }.bind(this));
	    },

	    getOptionName: function() {
	        return 'requireSpacesInConditionalExpression';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType(['ConditionalExpression'], function(node) {
	            var consequent = node.consequent;
	            var alternate = node.alternate;
	            var consequentToken = file.getFirstNodeToken(consequent);
	            var alternateToken = file.getFirstNodeToken(alternate);
	            var questionMarkToken = file.findPrevOperatorToken(consequentToken, '?');
	            var colonToken = file.findPrevOperatorToken(alternateToken, ':');
	            var token;

	            if (this._afterTest) {
	                token = file.getPrevToken(questionMarkToken);
	                errors.assert.whitespaceBetween({
	                    token: token,
	                    nextToken: questionMarkToken,
	                    message: 'Missing space after test'
	                });
	            }

	            if (this._beforeConsequent) {
	                token = file.getNextToken(questionMarkToken);
	                errors.assert.whitespaceBetween({
	                    token: questionMarkToken,
	                    nextToken: token,
	                    message: 'Missing space before consequent'
	                });
	            }

	            if (this._afterConsequent) {
	                token = file.getPrevToken(colonToken);
	                errors.assert.whitespaceBetween({
	                    token: token,
	                    nextToken: colonToken,
	                    message: 'Missing space after consequent'
	                });
	            }

	            if (this._beforeAlternate) {
	                token = file.getNextToken(colonToken);
	                errors.assert.whitespaceBetween({
	                    token: colonToken,
	                    nextToken: token,
	                    message: 'Missing space before alternate'
	                });
	            }
	        }.bind(this));
	    }

	};


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space before and/or after `?` or `:` in conditional expressions.
	 *
	 * Types: `Object` or `Boolean`
	 *
	 * Values: `"afterTest"`, `"beforeConsequent"`, `"afterConsequent"`, `"beforeAlternate"` as child properties,
	 * or `true` to set all properties to true. Child properties must be set to `true`. These token names correspond to:
	 *
	 * ```
	 * var a = b ? c : d;
	 *          ^ ^ ^ ^
	 *          | | | |
	 *          | | | - beforeAlternate
	 *          | | --- afterConsequent
	 *          | -------- beforeConsequent
	 *          ---------- afterTest
	 * ```
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpacesInConditionalExpression": {
	 *     "afterTest": true,
	 *     "beforeConsequent": true,
	 *     "afterConsequent": true,
	 *     "beforeAlternate": true
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var a = b?c:d;
	 * var a= b?c:d;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var a = b ?c:d;
	 * var a = b? c:d;
	 * var a = b?c :d;
	 * var a = b?c: d;
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        var validProperties = [
	            'afterTest',
	            'beforeConsequent',
	            'afterConsequent',
	            'beforeAlternate'
	        ];
	        var optionName = this.getOptionName();

	        if (options === true) {
	            options = {
	                'afterTest': true,
	                'beforeConsequent': true,
	                'afterConsequent': true,
	                'beforeAlternate': true
	            };
	        }

	        assert(
	            typeof options === 'object',
	            optionName + ' option requires a true value or an object'
	        );

	        var isProperlyConfigured = validProperties.some(function(key) {
	            var isPresent = key in options;

	            if (isPresent) {
	                assert(
	                    options[key] === true,
	                    optionName + '.' + key + ' property requires true value or should be removed'
	                );
	            }

	            return isPresent;
	        });

	        assert(
	            isProperlyConfigured,
	            optionName + ' must have at least 1 of the following properties: ' + validProperties.join(', ')
	        );

	        validProperties.forEach(function(property) {
	            this['_' + property] = Boolean(options[property]);
	        }.bind(this));
	    },

	    getOptionName: function() {
	        return 'disallowSpacesInConditionalExpression';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType(['ConditionalExpression'], function(node) {

	            var test = node.test;
	            var consequent = node.consequent;
	            var consequentToken = file.getFirstNodeToken(consequent);
	            var alternate = node.alternate;
	            var alternateToken = file.getFirstNodeToken(alternate);
	            var questionMarkToken = file.findPrevOperatorToken(consequentToken, '?');
	            var colonToken = file.findPrevOperatorToken(alternateToken, ':');
	            var token;

	            if (this._afterTest && test.loc.end.line === questionMarkToken.loc.start.line) {
	                token = file.getPrevToken(questionMarkToken);

	                errors.assert.noWhitespaceBetween({
	                    token: token,
	                    nextToken: questionMarkToken,
	                    message: 'Illegal space after test'
	                });
	            }

	            if (this._beforeConsequent && consequent.loc.end.line === questionMarkToken.loc.start.line) {
	                token = file.getNextToken(questionMarkToken);

	                errors.assert.noWhitespaceBetween({
	                    token: questionMarkToken,
	                    nextToken: token,
	                    message: 'Illegal space before consequent'
	                });
	            }

	            if (this._afterConsequent && consequent.loc.end.line === colonToken.loc.start.line) {
	                token = file.getPrevToken(colonToken);

	                errors.assert.noWhitespaceBetween({
	                    token: token,
	                    nextToken: colonToken,
	                    message: 'Illegal space after consequent'
	                });
	            }

	            if (this._beforeAlternate && alternate.loc.end.line === colonToken.loc.start.line) {
	                token = file.getNextToken(colonToken);
	                errors.assert.noWhitespaceBetween({
	                    token: colonToken,
	                    nextToken: token,
	                    message: 'Illegal space before alternate'
	                });
	            }
	        }.bind(this));
	    }

	};


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Expression
	 *
	 * Requires space before `()` or `{}` in function expressions (both [named](#requirespacesinnamedfunctionexpression)
	 * and [anonymous](#requirespacesinanonymousfunctionexpression)) and function declarations.
	 *
	 * Type: `Object`
	 *
	 * Values: `"beforeOpeningRoundBrace"` and `"beforeOpeningCurlyBrace"` as child properties.
	 * Child properties must be set to `true`.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpacesInFunction": {
	 *     "beforeOpeningRoundBrace": true,
	 *     "beforeOpeningCurlyBrace": true
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = function () {};
	 * var x = function a () {};
	 * function a () {}
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = function() {};
	 * var x = function (){};
	 * var x = function(){};
	 * var x = function a() {};
	 * var x = function a (){};
	 * var x = function a(){};
	 * function a() {}
	 * function a (){}
	 * function a(){}
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            typeof options === 'object',
	            this.getOptionName() + ' option must be the object'
	        );

	        if ('beforeOpeningRoundBrace' in options) {
	            assert(
	                options.beforeOpeningRoundBrace === true,
	                this.getOptionName() + '.beforeOpeningRoundBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        if ('beforeOpeningCurlyBrace' in options) {
	            assert(
	                options.beforeOpeningCurlyBrace === true,
	                this.getOptionName() + '.beforeOpeningCurlyBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        assert(
	            options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
	            this.getOptionName() + ' must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property'
	        );

	        this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
	        this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
	    },

	    getOptionName: function() {
	        return 'requireSpacesInFunction';
	    },

	    check: function(file, errors) {
	        var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
	        var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

	        file.iterateNodesByType(['FunctionDeclaration', 'FunctionExpression'], function(node) {
	            var parent = node.parentNode;

	            // Ignore syntactic sugar for getters and setters.
	            if (parent.type === 'Property' && (parent.kind === 'get' || parent.kind === 'set')) {
	                return;
	            }

	            if (beforeOpeningRoundBrace) {
	                // for a named function, use node.id
	                var functionToken = file.getFirstNodeToken(node.id || node);
	                errors.assert.whitespaceBetween({
	                    token: functionToken,
	                    nextToken: file.getNextToken(functionToken),
	                    message: 'Missing space before opening round brace',
	                });
	            }

	            if (beforeOpeningCurlyBrace) {
	                var bodyToken = file.getFirstNodeToken(node.body);
	                errors.assert.whitespaceBetween({
	                    token: file.getPrevToken(bodyToken),
	                    nextToken: bodyToken,
	                    message: 'Missing space before opening curly brace',
	                });
	            }
	        });
	    }

	};


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Expression
	 *
	 * Disallows space before `()` or `{}` in function expressions (both [named](#disallowspacesinnamedfunctionexpression)
	 * and [anonymous](#disallowspacesinanonymousfunctionexpression)) and function declarations.
	 *
	 * Type: `Object`
	 *
	 * Values: `"beforeOpeningRoundBrace"` and `"beforeOpeningCurlyBrace"` as child properties.
	 * Child properties must be set to `true`.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpacesInFunction": {
	 *     "beforeOpeningRoundBrace": true,
	 *     "beforeOpeningCurlyBrace": true
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = function(){};
	 * var x = function a(){};
	 * function a(){}
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = function() {};
	 * var x = function (){};
	 * var x = function () {};
	 * var x = function a() {};
	 * var x = function a (){};
	 * var x = function a () {};
	 * function a() {}
	 * function a (){}
	 * function a () {}
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            typeof options === 'object',
	            this.getOptionName() + ' option must be the object'
	        );

	        if ('beforeOpeningRoundBrace' in options) {
	            assert(
	                options.beforeOpeningRoundBrace === true,
	                this.getOptionName() + '.beforeOpeningRoundBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        if ('beforeOpeningCurlyBrace' in options) {
	            assert(
	                options.beforeOpeningCurlyBrace === true,
	                this.getOptionName() + '.beforeOpeningCurlyBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        assert(
	            options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
	            this.getOptionName() + ' must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property'
	        );

	        this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
	        this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
	    },

	    getOptionName: function() {
	        return 'disallowSpacesInFunction';
	    },

	    check: function(file, errors) {
	        var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
	        var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

	        file.iterateNodesByType(['FunctionDeclaration', 'FunctionExpression'], function(node) {
	            var parent = node.parentNode;

	            // Ignore syntactic sugar for getters and setters.
	            if (parent.type === 'Property' && (parent.kind === 'get' || parent.kind === 'set')) {
	                return;
	            }

	            if (beforeOpeningRoundBrace) {
	                // for a named function, use node.id
	                var functionToken = file.getFirstNodeToken(node.id || node);
	                errors.assert.noWhitespaceBetween({
	                    token: functionToken,
	                    nextToken: file.getNextToken(functionToken),
	                    message: 'Illegal space before opening round brace',
	                });
	            }

	            if (beforeOpeningCurlyBrace) {
	                var bodyToken = file.getFirstNodeToken(node.body);
	                errors.assert.noWhitespaceBetween({
	                    token: file.getPrevToken(bodyToken),
	                    nextToken: bodyToken,
	                    message: 'Illegal space before opening curly brace',
	                });
	            }
	        });
	    }

	};


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space before `()` or `{}` in function expressions (both [named](#requirespacesinnamedfunctionexpression)
	 * and [anonymous](#requirespacesinanonymousfunctionexpression)).
	 *
	 * Type: `Object`
	 *
	 * Values: `"beforeOpeningRoundBrace"` and `"beforeOpeningCurlyBrace"` as child properties.
	 * Child properties must be set to `true`.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpacesInFunctionExpression": {
	 *     "beforeOpeningRoundBrace": true,
	 *     "beforeOpeningCurlyBrace": true
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = function () {};
	 * var x = function a () {};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = function() {};
	 * var x = function (){};
	 * var x = function(){};
	 * var x = function a() {};
	 * var x = function a (){};
	 * var x = function a(){};
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            typeof options === 'object',
	            this.getOptionName() + ' option must be the object'
	        );

	        if ('beforeOpeningRoundBrace' in options) {
	            assert(
	                options.beforeOpeningRoundBrace === true,
	                this.getOptionName() + '.beforeOpeningRoundBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        if ('beforeOpeningCurlyBrace' in options) {
	            assert(
	                options.beforeOpeningCurlyBrace === true,
	                this.getOptionName() + '.beforeOpeningCurlyBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        assert(
	            options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
	            this.getOptionName() + ' must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property'
	        );

	        this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
	        this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
	    },

	    getOptionName: function() {
	        return 'requireSpacesInFunctionExpression';
	    },

	    check: function(file, errors) {
	        var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
	        var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

	        file.iterateNodesByType('FunctionExpression', function(node) {
	            var parent = node.parentNode;

	            // Ignore syntactic sugar for getters and setters.
	            if (parent.type === 'Property' && (parent.kind === 'get' || parent.kind === 'set')) {
	                return;
	            }

	            if (beforeOpeningRoundBrace) {
	                // for a named function, use node.id
	                var functionToken = file.getFirstNodeToken(node.id || node);
	                errors.assert.whitespaceBetween({
	                    token: functionToken,
	                    nextToken: file.getNextToken(functionToken),
	                    message: 'Missing space before opening round brace',
	                });
	            }

	            if (beforeOpeningCurlyBrace) {
	                var bodyToken = file.getFirstNodeToken(node.body);
	                errors.assert.whitespaceBetween({
	                    token: file.getPrevToken(bodyToken),
	                    nextToken: bodyToken,
	                    message: 'Missing space before opening curly brace',
	                });
	            }
	        });
	    }

	};


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space before `()` or `{}` in function expressions (both [named](#disallowspacesinnamedfunctionexpression)
	 * and [anonymous](#disallowspacesinanonymousfunctionexpression)).
	 *
	 * Type: `Object`
	 *
	 * Values: `"beforeOpeningRoundBrace"` and `"beforeOpeningCurlyBrace"` as child properties.
	 * Child properties must be set to `true`.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpacesInFunctionExpression": {
	 *     "beforeOpeningRoundBrace": true,
	 *     "beforeOpeningCurlyBrace": true
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = function(){};
	 * var x = function a(){};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = function() {};
	 * var x = function (){};
	 * var x = function () {};
	 * var x = function a() {};
	 * var x = function a (){};
	 * var x = function a () {};
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            typeof options === 'object',
	            this.getOptionName() + ' option must be the object'
	        );

	        if ('beforeOpeningRoundBrace' in options) {
	            assert(
	                options.beforeOpeningRoundBrace === true,
	                this.getOptionName() + '.beforeOpeningRoundBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        if ('beforeOpeningCurlyBrace' in options) {
	            assert(
	                options.beforeOpeningCurlyBrace === true,
	                this.getOptionName() + '.beforeOpeningCurlyBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        assert(
	            options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
	            this.getOptionName() + ' must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property'
	        );

	        this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
	        this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
	    },

	    getOptionName: function() {
	        return 'disallowSpacesInFunctionExpression';
	    },

	    check: function(file, errors) {
	        var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
	        var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

	        file.iterateNodesByType('FunctionExpression', function(node) {
	            var parent = node.parentNode;

	            // Ignore syntactic sugar for getters and setters.
	            if (parent.type === 'Property' && (parent.kind === 'get' || parent.kind === 'set')) {
	                return;
	            }

	            if (beforeOpeningRoundBrace) {
	                // for a named function, use node.id
	                var functionToken = file.getFirstNodeToken(node.id || node);
	                errors.assert.noWhitespaceBetween({
	                    token: functionToken,
	                    nextToken: file.getNextToken(functionToken),
	                    message: 'Illegal space before opening round brace',
	                });
	            }

	            if (beforeOpeningCurlyBrace) {
	                var bodyToken = file.getFirstNodeToken(node.body);
	                errors.assert.noWhitespaceBetween({
	                    token: file.getPrevToken(bodyToken),
	                    nextToken: bodyToken,
	                    message: 'Illegal space before opening curly brace',
	                });
	            }
	        });
	    }

	};


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space before `()` or `{}` in anonymous function expressions.
	 *
	 * Type: `Object`
	 *
	 * Values: `"beforeOpeningRoundBrace"` and `"beforeOpeningCurlyBrace"` as child properties.
	 * Child properties must be set to `true`.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpacesInAnonymousFunctionExpression": {
	 *     "beforeOpeningRoundBrace": true,
	 *     "beforeOpeningCurlyBrace": true
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var foo = function () {};
	 * var Foo = {
	 *     foo: function () {};
	 * }
	 * array.map(function () {});
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var foo = function() {};
	 * var Foo = {
	 *     foo: function (){};
	 * }
	 * array.map(function(){});
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            typeof options === 'object',
	            this.getOptionName() + ' option must be the object'
	        );

	        if ('beforeOpeningRoundBrace' in options) {
	            assert(
	                options.beforeOpeningRoundBrace === true,
	                this.getOptionName() + '.beforeOpeningRoundBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        if ('beforeOpeningCurlyBrace' in options) {
	            assert(
	                options.beforeOpeningCurlyBrace === true,
	                this.getOptionName() + '.beforeOpeningCurlyBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        assert(
	            options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
	            this.getOptionName() + ' must have beforeOpeningCurlyBrace ' +
	            ' or beforeOpeningRoundBrace property'
	        );

	        this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
	        this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
	    },

	    getOptionName: function() {
	        return 'requireSpacesInAnonymousFunctionExpression';
	    },

	    check: function(file, errors) {
	        var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
	        var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

	        file.iterateNodesByType(['FunctionExpression'], function(node) {
	            var parent = node.parentNode;

	            // Ignore syntactic sugar for getters and setters.
	            if (parent.type === 'Property' && (parent.kind === 'get' || parent.kind === 'set')) {
	                return;
	            }

	            if (!node.id) {

	                if (beforeOpeningRoundBrace) {
	                    var functionToken = file.getFirstNodeToken(node);
	                    errors.assert.whitespaceBetween({
	                        token: functionToken,
	                        nextToken: file.getNextToken(functionToken),
	                        message: 'Missing space before opening round brace'
	                    });
	                }

	                if (beforeOpeningCurlyBrace) {
	                    var bodyToken = file.getFirstNodeToken(node.body);
	                    errors.assert.whitespaceBetween({
	                        token: file.getPrevToken(bodyToken),
	                        nextToken: bodyToken,
	                        message: 'Missing space before opening curly brace'
	                    });
	                }
	            }
	        });
	    }

	};


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space before `()` or `{}` in anonymous function expressions.
	 *
	 * Type: `Object`
	 *
	 * Values: `"beforeOpeningRoundBrace"` and `"beforeOpeningCurlyBrace"` as child properties.
	 * Child properties must be set to `true`.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpacesInAnonymousFunctionExpression": {
	 *     "beforeOpeningRoundBrace": true,
	 *     "beforeOpeningCurlyBrace": true
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var foo = function(){};
	 * var Foo = {
	 *     foo: function(){};
	 * }
	 * array.map(function(){});
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var foo = function () {};
	 * var Foo = {
	 *     foo: function (){};
	 * }
	 * array.map(function() {});
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            typeof options === 'object',
	            this.getOptionName() + ' option must be the object'
	        );

	        if ('beforeOpeningRoundBrace' in options) {
	            assert(
	                options.beforeOpeningRoundBrace === true,
	                this.getOptionName() + '.beforeOpeningRoundBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        if ('beforeOpeningCurlyBrace' in options) {
	            assert(
	                options.beforeOpeningCurlyBrace === true,
	                this.getOptionName() + '.beforeOpeningCurlyBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        assert(
	            options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
	            this.getOptionName() + ' must have beforeOpeningCurlyBrace ' +
	            ' or beforeOpeningRoundBrace property'
	        );

	        this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
	        this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
	    },

	    getOptionName: function() {
	        return 'disallowSpacesInAnonymousFunctionExpression';
	    },

	    check: function(file, errors) {
	        var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
	        var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

	        file.iterateNodesByType(['FunctionExpression'], function(node) {
	            var parent = node.parentNode;

	            // Ignore syntactic sugar for getters and setters.
	            if (parent.type === 'Property' && (parent.kind === 'get' || parent.kind === 'set')) {
	                return;
	            }

	            // anonymous function expressions only
	            if (node.id) {
	                return;
	            }

	            if (beforeOpeningRoundBrace) {
	                var functionToken = file.getFirstNodeToken(node);
	                errors.assert.noWhitespaceBetween({
	                    token: functionToken,
	                    nextToken: file.getNextToken(functionToken),
	                    message: 'Illegal space before opening round brace',
	                });
	            }

	            if (beforeOpeningCurlyBrace) {
	                var bodyToken = file.getFirstNodeToken(node.body);
	                errors.assert.noWhitespaceBetween({
	                    token: file.getPrevToken(bodyToken),
	                    nextToken: bodyToken,
	                    message: 'Illegal space before opening curly brace',
	                });
	            }
	        });
	    }

	};


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space before `()` or `{}` in named function expressions.
	 *
	 * Type: `Object`
	 *
	 * Values: `"beforeOpeningRoundBrace"` and `"beforeOpeningCurlyBrace"` as child properties.
	 * Child properties must be set to `true`.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpacesInNamedFunctionExpression": {
	 *     "beforeOpeningRoundBrace": true,
	 *     "beforeOpeningCurlyBrace": true
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = function a () {};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = function a() {};
	 * var x = function a (){};
	 * var x = function a(){};
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            typeof options === 'object',
	            this.getOptionName() + ' option must be the object'
	        );

	        if ('beforeOpeningRoundBrace' in options) {
	            assert(
	                options.beforeOpeningRoundBrace === true,
	                this.getOptionName() + '.beforeOpeningRoundBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        if ('beforeOpeningCurlyBrace' in options) {
	            assert(
	                options.beforeOpeningCurlyBrace === true,
	                this.getOptionName() + '.beforeOpeningCurlyBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        assert(
	            options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
	            this.getOptionName() + ' must have beforeOpeningCurlyBrace ' +
	            'or beforeOpeningRoundBrace property'
	        );

	        this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
	        this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
	    },

	    getOptionName: function() {
	        return 'requireSpacesInNamedFunctionExpression';
	    },

	    check: function(file, errors) {
	        var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
	        var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

	        file.iterateNodesByType(['FunctionExpression'], function(node) {

	            if (node.id) {

	                if (beforeOpeningRoundBrace) {
	                    var functionToken = file.getFirstNodeToken(node.id);
	                    errors.assert.whitespaceBetween({
	                        token: functionToken,
	                        nextToken: file.getNextToken(functionToken),
	                        message: 'Missing space before opening round brace',
	                    });
	                }

	                if (beforeOpeningCurlyBrace) {
	                    var bodyToken = file.getFirstNodeToken(node.body);
	                    errors.assert.whitespaceBetween({
	                        token: file.getPrevToken(bodyToken),
	                        nextToken: bodyToken,
	                        message: 'Missing space before opening curly brace',
	                    });
	                }
	            }
	        });
	    }

	};


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space before `()` or `{}` in named function expressions.
	 *
	 * Type: `Object`
	 *
	 * Values: `"beforeOpeningRoundBrace"` and `"beforeOpeningCurlyBrace"` as child properties.
	 * Child properties must be set to `true`.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpacesInNamedFunctionExpression": {
	 *     "beforeOpeningRoundBrace": true,
	 *     "beforeOpeningCurlyBrace": true
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = function a(){};
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = function a() {};
	 * var x = function a (){};
	 * var x = function a () {};
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            typeof options === 'object',
	            this.getOptionName() + ' option must be the object'
	        );

	        if ('beforeOpeningRoundBrace' in options) {
	            assert(
	                options.beforeOpeningRoundBrace === true,
	                this.getOptionName() + '.beforeOpeningRoundBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        if ('beforeOpeningCurlyBrace' in options) {
	            assert(
	                options.beforeOpeningCurlyBrace === true,
	                this.getOptionName() + '.beforeOpeningCurlyBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        assert(
	            options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
	            this.getOptionName() + ' must have beforeOpeningCurlyBrace ' +
	            'or beforeOpeningRoundBrace property'
	        );

	        this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
	        this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
	    },

	    getOptionName: function() {
	        return 'disallowSpacesInNamedFunctionExpression';
	    },

	    check: function(file, errors) {
	        var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
	        var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

	        file.iterateNodesByType(['FunctionExpression'], function(node) {

	            // named function expressions only
	            if (node.id) {

	                if (beforeOpeningRoundBrace) {
	                    var functionToken = file.getFirstNodeToken(node.id);
	                    errors.assert.noWhitespaceBetween({
	                        token: functionToken,
	                        nextToken: file.getNextToken(functionToken),
	                        message: 'Illegal space before opening round brace',
	                    });
	                }

	                if (beforeOpeningCurlyBrace) {
	                    var bodyToken = file.getFirstNodeToken(node.body);
	                    errors.assert.noWhitespaceBetween({
	                        token: file.getPrevToken(bodyToken),
	                        nextToken: bodyToken,
	                        message: 'Illegal space before opening curly brace',
	                    });
	                }
	            }
	        });
	    }

	};


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space before `()` or `{}` in function declarations.
	 *
	 * Type: `Object`
	 *
	 * Values: `"beforeOpeningRoundBrace"` and `"beforeOpeningCurlyBrace"` as child properties.
	 * Child properties must be set to `true`.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpacesInFunctionDeclaration": {
	 *     "beforeOpeningRoundBrace": true,
	 *     "beforeOpeningCurlyBrace": true
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * function a () {}
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * function a() {}
	 * function a (){}
	 * function a(){}
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            typeof options === 'object',
	            this.getOptionName() + ' option must be the object'
	        );

	        if ('beforeOpeningRoundBrace' in options) {
	            assert(
	                options.beforeOpeningRoundBrace === true,
	                this.getOptionName() + '.beforeOpeningRoundBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        if ('beforeOpeningCurlyBrace' in options) {
	            assert(
	                options.beforeOpeningCurlyBrace === true,
	                this.getOptionName() + '.beforeOpeningCurlyBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        assert(
	            options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
	            this.getOptionName() + ' must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property'
	        );

	        this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
	        this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
	    },

	    getOptionName: function() {
	        return 'requireSpacesInFunctionDeclaration';
	    },

	    check: function(file, errors) {
	        var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
	        var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

	        file.iterateNodesByType(['FunctionDeclaration'], function(node) {

	            if (beforeOpeningRoundBrace) {
	                // for a named function, use node.id
	                var functionToken = file.getFirstNodeToken(node.id || node);
	                errors.assert.whitespaceBetween({
	                    token: functionToken,
	                    nextToken: file.getNextToken(functionToken),
	                    message: 'Missing space before opening round brace',
	                });
	            }

	            if (beforeOpeningCurlyBrace) {
	                var bodyToken = file.getFirstNodeToken(node.body);
	                errors.assert.whitespaceBetween({
	                    token: file.getPrevToken(bodyToken),
	                    nextToken: bodyToken,
	                    message: 'Missing space before opening curly brace',
	                });
	            }
	        });
	    }

	};


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space before `()` or `{}` in function declarations.
	 *
	 * Type: `Object`
	 *
	 * Values: `"beforeOpeningRoundBrace"` and `"beforeOpeningCurlyBrace"` as child properties.
	 * Child properties must be set to `true`.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpacesInFunctionDeclaration": {
	 *     "beforeOpeningRoundBrace": true,
	 *     "beforeOpeningCurlyBrace": true
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * function a(){}
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * function a() {}
	 * function a (){}
	 * function a () {}
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            typeof options === 'object',
	            this.getOptionName() + ' option must be the object'
	        );

	        if ('beforeOpeningRoundBrace' in options) {
	            assert(
	                options.beforeOpeningRoundBrace === true,
	                this.getOptionName() + '.beforeOpeningRoundBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        if ('beforeOpeningCurlyBrace' in options) {
	            assert(
	                options.beforeOpeningCurlyBrace === true,
	                this.getOptionName() + '.beforeOpeningCurlyBrace ' +
	                'property requires true value or should be removed'
	            );
	        }

	        assert(
	            options.beforeOpeningCurlyBrace || options.beforeOpeningRoundBrace,
	            this.getOptionName() + ' must have beforeOpeningCurlyBrace or beforeOpeningRoundBrace property'
	        );

	        this._beforeOpeningRoundBrace = Boolean(options.beforeOpeningRoundBrace);
	        this._beforeOpeningCurlyBrace = Boolean(options.beforeOpeningCurlyBrace);
	    },

	    getOptionName: function() {
	        return 'disallowSpacesInFunctionDeclaration';
	    },

	    check: function(file, errors) {
	        var beforeOpeningRoundBrace = this._beforeOpeningRoundBrace;
	        var beforeOpeningCurlyBrace = this._beforeOpeningCurlyBrace;

	        file.iterateNodesByType(['FunctionDeclaration'], function(node) {

	            if (beforeOpeningRoundBrace) {
	                var functionToken = file.getFirstNodeToken(node.id);
	                errors.assert.noWhitespaceBetween({
	                    token: functionToken,
	                    nextToken: file.getNextToken(functionToken),
	                    message: 'Illegal space before opening round brace',
	                });
	            }

	            if (beforeOpeningCurlyBrace) {
	                var bodyToken = file.getFirstNodeToken(node.body);
	                errors.assert.noWhitespaceBetween({
	                    token: file.getPrevToken(bodyToken),
	                    nextToken: bodyToken,
	                    message: 'Illegal space before opening curly brace',
	                });
	            }
	        });
	    }

	};


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires space before `()` in call expressions.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpacesInCallExpression": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = foobar ();
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = foobar();
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireSpacesInCallExpression';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('CallExpression', function(node) {
	            var lastCalleeToken = file.getLastNodeToken(node.callee);
	            var roundBraceToken = file.findNextToken(lastCalleeToken, 'Punctuator', '(');

	            errors.assert.whitespaceBetween({
	                token: file.getPrevToken(roundBraceToken),
	                nextToken: roundBraceToken,
	                message: 'Missing space before opening round brace'
	            });
	        });
	    }
	};


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows space before `()` in call expressions.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpacesInCallExpression": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = foobar();
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = foobar ();
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowSpacesInCallExpression';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('CallExpression', function(node) {
	            var lastCalleeToken = file.getLastNodeToken(node.callee);
	            var roundBraceToken = file.findNextToken(lastCalleeToken, 'Punctuator', '(');

	            errors.assert.noWhitespaceBetween({
	                token: file.getPrevToken(roundBraceToken),
	                nextToken: roundBraceToken,
	                message: 'Illegal space before opening round brace'
	            });
	        });
	    }
	};


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Enable validation of separators between function parameters. Will ignore newlines.
	 *
	 * Type: `String`
	 *
	 * Values:
	 *
	 *  - `","`: function parameters are immediately followed by a comma
	 *  - `", "`: function parameters are immediately followed by a comma and then a space
	 *  - `" ,"`: function parameters are immediately followed by a space and then a comma
	 *  - `" , "`: function parameters are immediately followed by a space, a comma, and then a space
	 *
	 * #### Example
	 *
	 * ```js
	 * "validateParameterSeparator": ", "
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * function a(b, c) {}
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * function a(b , c) {}
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            typeof options === 'string' && /^[ ]?,[ ]?$/.test(options),
	            this.getOptionName() + ' option requires string value containing only a comma and optional spaces'
	        );

	        this._separator = options;
	    },

	    getOptionName: function() {
	        return 'validateParameterSeparator';
	    },

	    check: function(file, errors) {

	        var separators = this._separator.split(',');
	        var whitespaceBeforeComma = Boolean(separators.shift());
	        var whitespaceAfterComma = Boolean(separators.pop());

	        file.iterateNodesByType(['FunctionDeclaration', 'FunctionExpression'], function(node) {

	            node.params.forEach(function(paramNode) {

	                var prevParamToken = file.getFirstNodeToken(paramNode);
	                var punctuatorToken = file.getNextToken(prevParamToken);

	                if (punctuatorToken.value === ',') {

	                    if (whitespaceBeforeComma) {
	                        errors.assert.spacesBetween({
	                            token: prevParamToken,
	                            nextToken: punctuatorToken,
	                            exactly: 1,
	                            message: 'One space required after function parameter \'' + prevParamToken.value + '\''
	                        });
	                    } else {
	                        errors.assert.noWhitespaceBetween({
	                            token: prevParamToken,
	                            nextToken: punctuatorToken,
	                            message: 'Unexpected space after function parameter \'' + prevParamToken.value + '\''
	                        });
	                    }

	                    var nextParamToken = file.getNextToken(punctuatorToken);

	                    if (whitespaceAfterComma) {
	                        errors.assert.spacesBetween({
	                            token: punctuatorToken,
	                            nextToken: nextParamToken,
	                            exactly: 1,
	                            message: 'One space required before function parameter \'' + nextParamToken.value + '\''
	                        });
	                    } else {
	                        errors.assert.noWhitespaceBetween({
	                            token: punctuatorToken,
	                            nextToken: nextParamToken,
	                            message: 'Unexpected space before function parameter \'' + nextParamToken.value + '\''
	                        });
	                    }
	                }
	            });
	        });
	    }

	};


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Ensure there are spaces after argument separators in call expressions.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpaceBetweenArguments": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * a(b, c);
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * a(b,c);
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireSpaceBetweenArguments';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType(['CallExpression'], function(node) {
	            node.arguments.forEach(function(param) {
	                var punctuatorToken = file.getPrevToken(file.getFirstNodeToken(param));
	                if (punctuatorToken.value === ',') {
	                    errors.assert.whitespaceBetween({
	                        token: punctuatorToken,
	                        nextToken: file.getNextToken(punctuatorToken)
	                    });
	                }
	            });
	        });
	    }
	};


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Ensure there are no spaces after argument separators in call expressions.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpaceBetweenArguments": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * a(b,c);
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * a(b, c);
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowSpaceBetweenArguments';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType(['CallExpression'], function(node) {
	            node.arguments.forEach(function(param) {
	                var token = file.getFirstNodeToken(param);
	                var punctuatorToken = file.getPrevToken(token);

	                if (punctuatorToken.value === ',') {
	                    errors.assert.noWhitespaceBetween({
	                        token: punctuatorToken,
	                        nextToken: file.getNextToken(punctuatorToken),
	                        message: 'Illegal space between arguments'
	                    });
	                }
	            });
	        });
	    }
	};


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires constructors to be capitalized (except for `this`)
	 *
	 * Types: `Boolean` or `Object`
	 *
	 * Values: `true` or Object with `allExcept` Array of quoted identifiers which are exempted
	 *
	 * JSHint: [`newcap`](http://jshint.com/docs/options/#newcap)
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireCapitalizedConstructors": true
	 * "requireCapitalizedConstructors": {
	 *     allExcept: ["somethingNative"]
	 * }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var a = new B();
	 * var c = new this();
	 * var d = new somethingNative();
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var d = new e();
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true || Array.isArray(options.allExcept),
	            this.getOptionName() + ' option requires a true value or an object of exceptions'
	        );
	        this._allowedConstructors = {};

	        var allExcept = options.allExcept;
	        if (allExcept) {
	            for (var i = 0, l = allExcept.length; i < l; i++) {
	                this._allowedConstructors[allExcept[i]] = true;
	            }
	        }
	    },

	    getOptionName: function() {
	        return 'requireCapitalizedConstructors';
	    },

	    check: function(file, errors) {
	        var allowedConstructors = this._allowedConstructors;

	        file.iterateNodesByType('NewExpression', function(node) {
	            if (node.callee.type === 'Identifier' &&
	                !allowedConstructors[node.callee.name] &&
	                node.callee.name[0].toUpperCase() !== node.callee.name[0]
	            ) {
	                errors.add(
	                    'Constructor functions should be capitalized',
	                    node.callee.loc.start.line,
	                    node.callee.loc.start.column
	                );
	            }
	        });
	    }

	};


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Option to check `var that = this` expressions
	 *
	 * Types: `Array` or `String`
	 *
	 * Values: String value used for context local declaration
	 *
	 * #### Example
	 *
	 * ```js
	 * "safeContextKeyword": ["that"]
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var that = this;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var _this = this;
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(keywords) {
	        assert(
	            Array.isArray(keywords) || typeof keywords === 'string',
	            this.getOptionName() + ' option requires string or array value'
	        );

	        this._keywords = keywords;
	    },

	    getOptionName: function() {
	        return 'safeContextKeyword';
	    },

	    check: function(file, errors) {
	        var keywords = typeof this._keywords === 'string' ? [this._keywords] : this._keywords;

	        // var that = this
	        file.iterateNodesByType('VariableDeclaration', function(node) {
	            for (var i = 0; i < node.declarations.length; i++) {
	                var decl = node.declarations[i];

	                // decl.init === null in case of "var foo;"
	                if (decl.init &&
	                    (decl.init.type === 'ThisExpression' && checkKeywords(decl.id.name, keywords))
	                ) {
	                    errors.add(
	                        'You should use "' + keywords.join('" or "') + '" to save a reference to "this"',
	                        node.loc.start
	                    );
	                }
	            }
	        });

	        // that = this
	        file.iterateNodesByType('AssignmentExpression', function(node) {

	            if (
	                // filter property assignments "foo.bar = this"
	                node.left.type === 'Identifier' &&
	                (node.right.type === 'ThisExpression' && checkKeywords(node.left.name, keywords))
	            ) {
	                errors.add(
	                    'You should use "' + keywords.join('" or "') + '" to save a reference to "this"',
	                    node.loc.start
	                );
	            }
	        });
	    }
	};

	/**
	 * Check if at least one keyword equals to passed name
	 * @param {String} name
	 * @param {Array} keywords
	 * @return {Boolean}
	 */
	function checkKeywords(name, keywords) {
	    for (var i = 0; i < keywords.length; i++) {
	        if (name === keywords[i]) {
	            return false;
	        }
	    }

	    return true;
	}


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires member expressions to use dot notation when possible
	 *
	 * Types: `Boolean` or `String`
	 *
	 * Values:
	 *  - `true`
	 *  - `"except_snake_case"` allow quoted snake cased identifiers
	 *
	 * JSHint: [`sub`](http://www.jshint.com/docs/options/#sub)
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireDotNotation": true
	 * ```
	 *
	 * ##### Valid for `true`
	 *
	 * ```js
	 * var a = b[c];
	 * var a = b.c;
	 * var a = b[c.d];
	 * var a = b[1];
	 * var a = b['while']; //reserved word
	 * ```
	 *
	 * ##### Valid for `"except_snake_case"`
	 * ```
	 * var a = b[c];
	 * var a = b.c;
	 * var a = b['snake_cased'];
	 * var a = b['camelCased_butWithSnakes'];
	 * ```
	 *
	 * ##### Invalid for `true`
	 *
	 * ```js
	 * var a = b['c'];
	 * var a = b['snake_cased'];
	 * var a = b['_camelCased'];
	 * var a = b['camelCased_'];
	 * ```
	 *
	 * ##### Invalid for `"except_snake_case"`
	 *
	 * ```js
	 * var a = b['c'];
	 * ```
	 *
	 * #### Example for `"es3": false` or `"es3": null`
	 *
	 * ```js
	 * "requireDotNotation": true,
	 * "es3": false
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var a = b[c];
	 * var a = b.c;
	 * var a = b[c.d];
	 * var a = b[1];
	 * var a = b.while;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var a = b['c'];
	 * var a = b['while']; // reserved words can be property names in ES5
	 * ```
	 */

	var assert = __webpack_require__(23);
	var utils = __webpack_require__(49);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true || options === 'except_snake_case',
	            this.getOptionName() + ' option requires a true value or "except_snake_case"'
	        );
	        this._exceptSnakeCase = options === 'except_snake_case';
	    },

	    getOptionName: function() {
	        return 'requireDotNotation';
	    },

	    check: function(file, errors) {
	        var exceptSnakeCase = this._exceptSnakeCase;

	        function isES3Allowed(value) {
	            return file.getDialect() === 'es3' && (utils.isEs3Keyword(value) || utils.isEs3FutureReservedWord(value));
	        }

	        file.iterateNodesByType('MemberExpression', function(node) {
	            if (!node.computed || node.property.type !== 'Literal') {
	                return;
	            }

	            var value = node.property.value;
	            if (typeof value === 'number' || (typeof value === 'string' && (
	                !utils.isValidIdentifierName(value) ||
	                exceptSnakeCase && utils.isSnakeCased(utils.trimUnderscores(value))
	            ))) {
	                return;
	            }

	            if (value === null ||
	                typeof value === 'boolean' ||
	                value === 'null' ||
	                value === 'true' ||
	                value === 'false' ||
	                isES3Allowed(value)
	            ) {
	                return;
	            }

	            errors.add(
	                'Use dot notation instead of brackets for member expressions',
	                node.property.loc.start
	            );
	        });
	    }

	};


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires that a line comment (`//`) be followed by a space.
	 *
	 * Types: `Boolean`, `Object` or `String`
	 *
	 * Values:
	 *  - `true`
	 *  - `"allowSlash"` (*deprecated* use `"allExcept": ["/"]`) allows `/// ` format
	 *  - `Object`:
	 *     - `allExcept`: array of allowed strings before space `//(here) `
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpaceAfterLineComment": { "allExcept": ["#", "="] }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * // A comment
	 * /*A comment*\/
	 * //# sourceURL=filename.js
	 * //= require something
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * //A comment
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true ||
	            options === 'allowSlash' ||
	            typeof options === 'object',
	            this.getOptionName() + ' option requires a true value ' +
	            'or an object with String[] `allExcept` property'
	        );

	        // verify first item in `allExcept` property in object (if it's an object)
	        assert(
	            typeof options !== 'object' ||
	            Array.isArray(options.allExcept) &&
	            typeof options.allExcept[0] === 'string',
	            'Property `allExcept` in ' + this.getOptionName() + ' should be an array of strings'
	        );

	        // don't check triple slashed comments, microsoft js doc convention. see #593
	        // exceptions. see #592
	        // need to drop allowSlash support in 2.0. Fixes #697
	        this._allExcept = options === 'allowSlash' ? ['/'] :
	            options.allExcept || [];
	    },

	    getOptionName: function() {
	        return 'requireSpaceAfterLineComment';
	    },

	    check: function(file, errors) {
	        var allExcept = this._allExcept;

	        file.iterateTokensByType('Line', function(comment) {
	            var value = comment.value;

	            // cutout exceptions
	            allExcept.forEach(function(el) {
	                if (value.indexOf(el) === 0) {
	                    value = value.substr(el.length);
	                }
	            });

	            if (value.length === 0) {
	                return;
	            }

	            if (value[0] !== ' ') {
	                errors.add('Missing space after line comment', comment.loc.start);
	            }
	        });
	    }
	};


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires that a line comment (`//`) not be followed by a space.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpaceAfterLineComment": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * //A comment
	 * /* A comment*\/
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * // A comment
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowSpaceAfterLineComment';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByType('Line', function(comment) {
	            var value = comment.value;
	            if (value.length > 0 && value[0] === ' ') {
	                errors.add('Illegal space after line comment', comment.loc.start);
	            }
	        });
	    }
	};


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires that a function expression be anonymous.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireAnonymousFunctions": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var a = function(){
	 *
	 * };
	 *
	 * $('#foo').click(function(){
	 *
	 * })
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var a = function foo(){
	 *
	 * };
	 *
	 * $('#foo').click(function bar(){
	 *
	 * });
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireAnonymousFunctions';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType(['FunctionExpression', 'FunctionDeclaration'], function(node) {
	            if (node.id !== null) {
	                errors.add('Functions must not be named', node.loc.start);
	            }
	        });
	    }
	};


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires that a function expression be named.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowAnonymousFunctions": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var a = function foo(){
	 *
	 * };
	 *
	 * $('#foo').click(function bar(){
	 *
	 * });
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var a = function(){
	 *
	 * };
	 *
	 * $('#foo').click(function(){
	 *
	 * });
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowAnonymousFunctions';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType(['FunctionExpression', 'FunctionDeclaration'], function(node) {
	            if (node.id === null) {
	                errors.add('Anonymous functions need to be named', node.loc.start);
	            }
	        });
	    }
	};


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Require unassigned functions to be named inline
	 *
	 * Types: `Boolean` or `Object`
	 *
	 * Values:
	 *  - `true`
	 *  - `Object`:
	 *     - `allExcept`: array of quoted identifiers
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireNamedUnassignedFunctions": { "allExcept": ["describe", "it"] }
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * [].forEach(function x() {});
	 * var y = function() {};
	 * function z() {}
	 * it(function () {});
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * [].forEach(function () {});
	 * before(function () {});
	 * ```
	 */

	var assert = __webpack_require__(23);
	var pathval = __webpack_require__(155);

	function getNodeName(node) {
	    if (node.type === 'Identifier') {
	        return node.name;
	    } else {
	        return node.value;
	    }
	}

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true ||
	            typeof options === 'object',
	            this.getOptionName() + ' option requires true value ' +
	            'or an object with String[] `allExcept` property'
	        );

	        // verify first item in `allExcept` property in object (if it's an object)
	        assert(
	            typeof options !== 'object' ||
	            Array.isArray(options.allExcept) &&
	            typeof options.allExcept[0] === 'string',
	            'Property `allExcept` in ' + this.getOptionName() + ' should be an array of strings'
	        );

	        if (options.allExcept) {
	            this._allExceptItems = options.allExcept.map(function(item) {
	                var parts = pathval.parse(item).map(function extractPart (part) {
	                    return part.i !== undefined ? part.i : part.p;
	                });
	                return JSON.stringify(parts);
	            });
	        }
	    },

	    getOptionName: function() {
	        return 'requireNamedUnassignedFunctions';
	    },

	    check: function(file, errors) {
	        var _this = this;
	        file.iterateNodesByType('FunctionExpression', function(node) {
	            var parentNode = node.parentNode;
	            // If the function has been named via left hand assignment, skip it
	            //   e.g. `var hello = function() {`, `foo.bar = function() {`
	            if (parentNode.type.match(/VariableDeclarator|Property|AssignmentExpression/)) {
	                return;
	            }

	            // If the function has been named, skip it
	            //   e.g. `[].forEach(function hello() {`
	            if (node.id !== null) {
	                return;
	            }

	            // If we have exceptions and the function is being invoked, detect whether we excepted it
	            if (_this._allExceptItems && parentNode.type === 'CallExpression') {
	                // Determine the path that resolves to our call expression
	                // We must cover both direct calls (e.g. `it(function() {`) and
	                //   member expressions (e.g. `foo.bar(function() {`)
	                var memberNode = parentNode.callee;
	                var canBeRepresented = true;
	                var fullpathParts = [];
	                while (memberNode) {
	                    if (memberNode.type.match(/Identifier|Literal/)) {
	                        fullpathParts.unshift(getNodeName(memberNode));
	                    } else if (memberNode.type === 'MemberExpression') {
	                        fullpathParts.unshift(getNodeName(memberNode.property));
	                    } else {
	                        canBeRepresented = false;
	                        break;
	                    }
	                    memberNode = memberNode.object;
	                }

	                // If the path is not-dynamic (i.e. can be represented by static parts),
	                //   then check it against our exceptions
	                if (canBeRepresented) {
	                    var fullpath = JSON.stringify(fullpathParts);
	                    for (var i = 0, l = _this._allExceptItems.length; i < l; i++) {
	                        if (fullpath === _this._allExceptItems[i]) {
	                            return;
	                        }
	                    }
	                }
	            }

	            // Complain that this function must be named
	            errors.add('Inline functions need to be named', node.loc.start);
	        });
	    }
	};


/***/ },
/* 155 */
/***/ function(module, exports) {

	/**
	 * ### .get(obj, path)
	 *
	 * Retrieve the value in an object given a string path.
	 *
	 * ```js
	 * var obj = {
	 *     prop1: {
	 *         arr: ['a', 'b', 'c']
	 *       , str: 'Hello'
	 *     }
	 *   , prop2: {
	 *         arr: [ { nested: 'Universe' } ]
	 *       , str: 'Hello again!'
	 *     }
	 * };
	 * ```
	 *
	 * The following would be the results.
	 *
	 * ```js
	 * var properties = require('tea-properties');
	 * properties.get(obj, 'prop1.str'); // Hello
	 * properties.get(obj, 'prop1.att[2]'); // b
	 * properties.get(obj, 'prop2.arr[0].nested'); // Universe
	 * ```
	 *
	 * @param {Object} object
	 * @param {String} path
	 * @return {Object} value or `undefined`
	 */

	exports.get = function(obj, path) {
	  var parsed = exports.parse(path);
	  return getPathValue(parsed, obj);
	};

	/**
	 * ### .set(path, value, object)
	 *
	 * Define the value in an object at a given string path.
	 *
	 * ```js
	 * var obj = {
	 *     prop1: {
	 *         arr: ['a', 'b', 'c']
	 *       , str: 'Hello'
	 *     }
	 *   , prop2: {
	 *         arr: [ { nested: 'Universe' } ]
	 *       , str: 'Hello again!'
	 *     }
	 * };
	 * ```
	 *
	 * The following would be acceptable.
	 *
	 * ```js
	 * var properties = require('tea-properties');
	 * properties.set(obj, 'prop1.str', 'Hello Universe!');
	 * properties.set(obj, 'prop1.arr[2]', 'B');
	 * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
	 * ```
	 *
	 * @param {Object} object
	 * @param {String} path
	 * @param {Mixed} value
	 * @api public
	 */

	exports.set = function(obj, path, val) {
	  var parsed = exports.parse(path);
	  setPathValue(parsed, val, obj);
	};

	/*!
	 * Helper function used to parse string object
	 * paths. Use in conjunction with `getPathValue`.
	 *
	 *  var parsed = parsePath('myobject.property.subprop');
	 *
	 * ### Paths:
	 *
	 * * Can be as near infinitely deep and nested
	 * * Arrays are also valid using the formal `myobject.document[3].property`.
	 *
	 * @param {String} path
	 * @returns {Object} parsed
	 */

	exports.parse = function(path) {
	  var str = (path || '').replace(/\[/g, '.[');
	  var parts = str.match(/(\\\.|[^.]+?)+/g);

	  return parts.map(function(value) {
	    var re = /\[(\d+)\]$/
	      , mArr = re.exec(value)
	    if (mArr) return { i: parseFloat(mArr[1]) };
	    else return { p: value };
	  });
	};

	/*!
	 * Companion function for `parsePath` that returns
	 * the value located at the parsed address.
	 *
	 *  var value = getPathValue(parsed, obj);
	 *
	 * @param {Object} parsed definition from `parsePath`.
	 * @param {Object} object to search against
	 * @returns {Object|Undefined} value
	 */

	function getPathValue(parsed, obj) {
	  var tmp = obj;
	  var res;

	  for (var i = 0, l = parsed.length; i < l; i++) {
	    var part = parsed[i];
	    if (tmp) {
	      if (defined(part.p)) tmp = tmp[part.p];
	      else if (defined(part.i)) tmp = tmp[part.i];
	      if (i == (l - 1)) res = tmp;
	    } else {
	      res = undefined;
	    }
	  }

	  return res;
	};

	/*!
	 * Companion function for `parsePath` that sets
	 * the value located at a parsed address.
	 *
	 *  setPathValue(parsed, 'value', obj);
	 *
	 * @param {Object} parsed definition from `parsePath`
	 * @param {*} value to use upon set
	 * @param {Object} object to search and define on
	 * @api private
	 */

	function setPathValue(parsed, val, obj) {
	  var tmp = obj;
	  var i = 0;
	  var l = parsed.length;
	  var part;

	  for (; i < l; i++) {
	    part = parsed[i];

	    if (defined(tmp) && i == (l - 1)) {
	      var x = defined(part.p) ? part.p : part.i;
	      tmp[x] = val;
	    } else if (defined(tmp)) {
	      if (defined(part.p) && tmp[part.p]) {
	        tmp = tmp[part.p];
	      } else if (defined(part.i) && tmp[part.i]) {
	        tmp = tmp[part.i];
	      } else {
	        var next = parsed[i + 1];
	        var x = defined(part.p) ? part.p : part.i;
	        var y = defined(next.p) ? {} : [];
	        tmp[x] = y;
	        tmp = tmp[x];
	      }
	    } else {
	      if (i == (l - 1)) tmp = val;
	      else if (defined(part.p)) tmp = {};
	      else if (defined(part.i)) tmp = [];
	    }
	  }
	};

	/*!
	 * Check if `val` is defined.
	 *
	 * @param {Mixed} val
	 * @returns {Boolean} `true` if defined
	 * @api private
	 */

	function defined(val) {
	  return !(!val && 'undefined' === typeof val);
	}


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows unassigned functions to be named inline
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowNamedUnassignedFunctions": true
	 * ```
	 *
	 * ##### Valid
	 * ```js
	 * [].forEach(function () {});
	 * var x = function() {};
	 * function y() {}
	 * ```
	 *
	 * ##### Invalid
	 * ```js
	 * [].forEach(function x() {});
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires true value'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowNamedUnassignedFunctions';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('FunctionExpression', function(node) {
	            // If the function has been named via left hand assignment, skip it
	            //   e.g. `var hello = function() {`, `foo.bar = function() {`
	            if (node.parentNode.type.match(/VariableDeclarator|Property|AssignmentExpression/)) {
	                return;
	            }

	            // If the function has not been named, skip it
	            //   e.g. `[].forEach(function() {`
	            if (node.id === null) {
	                return;
	            }

	            // Otherwise, complain that it is being named
	            errors.add('Inline functions cannot be named', node.loc.start);
	        });
	    }
	};


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires function declarations by disallowing assignment of functions
	 * expressions to variables. Function expressions are allowed in all other
	 * contexts, including when passed as function arguments or immediately invoked.
	 *
	 * Assignment of function expressions to object members is also permitted, since
	 * these can't be declared.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireFunctionDeclarations": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * function declared() {
	 *
	 * };
	 *
	 * (function iife() {
	 *     void 0;
	 * })();
	 *
	 * var obj = {
	 *     a: function () {}
	 * };
	 *
	 * obj.b = function () { };
	 *
	 * $('#foo').click(function bar() {
	 *
	 * };)
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var expressed = function() {
	 *
	 * };
	 *
	 * var expressed = function deeply() {
	 *
	 * };
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireFunctionDeclarations';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType(
	            'VariableDeclarator',
	            function(node) {
	                if (node.init && node.init.type === 'FunctionExpression') {
	                    errors.add('Use a function declaration instead', node.loc.start);
	                }
	            }
	        );

	        file.iterateNodesByType(
	            'AssignmentExpression',
	            function(node) {
	                if (node.left.type !== 'MemberExpression' &&
	                    node.right.type === 'FunctionExpression') {
	                    errors.add('Use a function declaration instead', node.loc.start);
	                }
	            }
	        );
	    }
	};


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows function declarations.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowFunctionDeclarations": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var expressed = function() {
	 *
	 * };
	 *
	 * var expressed = function deeply() {
	 *
	 * };
	 *
	 * $('#foo').click(function bar() {
	 *
	 * };)
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * function stated() {
	 *
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowFunctionDeclarations';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('FunctionDeclaration', function(node) {
	            errors.add('Illegal function declaration', node.loc.start);
	        });
	    }
	};


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires the first alphabetical character of a comment to be uppercase, unless it is part of a multi-line textblock.
	 *
	 * By default, the prefix for inline comments `jscs` is ignored.
	 *
	 * Types: `Boolean` or `Object`
	 *
	 * Values:
	 *  - `true`
	 *  - `Object`:
	 *     - `allExcept`: array of quoted exceptions
	 *
	 * #### Example
	 *
	 * `"requireCapitalizedComments": true`
	 *
	 * Valid:
	 *
	 * ```
	 * // Valid
	 * //Valid
	 *
	 * /*
	 *   Valid
	 *  *\/
	 *
	 * /**
	 *  * Valid
	 *  *\/
	 *
	 * // A textblock is a set of lines
	 * // that starts with a capitalized letter
	 * // and has one or more non-capitalized lines
	 * // afterwards
	 *
	 * // A textblock may also have multiple lines.
	 * // Those lines can be uppercase as well to support
	 * // sentense breaks in textblocks
	 *
	 * // 123 or any non-alphabetical starting character
	 * // @are also valid anywhere
	 * ```
	 *
	 * Invalid:
	 * ```
	 * // invalid
	 * //invalid
	 * /** invalid *\/
	 * /**
	 *  * invalid
	 *  *\/
	 * ```
	 *
	 * ```js
	 * "requireCapitalizedComments": { "allExcept": ["jshint"] }
	 * ```
	 *
	 * Valid:
	 *
	 * ```
	 * function sayHello() {
	 *     \/* jshint: -W071 *\/
	 *
	 *     // I can now say hello in lots of statements, if I like.
	 *     return "Hello";
	 * }
	 * ```
	 *
	 * * Invalid:
	 *
	 * ```
	 * function sayHello() {
	 *     \/* jshint: -W071 *\/
	 *
	 *     // i can now say hello in lots of statements, if I like.
	 *     return "Hello";
	 * }
	 * ```
	 *
	 * * Invalid:
	 *
	 * ```
	 * function sayHello() {
	 *     \/* istanbul ignore next *\/
	 *
	 *     // I'd like to ignore this statement in coverage reports.
	 *     return "Hello";
	 * }
	 * ```
	 *
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        // except comments that begin with `jscs`, since these are used to
	        // selectively enable/disable rules within a file
	        this._exceptions = {
	            'jscs': true
	        };

	        var optionName = this.getOptionName();

	        var isObject = typeof options === 'object';

	        assert(
	            options === true ||
	            isObject,
	            optionName + ' option requires a true value ' +
	            'or an object with String[] `allExcept` property'
	        );

	        if (isObject) {
	            var exceptions = options.allExcept;

	            // verify items in `allExcept` property in object are string values
	            assert(
	                Array.isArray(exceptions) &&
	                exceptions.every(function(el) { return typeof el === 'string'; }),
	                'Property `allExcept` in ' + optionName + ' should be an array of strings'
	            );

	            for (var i = 0, l = exceptions.length; i < l; i++) {
	                this._exceptions[exceptions[i]] = true;
	            }
	        }
	    },

	    getOptionName: function() {
	        return 'requireCapitalizedComments';
	    },

	    check: function(file, errors) {
	        var inTextBlock = null;
	        var exceptions = this._exceptions;

	        var letterPattern = __webpack_require__(160);
	        var upperCasePattern = __webpack_require__(161);

	        file.iterateTokensByType(['Line', 'Block'], function(comment, index, comments) {
	            // strip leading whitespace and any asterisks
	            // split on whitespace and colons
	            var splitComment = comment.value.replace(/(^\s+|[\*])/g, '').split(/[\s\:]/g);

	            if (exceptions[splitComment[0]]) {
	                return;
	            }

	            var stripped = comment.value.replace(/[\n\s\*]/g, '');
	            var firstChar = stripped[0];
	            var isLetter = firstChar && letterPattern.test(firstChar);

	            if (!isLetter) {
	                inTextBlock = false;
	                return;
	            }

	            inTextBlock = inTextBlock &&
	                comments[index - 1].type === 'Line' &&
	                comments[index - 1].loc.start.line + 1 === comment.loc.start.line;

	            var isUpperCase = upperCasePattern.test(firstChar);
	            var isValid = isUpperCase || inTextBlock;

	            if (!isValid) {
	                errors.add(
	                    'Comments must start with an uppercase letter, unless it is part of a textblock',
	                    comment.loc.start
	                );
	            }

	            inTextBlock = comment.type === 'Line';
	        });
	    }
	};


/***/ },
/* 160 */
/***/ function(module, exports) {

	module.exports = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/;


/***/ },
/* 161 */
/***/ function(module, exports) {

	module.exports = /[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0\uA7B1\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]/;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires the first alphabetical character of a comment to be lowercase.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * `"disallowCapitalizedComments": true`
	 *
	 * Valid:
	 *
	 * ```
	 * // valid
	 * //valid
	 *
	 * /*
	 *   valid
	 *  *\/
	 *
	 * /**
	 *  * valid
	 *  *\/
	 *
	 * // 123 or any non-alphabetical starting character
	 * ```
	 *
	 * Invalid:
	 * ```
	 * // Invalid
	 * //Invalid
	 * /** Invalid *\/
	 * /**
	 *  * Invalid
	 *  *\/
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowCapitalizedComments';
	    },

	    check: function(file, errors) {
	        var letterPattern = __webpack_require__(160);
	        var lowerCasePattern = __webpack_require__(163);

	        file.iterateTokensByType(['Line', 'Block'], function(comment) {
	            var stripped = comment.value.replace(/[\n\s\*]/g, '');
	            var firstChar = stripped[0];

	            if (letterPattern.test(firstChar) && !lowerCasePattern.test(firstChar)) {
	                errors.add(
	                    'Comments must start with a lowercase letter',
	                    comment.loc.start
	                );
	            }
	        });
	    }
	};


/***/ },
/* 163 */
/***/ function(module, exports) {

	module.exports = /[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uAB30-\uAB5A\uAB64\uAB65\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]/;


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires placing line feed after assigning a variable.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireLineBreakAfterVariableAssignment": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var abc = 8;
	 * var foo = 5;
	 *
	 * var a, b, c,
	 *     foo = 7,
	 *     bar = 8;
	 *
	 * var a,
	 *     foo = 7,
	 *     a, b, c,
	 *     bar = 8;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var abc = 8; var foo = 5;
	 *
	 * var a, b, c,
	 *     foo = 7, bar = 8;
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireLineBreakAfterVariableAssignment';
	    },

	    check: function(file, errors) {
	        var lastDeclaration;
	        file.iterateNodesByType('VariableDeclaration', function(node) {
	            if (node.parentNode.type === 'ForStatement' ||
	                node.parentNode.type === 'ForInStatement' ||
	                node.parentNode.type === 'ForOfStatement') {
	                return;
	            }

	            for (var i = 0; i < node.declarations.length; i++) {
	                var thisDeclaration = node.declarations[i];
	                if (thisDeclaration.parentNode.kind === 'var' ||
	                    thisDeclaration.parentNode.kind === 'let' ||
	                    thisDeclaration.parentNode.kind === 'const') {
	                    if (lastDeclaration && lastDeclaration.init) {
	                        errors.assert.differentLine({
	                            token: lastDeclaration,
	                            nextToken: thisDeclaration,
	                            message: 'Variable assignments should be followed by new line'
	                        });
	                    }
	                    lastDeclaration = thisDeclaration;
	                }
	            }
	        });
	    }

	};


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires an extra blank newline after var declarations, as long
	 * as it is not the last expression in the current block.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requirePaddingNewLineAfterVariableDeclaration": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var x = {
	 *     a: 1
	 * };
	 *
	 * foo({
	 *     a: {
	 *         b: 1
	 *     }
	 * });
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var x = { a: 1 };
	 * foo({a:{b:1}});
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(requirePaddingNewLineAfterVariableDeclaration) {
	        assert(
	            requirePaddingNewLineAfterVariableDeclaration === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requirePaddingNewLineAfterVariableDeclaration';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('VariableDeclaration', function(node) {
	            if (node.parentNode.type === 'ForStatement' ||
	                node.parentNode.type === 'ForInStatement' ||
	                node.parentNode.type === 'ForOfStatement') {
	                return;
	            }

	            var endOfDeclaration = file.getLastNodeToken(node);
	            var nextToken = file.getNextToken(endOfDeclaration);

	            if (nextToken.value in {'var': true, 'let': true, 'const': true}) {
	                return;
	            }

	            if (nextToken.value === '}') {
	                return;
	            }

	            if (nextToken.type === 'EOF') {
	                return;
	            }

	            errors.assert.linesBetween({
	                atLeast: 2,
	                token: endOfDeclaration,
	                nextToken: nextToken
	            });
	        });
	    }

	};


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallow a blank line after `'use strict';` statements
	 *
	 * Values: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowPaddingNewLinesAfterUseStrict": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * 'use strict';
	 * // code
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * 'use strict';
	 *
	 * // code
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(disallowPaddingNewLinesAfterUseStrict) {
	        assert(
	            disallowPaddingNewLinesAfterUseStrict === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowPaddingNewLinesAfterUseStrict';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('ExpressionStatement', function(node) {
	            var expression = node.expression;

	            if (expression.type !== 'Literal' || expression.value !== 'use strict') {
	                return;
	            }

	            var endOfNode = file.getLastNodeToken(node);
	            var nextToken = file.getNextToken(endOfNode, {
	                includeComments: true
	            });

	            errors.assert.linesBetween({
	                atMost: 1,
	                token: endOfNode,
	                nextToken: nextToken
	            });
	        });
	    }
	};


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires a blank line after `'use strict';` statements
	 *
	 * Values: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requirePaddingNewLinesAfterUseStrict": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * 'use strict';
	 *
	 * // code
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * 'use strict';
	 * // code
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(requirePaddingNewLinesAfterUseStrict) {
	        assert(
	            requirePaddingNewLinesAfterUseStrict === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requirePaddingNewLinesAfterUseStrict';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('ExpressionStatement', function(node) {
	            var expression = node.expression;

	            if (expression.type !== 'Literal' || expression.value !== 'use strict') {
	                return;
	            }

	            var endOfNode = file.getLastNodeToken(node);
	            var nextToken = file.getNextToken(endOfNode, {
	                includeComments: true
	            });

	            errors.assert.linesBetween({
	                atLeast: 2,
	                token: endOfNode,
	                nextToken: nextToken
	            });
	        });
	    }
	};


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows newline before module.exports
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowPaddingNewLinesBeforeExport": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var a = 2;
	 * module.exports = a;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var a = 2;
	 *
	 * module.exports = a;
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        assert(
	            value === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowPaddingNewLinesBeforeExport';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('AssignmentExpression', function(node) {
	            var left = node.left;
	            if (!(
	                left.object &&
	                left.object.name === 'module' &&
	                left.property &&
	                left.property.name === 'exports')) {
	                return;
	            }

	            var firstToken = file.getFirstNodeToken(node);
	            var prevToken = file.getPrevToken(firstToken, {includeComments: true});

	            errors.assert.linesBetween({
	                atMost: 1,
	                token: prevToken,
	                nextToken: firstToken,
	                message: 'Unexpected extra newline before export'
	            });
	        });
	    }

	};


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires newline before module.exports
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requirePaddingNewLinesBeforeExport": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var a = 2;
	 *
	 * module.exports = a;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var a = 2;
	 * module.exports = a;
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(value) {
	        assert(
	            value === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requirePaddingNewLinesBeforeExport';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('AssignmentExpression', function(node) {
	            var left = node.left;
	            if (!(
	                left.object &&
	                left.object.name === 'module' &&
	                left.property &&
	                left.property.name === 'exports')) {
	                return;
	            }

	            var firstToken = file.getFirstNodeToken(node);
	            var prevToken = file.getPrevToken(firstToken);

	            errors.assert.linesBetween({
	                atLeast: 2,
	                token: prevToken,
	                nextToken: firstToken,
	                message: 'Missing newline before export'
	            });
	        });
	    }

	};


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires semicolon after:
	 *
	 * * var declaration
	 * * expression statement
	 * * return
	 * * throw
	 * * break
	 * * continue
	 * * do-while
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSemicolons": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var a = 1;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var a = 1
	 * ```
	*/

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireSemicolons';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType([
	            'VariableDeclaration',
	            'ExpressionStatement',
	            'DoWhileStatement',
	            'ReturnStatement',
	            'ThrowStatement',
	            'BreakStatement',
	            'ContinueStatement',
	            'DebuggerStatement'
	        ], function(node) {
	            // ignore variable declaration inside for and for-in
	            if (node.type === 'VariableDeclaration') {
	                if ((node.parentNode.type === 'ForInStatement' && node.parentNode.left === node) ||
	                    (node.parentNode.type === 'ForOfStatement' && node.parentNode.left === node) ||
	                    (node.parentNode.type === 'ForStatement' && node.parentNode.init === node)) {
	                    return;
	                }
	            }

	            // get last token inside node
	            var lastToken = file.getLastNodeToken(node);
	            var checkToken = lastToken;

	            // if last token is not a semicolon punctuator, try to get next token in file
	            if (checkToken && (checkToken.type !== 'Punctuator' || checkToken.value !== ';')) {
	                checkToken = file.getNextToken(checkToken);
	            }

	            // check token is semicolon
	            if (!checkToken || checkToken.type !== 'Punctuator' || checkToken.value !== ';') {
	                errors.add(
	                    'Missing semicolon after statement',
	                    (lastToken || node).loc.end
	                );
	            }
	        });
	    }
	};


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows lines from ending in a semicolon.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSemicolons": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var a = 1
	 * ;[b].forEach(c)
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var a = 1;
	 * [b].forEach(c);
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowSemicolons';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByTypeAndValue('Punctuator', ';', function(token) {
	            var nextToken = file.getNextToken(token);
	            // do not use assertions here as this is not yet autofixable
	            if (nextToken.type === 'EOF' || nextToken.loc.end.line > token.loc.end.line) {
	                errors.add('semicolons are disallowed at the end of a line.', token.loc.end);
	            }
	        });
	    }
	};


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires spaces inbetween for statement.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true` to requires spaces inbetween for statement.
	 *
	 * #### Example
	 *
	 * ```js
	 * "requireSpacesInForStatement": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * for(var i = 0; i<l; i++) {
	 *     x++;
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * for(var i = 0;i<l;i++) {
	 *     x++;
	 * }
	 * ```
	 *
	 * ```js
	 * for(var i = 0; i<l;i++) {
	 *     x++;
	 * }
	 * ```
	 *
	 * ```js
	 * for(var i = 0;i<l; i++) {
	 *     x++;
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'requireSpacesInForStatement';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('ForStatement', function(node) {
	            if (node.test) {
	                var testToken = file.getFirstNodeToken(node.test);
	                errors.assert.spacesBetween({
	                    token: file.getPrevToken(testToken),
	                    nextToken: testToken,
	                    exactly: 1,
	                    message: 'One space required after semicolon'
	                });
	            }
	            if (node.update) {
	                var updateToken = file.getFirstNodeToken(node.update);
	                errors.assert.spacesBetween({
	                    token: file.getPrevToken(updateToken),
	                    nextToken: updateToken,
	                    exactly: 1,
	                    message: 'One space required after semicolon'
	                });
	            }
	        });
	    }
	};


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallow spaces in between for statement.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true` to disallow spaces in between for statement.
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowSpacesInForStatement": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * for(var i=0;i<l;i++) {
	 *     x++;
	 * }
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * for(var i = 0; i<l; i++) {
	 *     x++;
	 * }
	 * ```
	 *
	 * ```js
	 * for(var i = 0; i<l;i++) {
	 *     x++;
	 * }
	 * ```
	 *
	 * ```js
	 * for(var i = 0;i<l; i++) {
	 *     x++;
	 * }
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowSpacesInForStatement';
	    },

	    check: function(file, errors) {
	        file.iterateNodesByType('ForStatement', function(node) {
	            if (node.test) {
	                var testToken = file.getFirstNodeToken(node.test);
	                errors.assert.noWhitespaceBetween({
	                    token: file.getPrevToken(testToken),
	                    nextToken: testToken,
	                    message: 'Space found after semicolon'
	                });
	            }
	            if (node.update) {
	                var updateToken = file.getFirstNodeToken(node.update);
	                errors.assert.noWhitespaceBetween({
	                    token: file.getPrevToken(updateToken),
	                    nextToken: updateToken,
	                    message: 'Space found after semicolon'
	                });
	            }
	        });
	    }
	};


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows keywords in your comments, such as TODO or FIXME
	 *
	 * Types: `Boolean`, `String` or `Array`
	 *
	 * Values:
	 * - `true`
	 * - `'\b(word1|word2)\b'`
	 * - `['word1', 'word2']`
	 *
	 * #### Examples
	 *
	 * ```js
	 * "disallowKeywordsInComments": true
	 * "disallowKeywordsInComments": "\\b(word1|word2)\\b"
	 * "disallowKeywordsInComments": ["word1", "word2"]
	 * ```
	 *
	 * #### Invalid:
	 * ```
	 * // ToDo
	 * //TODO
	 * /** fixme *\/
	 * /**
	 *  * FIXME
	 *  *\/
	 * ```
	 */

	var assert = __webpack_require__(23);

	function getCommentErrors(comment, keywordRegEx) {
	    var splitComment = comment.value.split('\n');
	    var errors = [];

	    splitComment.forEach(function(commentNode, index) {
	        var lineIndex = index;
	        var matches = commentNode.match(keywordRegEx);
	        var lastIndex = -1;

	        if (!matches) { return; }

	        errors = errors.concat(matches.map(function(match) {
	            lastIndex++;
	            lastIndex = commentNode.indexOf(match, lastIndex);

	            // line + lineIndex because comment block was split at new lines
	            //   will place carat at correct place within multiline comment
	            // foundAtIndex += 2 because comment opening is stripped
	            //   +2 finds accurate carat position on opening line comment
	            return {
	                line: comment.loc.start.line + lineIndex,
	                column: lastIndex + (lineIndex > 0 ? 0 : 2)
	            };
	        }));
	    });

	    return errors;
	}

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(keywords) {
	        this._message = 'Comments cannot contain the following keywords: ';
	        this._keywords = ['todo', 'fixme'];

	        switch (true) {
	            case Array.isArray(keywords):
	                // use the array of strings provided to build RegExp pattern
	                this._keywords = keywords;
	                /* falls through */
	            case keywords:
	                // use default keywords
	                this._message += this._keywords.join(', ');
	                this._keywordRegEx = new RegExp('\\b(' + this._keywords.join('|') + ')\\b', 'gi');
	                break;
	            case typeof keywords === 'string':
	                // use string passed in as the RegExp pattern
	                this._message = 'Comments cannot contain keywords based on the expression you provided';
	                this._keywordRegEx = new RegExp(keywords, 'gi');
	                break;
	            default:
	                assert(false, this.getOptionName() + ' option requires a true value, a string or an array');
	        }
	    },

	    getOptionName: function() {
	        return 'disallowKeywordsInComments';
	    },

	    check: function(file, errors) {
	        file.iterateTokensByType(['Line', 'Block'], function(comment) {
	            getCommentErrors(comment, this._keywordRegEx).forEach(function(errorObj) {
	                errors.add(this._message, errorObj);
	            }.bind(this));
	        }.bind(this));
	    }
	};


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows a specified set of identifier names.
	 *
	 * Type: `Array`
	 *
	 * Values: Array of strings, which should be disallowed as identifier names
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowIdentifierNames": ['temp', 'foo']
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * var good = 1;
	 * object['fine'] = 2;
	 * object.fine = 3;
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * var temp = 1;
	 * object['foo'] = 2;
	 * object.foo = 3;
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(identifiers) {
	        assert(
	            Array.isArray(identifiers),
	            'disallowIdentifierNames option requires an array'
	        );

	        this._identifierIndex = {};
	        for (var i = 0, l = identifiers.length; i < l; i++) {
	            this._identifierIndex[identifiers[i]] = true;
	        }
	    },

	    getOptionName: function() {
	        return 'disallowIdentifierNames';
	    },

	    check: function(file, errors) {
	        var disallowedIdentifiers = this._identifierIndex;

	        file.iterateNodesByType('Identifier', function(node) {
	            if (Object.prototype.hasOwnProperty.call(disallowedIdentifiers, node.name)) {
	                errors.add('Illegal Identifier name: ' + node.name, node.loc.start);
	            }
	        });

	        file.iterateNodesByType('MemberExpression', function(node) {
	            if (node.property.type === 'Literal') {
	                if (Object.prototype.hasOwnProperty.call(disallowedIdentifiers, node.property.value)) {
	                    errors.add('Illegal Identifier name: ' + node.property.value, node.property.loc.start);
	                }
	            }
	        });

	    }

	};


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires the file to be at most the number of lines specified
	 *
	 * Type: `Integer`
	 *
	 * Values:
	*  - `Integer`: file should be at most the number of lines specified
	 *
	 * #### Example
	 *
	 * ```js
	 * "maximumNumberOfLines": 100
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            typeof options === 'number',
	            this.getOptionName() + ' option requires number value or should be removed'
	        );
	        this._maximumNumberOfLines = options;
	    },

	    getOptionName: function() {
	        return 'maximumNumberOfLines';
	    },

	    check: function(file, errors) {
	        var firstToken = file.getFirstToken();
	        var lastToken = file.getLastToken();

	        errors.assert.linesBetween({
	            token: firstToken,
	            nextToken: lastToken,
	            atMost: this._maximumNumberOfLines - 1,
	            message: 'File must be at most ' + this._maximumNumberOfLines + ' lines long'
	        });
	    }

	};


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Requires each element in array on a single line when array length is more than passed maximum
	 * number or array fills more than one line.
	 * Set `ignoreBrackets` to `true` to allow elements on the same line with brackets.
	 *
	 * Type: `Boolean` or `Number` (maximum) or `Object` (`{maximum: Number, ignoreBrackets: Boolean}`)
	 *
	 * Values: `true`
	 *
	 * Default: `{maximum: Infinity, ignoreBrackets: false}`
	 *
	 * #### Example
	 *
	 * ```js
	 * "validateNewlineAfterArrayElements": {
	 *   "maximum": 3
	 * }
	 * ```
	 *
	 * ##### Valid for `true`
	 *
	 * ```js
	 * var x = [{a: 1}, [2], '3', 4, 5, 6];
	 * var x = [
	 *   {a: 1},
	 *   [2],
	 *   '3',
	 *   4
	 * ];
	 * ```
	 *
	 * ##### Invalid for `true`
	 *
	 * ```js
	 * var x = [1,
	 *   2];
	 * ```
	 *
	 * ##### Valid for `3`
	 *
	 * ```js
	 * var x = [{a: 1}, [2], '3'];
	 * var x = [
	 *   1,
	 *   2,
	 *   3,
	 *   4
	 * ];
	 * ```
	 *
	 * ##### Invalid for `3`
	 *
	 * ```js
	 * var x = [1, 2, 3, 4];
	 * var x = [1,
	 *   2,
	 *   3];
	 * var x = [
	 *     1, 2
	 * ];
	 * ```
	 *
	 * ##### Valid for `{maximum: 2, ignoreBrackets: true}`
	 *
	 * ```js
	 * var x = [{a: 1}, [2]];
	 * var x = [1,
	 *   2,
	 *   3];
	 * ```
	 *
	 * ##### Invalid for `{maximum: 2, ignoreBrackets: true}`
	 *
	 * ```js
	 * var x = [1, 2, 3];
	 * var x = [1, 2,
	 *   3];
	 * var x = [1,
	 *   2, 3];
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {
	    configure: function(opts) {
	        assert(
	            opts === true ||
	            typeof opts === 'number' && opts >= 1 ||
	            typeof opts === 'object',
	            this.getOptionName() + ' option requires maximal number of items ' +
	                'or true value either should be removed'
	        );
	        if (typeof opts === 'object') {
	            this._options = opts;

	            if ('maximum' in opts) {
	                assert(typeof opts.maximum === 'number' && opts.maximum >= 1,
	                    'maximum property requires a positive number or should be removed');
	            } else {
	                opts.maximum = Infinity;
	            }

	            if ('ignoreBrackets' in opts) {
	                assert(opts.ignoreBrackets === true,
	                    'ignoreBrackets property requires true value or should be removed');
	            } else {
	                opts.ignoreBrackets = false;
	            }

	        } else {
	            this._options = {
	                maximum: opts === true ? Infinity : opts,
	                ignoreBrackets: false
	            };
	        }
	    },

	    getOptionName: function() {
	        return 'validateNewlineAfterArrayElements';
	    },

	    check: function(file, errors) {
	        var maximum = this._options.maximum;
	        var ignoreBrackets = this._options.ignoreBrackets;

	        file.iterateNodesByType(['ArrayExpression'], function(node) {
	            var els = node.elements;
	            if (els.length <= maximum && node.loc.start.line === node.loc.end.line) {
	                return;
	            }

	            if (!ignoreBrackets) {
	                if (els[0] && els[0].loc.start.line === node.loc.start.line) {
	                    errors.add('First element should be placed on new line', els[0].loc.start);
	                }
	                if (els[els.length - 1] && els[els.length - 1].loc.end.line === node.loc.end.line) {
	                    errors.add('Closing bracket should be placed on new line', node.loc.end);
	                }
	            }

	            var prevLine = 0;
	            els.forEach(function(elem) {
	                if (!elem) {
	                    // skip holes
	                    return;
	                }
	                var line = elem.loc.start.line;
	                if (prevLine === line) {
	                    errors.add('Multiple elements at a single line in multiline array', {
	                        line: line,
	                        column: elem.loc.start.column
	                    });
	                }
	                prevLine = line;
	            });

	        });
	    }
	};


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Disallows the not, not equals, and strict not equals operators in conditionals.
	 *
	 * Type: `Boolean`
	 *
	 * Value: `true`
	 *
	 * #### Example
	 *
	 * ```js
	 * "disallowNotOperatorsInConditionals": true
	 * ```
	 *
	 * ##### Valid
	 *
	 * ```js
	 * if (clause) {
	 *     // Do something really crazy
	 * } else {
	 *     // Do something crazy
	 * }
	 *
	 * if (a == 1) {
	 *     // Do something really crazy
	 * } else {
	 *     // Do something crazy
	 * }
	 *
	 * var a = (clause) ? 1 : 0
	 * ```
	 *
	 * ##### Invalid
	 *
	 * ```js
	 * if (!clause) {
	 *     // Do something crazy
	 * } else {
	 *     // Do something really crazy
	 * }
	 *
	 * if (a != 1) {
	 *     // Do something crazy
	 * } else {
	 *     // Do something really crazy
	 * }
	 *
	 * if (a !== 1) {
	 *     // Do something crazy
	 * } else {
	 *     // Do something really crazy
	 * }
	 *
	 * var a = (!clause) ? 0 : 1
	 * ```
	 */

	var assert = __webpack_require__(23);

	module.exports = function() {};

	module.exports.prototype = {

	    configure: function(options) {
	        assert(
	            options === true,
	            this.getOptionName() + ' option requires a true value or should be removed'
	        );
	    },

	    getOptionName: function() {
	        return 'disallowNotOperatorsInConditionals';
	    },

	    check: function(file, errors) {
	        function hasNotOperator(test) {
	            return test.type === 'UnaryExpression' && test.operator === '!';
	        }

	        function hasNotEqualOperator(test) {
	            return test.type === 'BinaryExpression' && test.operator === '!=';
	        }

	        function hasStrictNotEqualOperator(test) {
	            return test.type === 'BinaryExpression' && test.operator === '!==';
	        }

	        file.iterateNodesByType(['IfStatement', 'ConditionalExpression'], function(node) {
	            var alternate = node.alternate;

	            // check if the if statement has an else block
	            if (node.type === 'IfStatement' && (!alternate || alternate.type !== 'BlockStatement')) {
	                return;
	            }
	            var test = node.test;
	            if (hasNotOperator(test)) {
	                errors.add('Illegal use of not operator in if statement', test.loc.start);
	            }
	            if (hasNotEqualOperator(test)) {
	                errors.add('Illegal use of not equal operator in if statement', test.loc.end);
	            }
	            if (hasStrictNotEqualOperator(test)) {
	                errors.add('Illegal use of strict not equal operator in if statement', test.loc.end);
	            }
	        });
	    }
	};


/***/ },
/* 179 */
/***/ function(module, exports) {

	module.exports = {
		"disallowSpacesInNamedFunctionExpression": {
			"beforeOpeningRoundBrace": true
		},
		"disallowSpacesInFunctionExpression": {
			"beforeOpeningRoundBrace": true
		},
		"disallowSpacesInAnonymousFunctionExpression": {
			"beforeOpeningRoundBrace": true
		},
		"disallowSpacesInFunctionDeclaration": {
			"beforeOpeningRoundBrace": true
		},
		"disallowEmptyBlocks": true,
		"disallowSpacesInsideArrayBrackets": true,
		"disallowSpacesInsideParentheses": true,
		"disallowQuotedKeysInObjects": true,
		"disallowSpaceAfterObjectKeys": true,
		"disallowSpaceAfterPrefixUnaryOperators": true,
		"disallowSpaceBeforePostfixUnaryOperators": true,
		"disallowSpaceBeforeBinaryOperators": [
			","
		],
		"disallowMixedSpacesAndTabs": true,
		"disallowTrailingWhitespace": true,
		"disallowTrailingComma": true,
		"disallowYodaConditions": true,
		"disallowKeywords": [
			"with"
		],
		"disallowMultipleLineBreaks": true,
		"disallowMultipleVarDecl": true,
		"requireSpaceBeforeBlockStatements": true,
		"requireParenthesesAroundIIFE": true,
		"requireSpacesInConditionalExpression": true,
		"requireBlocksOnNewline": 1,
		"requireCommaBeforeLineBreak": true,
		"requireSpaceBeforeBinaryOperators": true,
		"requireSpaceAfterBinaryOperators": true,
		"requireCamelCaseOrUpperCaseIdentifiers": true,
		"requireLineFeedAtFileEnd": true,
		"requireCapitalizedConstructors": true,
		"requireDotNotation": true,
		"requireSpacesInForStatement": true,
		"requireSpaceBetweenArguments": true,
		"requireCurlyBraces": [
			"do"
		],
		"requireSpaceAfterKeywords": [
			"if",
			"else",
			"for",
			"while",
			"do",
			"switch",
			"case",
			"return",
			"try",
			"catch",
			"typeof"
		],
		"requirePaddingNewLinesBeforeLineComments": {
			"allExcept": "firstAfterCurly"
		},
		"requirePaddingNewLinesAfterBlocks": true,
		"safeContextKeyword": "_this",
		"validateLineBreaks": "LF",
		"validateQuoteMarks": "'",
		"validateIndentation": 2
	};

/***/ },
/* 180 */
/***/ function(module, exports) {

	module.exports = {
		"requireCurlyBraces": [
			"if",
			"else",
			"for",
			"while",
			"do",
			"try",
			"catch"
		],
		"requireSpaceAfterKeywords": [
			"if",
			"else",
			"for",
			"while",
			"do",
			"switch",
			"case",
			"return",
			"try",
			"catch",
			"function",
			"typeof"
		],
		"requireSpaceBeforeBlockStatements": true,
		"requireParenthesesAroundIIFE": true,
		"requireSpacesInConditionalExpression": true,
		"disallowSpacesInNamedFunctionExpression": {
			"beforeOpeningRoundBrace": true
		},
		"disallowSpacesInFunctionDeclaration": {
			"beforeOpeningRoundBrace": true
		},
		"requireSpaceBetweenArguments": true,
		"requireMultipleVarDecl": "onevar",
		"requireBlocksOnNewline": true,
		"disallowEmptyBlocks": true,
		"disallowSpacesInsideArrayBrackets": true,
		"disallowSpacesInsideParentheses": true,
		"disallowDanglingUnderscores": true,
		"requireCommaBeforeLineBreak": true,
		"disallowSpaceAfterPrefixUnaryOperators": true,
		"disallowSpaceBeforePostfixUnaryOperators": true,
		"disallowSpaceBeforeBinaryOperators": [
			","
		],
		"requireSpacesInForStatement": true,
		"requireSpaceBeforeBinaryOperators": true,
		"requireSpaceAfterBinaryOperators": true,
		"disallowKeywords": [
			"with",
			"continue"
		],
		"validateIndentation": 4,
		"disallowMixedSpacesAndTabs": true,
		"disallowTrailingWhitespace": true,
		"disallowTrailingComma": true,
		"disallowKeywordsOnNewLine": [
			"else"
		],
		"requireLineFeedAtFileEnd": true,
		"requireCapitalizedConstructors": true,
		"requireDotNotation": true,
		"disallowNewlineBeforeBlockStatements": true,
		"disallowMultipleLineStrings": true,
		"requireSpaceBeforeObjectValues": true
	};

/***/ },
/* 181 */
/***/ function(module, exports) {

	module.exports = {
		"requireCurlyBraces": [
			"if",
			"else",
			"for",
			"while",
			"do",
			"try",
			"catch"
		],
		"requireOperatorBeforeLineBreak": true,
		"requireCamelCaseOrUpperCaseIdentifiers": true,
		"maximumLineLength": {
			"value": 80,
			"allowComments": true,
			"allowRegex": true
		},
		"validateIndentation": 2,
		"validateQuoteMarks": "'",
		"disallowMultipleLineStrings": true,
		"disallowMixedSpacesAndTabs": true,
		"disallowTrailingWhitespace": true,
		"disallowSpaceAfterPrefixUnaryOperators": true,
		"disallowMultipleVarDecl": true,
		"disallowKeywordsOnNewLine": [
			"else"
		],
		"requireSpaceAfterKeywords": [
			"if",
			"else",
			"for",
			"while",
			"do",
			"switch",
			"return",
			"try",
			"catch"
		],
		"requireSpaceBeforeBinaryOperators": [
			"=",
			"+=",
			"-=",
			"*=",
			"/=",
			"%=",
			"<<=",
			">>=",
			">>>=",
			"&=",
			"|=",
			"^=",
			"+=",
			"+",
			"-",
			"*",
			"/",
			"%",
			"<<",
			">>",
			">>>",
			"&",
			"|",
			"^",
			"&&",
			"||",
			"===",
			"==",
			">=",
			"<=",
			"<",
			">",
			"!=",
			"!=="
		],
		"requireSpaceAfterBinaryOperators": true,
		"requireSpacesInConditionalExpression": true,
		"requireSpaceBeforeBlockStatements": true,
		"requireSpacesInForStatement": true,
		"requireLineFeedAtFileEnd": true,
		"requireSpacesInFunctionExpression": {
			"beforeOpeningCurlyBrace": true
		},
		"disallowSpacesInAnonymousFunctionExpression": {
			"beforeOpeningRoundBrace": true
		},
		"disallowSpacesInsideObjectBrackets": "all",
		"disallowSpacesInsideArrayBrackets": "all",
		"disallowSpacesInsideParentheses": true,
		"disallowMultipleLineBreaks": true,
		"disallowNewlineBeforeBlockStatements": true
	};

/***/ },
/* 182 */
/***/ function(module, exports) {

	module.exports = {
		"preset": "google",
		"maximumLineLength": 120,
		"requireCamelCaseOrUpperCaseIdentifiers": "ignoreProperties",
		"validateQuoteMarks": {
			"mark": "'",
			"escape": true
		},
		"disallowMultipleVarDecl": "exceptUndefined"
	};

/***/ },
/* 183 */
/***/ function(module, exports) {

	module.exports = {
		"requireCurlyBraces": [
			"if",
			"else",
			"for",
			"while",
			"do",
			"try",
			"catch"
		],
		"requireOperatorBeforeLineBreak": true,
		"requireParenthesesAroundIIFE": true,
		"requireCommaBeforeLineBreak": true,
		"requireCamelCaseOrUpperCaseIdentifiers": true,
		"requireDotNotation": "except_snake_case",
		"requireSpacesInForStatement": true,
		"requireSpaceBetweenArguments": true,
		"maximumLineLength": {
			"value": 100,
			"tabSize": 4,
			"allowUrlComments": true,
			"allowRegex": true
		},
		"validateQuoteMarks": {
			"mark": "\"",
			"escape": true
		},
		"disallowMixedSpacesAndTabs": "smart",
		"disallowTrailingWhitespace": true,
		"disallowMultipleLineStrings": true,
		"disallowTrailingComma": true,
		"requireSpaceBeforeBlockStatements": true,
		"requireSpacesInFunctionExpression": {
			"beforeOpeningCurlyBrace": true
		},
		"requireSpacesInsideParentheses": "all",
		"requireSpaceAfterKeywords": [
			"if",
			"else",
			"for",
			"while",
			"do",
			"switch",
			"return",
			"try",
			"catch"
		],
		"requireSpacesInsideObjectBrackets": "all",
		"requireSpacesInsideArrayBrackets": "all",
		"requireSpacesInConditionalExpression": true,
		"requireSpaceAfterBinaryOperators": true,
		"requireLineFeedAtFileEnd": true,
		"requireSpaceBeforeBinaryOperators": [
			"=",
			"+=",
			"-=",
			"*=",
			"/=",
			"%=",
			"<<=",
			">>=",
			">>>=",
			"&=",
			"|=",
			"^=",
			"+=",
			"+",
			"-",
			"*",
			"/",
			"%",
			"<<",
			">>",
			">>>",
			"&",
			"|",
			"^",
			"&&",
			"||",
			"===",
			"==",
			">=",
			"<=",
			"<",
			">",
			"!=",
			"!=="
		],
		"requireSpacesInAnonymousFunctionExpression": {
			"beforeOpeningCurlyBrace": true
		},
		"requireSpacesInNamedFunctionExpression": {
			"beforeOpeningCurlyBrace": true
		},
		"requirePaddingNewLinesBeforeLineComments": true,
		"validateLineBreaks": "LF",
		"disallowKeywords": [
			"with"
		],
		"disallowKeywordsOnNewLine": [
			"else"
		],
		"disallowSpacesInFunctionExpression": {
			"beforeOpeningRoundBrace": true
		},
		"disallowSpacesInNamedFunctionExpression": {
			"beforeOpeningRoundBrace": true
		},
		"disallowSpacesInAnonymousFunctionExpression": {
			"beforeOpeningRoundBrace": true
		},
		"disallowSpaceAfterObjectKeys": true,
		"disallowSpaceAfterPrefixUnaryOperators": true,
		"disallowSpaceBeforePostfixUnaryOperators": true,
		"disallowSpaceBeforeBinaryOperators": [
			",",
			":"
		],
		"disallowMultipleLineBreaks": true
	};

/***/ },
/* 184 */
/***/ function(module, exports) {

	module.exports = {
		"requireCurlyBraces": [
			"while",
			"do",
			"try",
			"catch"
		],
		"requireSpaceAfterKeywords": [
			"if",
			"else",
			"for",
			"while",
			"do",
			"switch",
			"return",
			"try",
			"catch"
		],
		"requireSpacesInFunctionExpression": {
			"beforeOpeningCurlyBrace": true
		},
		"requirePaddingNewlinesInBlocks": true,
		"requireSpacesInsideObjectBrackets": "all",
		"requireSpacesInsideArrayBrackets": "allButNested",
		"requireSpaceBeforeBlockStatements": true,
		"requireSpacesInForStatement": true,
		"disallowKeywords": [
			"with"
		],
		"requireLineFeedAtFileEnd": true,
		"validateLineBreaks": "LF",
		"validateIndentation": "\t",
		"requireSpaceAfterPrefixUnaryOperators": [
			"++",
			"--"
		],
		"requireSpaceBetweenArguments": true,
		"requireSpaceBeforePostfixUnaryOperators": [
			"++",
			"--"
		],
		"requireSpaceBeforeBinaryOperators": [
			"+",
			"-",
			"/",
			"*",
			"=",
			"==",
			"===",
			"!=",
			"!==",
			">",
			">=",
			"<",
			"<="
		],
		"requireSpaceAfterBinaryOperators": [
			"+",
			"-",
			"/",
			"*",
			"=",
			"==",
			"===",
			"!=",
			"!==",
			">",
			">=",
			"<",
			"<="
		],
		"disallowSpaceBeforeBinaryOperators": [
			","
		],
		"requireSpacesInConditionalExpression": {
			"afterTest": true,
			"beforeConsequent": true,
			"afterConsequent": true,
			"beforeAlternate": true
		}
	};

/***/ },
/* 185 */
/***/ function(module, exports) {

	module.exports = {
		"disallowKeywords": [
			"with"
		],
		"disallowKeywordsOnNewLine": [
			"else"
		],
		"disallowMixedSpacesAndTabs": true,
		"disallowMultipleVarDecl": "exceptUndefined",
		"disallowNewlineBeforeBlockStatements": true,
		"disallowQuotedKeysInObjects": true,
		"disallowSpaceAfterObjectKeys": true,
		"disallowSpaceAfterPrefixUnaryOperators": true,
		"disallowSpacesInFunction": {
			"beforeOpeningRoundBrace": true
		},
		"disallowSpacesInsideParentheses": true,
		"disallowTrailingWhitespace": true,
		"maximumLineLength": 80,
		"requireCamelCaseOrUpperCaseIdentifiers": true,
		"requireCapitalizedComments": true,
		"requireCapitalizedConstructors": true,
		"requireCurlyBraces": true,
		"requireSpaceAfterKeywords": [
			"if",
			"else",
			"for",
			"while",
			"do",
			"switch",
			"case",
			"return",
			"try",
			"catch",
			"typeof"
		],
		"requireSpaceAfterLineComment": true,
		"requireSpaceAfterBinaryOperators": true,
		"requireSpaceBeforeBinaryOperators": true,
		"requireSpaceBeforeBlockStatements": true,
		"requireSpaceBeforeObjectValues": true,
		"requireSpacesInFunction": {
			"beforeOpeningCurlyBrace": true
		},
		"requireTrailingComma": {
			"ignoreSingleLine": true
		},
		"validateIndentation": 2,
		"validateLineBreaks": "LF",
		"validateQuoteMarks": "'"
	};

/***/ },
/* 186 */
/***/ function(module, exports) {

	module.exports = {
		"requireCurlyBraces": [
			"if",
			"else",
			"for",
			"while",
			"do",
			"try",
			"catch"
		],
		"requireSpaceBeforeKeywords": true,
		"requireSpaceAfterKeywords": true,
		"requireSpaceBeforeBlockStatements": true,
		"requireParenthesesAroundIIFE": true,
		"requireSpacesInConditionalExpression": true,
		"disallowSpacesInNamedFunctionExpression": {
			"beforeOpeningRoundBrace": true
		},
		"disallowSpacesInFunctionDeclaration": {
			"beforeOpeningRoundBrace": true
		},
		"disallowSpacesInCallExpression": true,
		"requireMultipleVarDecl": "onevar",
		"requireBlocksOnNewline": 1,
		"disallowEmptyBlocks": true,
		"requireSpacesInsideObjectBrackets": "all",
		"requireSpacesInsideArrayBrackets": "all",
		"requireSpacesInsideParentheses": "all",
		"disallowQuotedKeysInObjects": "allButReserved",
		"disallowDanglingUnderscores": true,
		"disallowSpaceAfterObjectKeys": true,
		"requireSpaceBeforeObjectValues": true,
		"requireCommaBeforeLineBreak": true,
		"requireSpacesInForStatement": true,
		"requireSpaceBetweenArguments": true,
		"disallowSpaceAfterPrefixUnaryOperators": true,
		"disallowSpaceBeforePostfixUnaryOperators": true,
		"disallowSpaceBeforeBinaryOperators": [
			","
		],
		"requireSpaceBeforeBinaryOperators": true,
		"requireSpaceAfterBinaryOperators": true,
		"disallowImplicitTypeConversion": [
			"binary",
			"string"
		],
		"requireCamelCaseOrUpperCaseIdentifiers": true,
		"disallowKeywords": [
			"with"
		],
		"disallowMultipleLineBreaks": true,
		"disallowMixedSpacesAndTabs": true,
		"disallowOperatorBeforeLineBreak": [
			"."
		],
		"disallowTrailingWhitespace": true,
		"disallowTrailingComma": true,
		"disallowKeywordsOnNewLine": [
			"else",
			"catch"
		],
		"requireLineBreakAfterVariableAssignment": true,
		"requireLineFeedAtFileEnd": true,
		"requireCapitalizedConstructors": true,
		"requireDotNotation": true,
		"disallowYodaConditions": true,
		"requireSpaceAfterLineComment": true,
		"disallowNewlineBeforeBlockStatements": true,
		"validateLineBreaks": "LF",
		"validateQuoteMarks": "'",
		"validateIndentation": "\t"
	};

/***/ },
/* 187 */
/***/ function(module, exports) {

	module.exports = {
		"preset": "jquery",
		"disallowSpaceAfterPrefixUnaryOperators": [
			"++",
			"--",
			"+",
			"-",
			"~"
		],
		"disallowSpaceBeforePostfixUnaryOperators": true,
		"maximumLineLength": null,
		"requireSpaceAfterPrefixUnaryOperators": [
			"!"
		],
		"requireSpacesInsideParentheses": {
			"all": true,
			"except": [
				"{",
				"}",
				"[",
				"]",
				"function"
			]
		},
		"requireYodaConditions": true,
		"validateQuoteMarks": "'"
	};

/***/ },
/* 188 */
/***/ function(module, exports) {

	module.exports = {
		"requireCurlyBraces": [
			"if",
			"else",
			"for",
			"while",
			"do"
		],
		"requireSpaceAfterKeywords": [
			"if",
			"else",
			"for",
			"while",
			"do",
			"switch",
			"return",
			"catch"
		],
		"disallowKeywords": [
			"with"
		],
		"disallowKeywordsOnNewLine": [
			"else",
			"catch"
		],
		"disallowSpaceAfterPrefixUnaryOperators": true,
		"disallowSpaceBeforePostfixUnaryOperators": [
			"++",
			"--"
		],
		"requireSpaceBeforeBinaryOperators": true,
		"requireSpaceAfterBinaryOperators": true,
		"disallowMultipleVarDecl": true,
		"disallowSpacesInsideParentheses": true,
		"disallowEmptyBlocks": true,
		"requireParenthesesAroundIIFE": true,
		"requireSpaceBetweenArguments": true,
		"requireSpacesInFunctionDeclaration": {
			"beforeOpeningCurlyBrace": true
		},
		"disallowSpacesInFunctionDeclaration": {
			"beforeOpeningRoundBrace": true
		},
		"requireSpacesInAnonymousFunctionExpression": {
			"beforeOpeningRoundBrace": true,
			"beforeOpeningCurlyBrace": true
		},
		"disallowSpacesInNamedFunctionExpression": {
			"beforeOpeningRoundBrace": true
		},
		"requireSpacesInNamedFunctionExpression": {
			"beforeOpeningCurlyBrace": true
		},
		"requireSpacesInConditionalExpression": {
			"afterTest": true,
			"beforeConsequent": true,
			"afterConsequent": true,
			"beforeAlternate": true
		},
		"disallowSpaceBeforeBinaryOperators": [
			","
		],
		"requireCommaBeforeLineBreak": true,
		"validateQuoteMarks": "'",
		"disallowMultipleLineStrings": true,
		"disallowImplicitTypeConversion": [
			"numeric",
			"boolean",
			"binary",
			"string"
		],
		"disallowYodaConditions": true,
		"disallowSpacesInsideArrayBrackets": true,
		"requireDotNotation": true,
		"disallowSpaceAfterObjectKeys": true,
		"disallowSpacesInsideObjectBrackets": true,
		"disallowQuotedKeysInObjects": true,
		"maximumLineLength": {
			"value": 120,
			"allowUrlComments": true
		},
		"requireSpaceAfterLineComment": true,
		"requireLineFeedAtFileEnd": true,
		"disallowMultipleLineBreaks": true,
		"disallowMixedSpacesAndTabs": true,
		"disallowTrailingWhitespace": true,
		"validateIndentation": 4,
		"validateLineBreaks": "LF",
		"requireSemicolons": true
	};

/***/ }
/******/ ]);